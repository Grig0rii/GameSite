var em = {};
/**
* @vue/shared v3.5.22
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
// @__NO_SIDE_EFFECTS__
function _a(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const n of e.split(",")) t[n] = 1;
  return (n) => n in t;
}
const it = em.NODE_ENV !== "production" ? Object.freeze({}) : {}, Kl = em.NODE_ENV !== "production" ? Object.freeze([]) : [], Bt = () => {
}, tm = () => !1, fo = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Zo = (e) => e.startsWith("onUpdate:"), pt = Object.assign, ec = (e, t) => {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}, Lp = Object.prototype.hasOwnProperty, Ke = (e, t) => Lp.call(e, t), Ae = Array.isArray, al = (e) => Er(e) === "[object Map]", nm = (e) => Er(e) === "[object Set]", Te = (e) => typeof e == "function", ct = (e) => typeof e == "string", xa = (e) => typeof e == "symbol", et = (e) => e !== null && typeof e == "object", tc = (e) => (et(e) || Te(e)) && Te(e.then) && Te(e.catch), am = Object.prototype.toString, Er = (e) => am.call(e), nc = (e) => Er(e).slice(8, -1), lm = (e) => Er(e) === "[object Object]", ac = (e) => ct(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Ti = /* @__PURE__ */ _a(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Fp = /* @__PURE__ */ _a(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Pr = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, Hp = /-\w/g, Ht = Pr(
  (e) => e.replace(Hp, (t) => t.slice(1).toUpperCase())
), zp = /\B([A-Z])/g, pa = Pr(
  (e) => e.replace(zp, "-$1").toLowerCase()
), wn = Pr((e) => e.charAt(0).toUpperCase() + e.slice(1)), Ja = Pr(
  (e) => e ? `on${wn(e)}` : ""
), $a = (e, t) => !Object.is(e, t), zl = (e, ...t) => {
  for (let n = 0; n < e.length; n++)
    e[n](...t);
}, Qo = (e, t, n, a = !1) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    writable: a,
    value: n
  });
}, zs = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
}, jp = (e) => {
  const t = ct(e) ? Number(e) : NaN;
  return isNaN(t) ? e : t;
};
let Nd;
const vo = () => Nd || (Nd = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function he(e) {
  if (Ae(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const a = e[n], l = ct(a) ? Kp(a) : he(a);
      if (l)
        for (const i in l)
          t[i] = l[i];
    }
    return t;
  } else if (ct(e) || et(e))
    return e;
}
const Wp = /;(?![^(]*\))/g, Up = /:([^]+)/, Gp = /\/\*[^]*?\*\//g;
function Kp(e) {
  const t = {};
  return e.replace(Gp, "").split(Wp).forEach((n) => {
    if (n) {
      const a = n.split(Up);
      a.length > 1 && (t[a[0].trim()] = a[1].trim());
    }
  }), t;
}
function le(e) {
  let t = "";
  if (ct(e))
    t = e;
  else if (Ae(e))
    for (let n = 0; n < e.length; n++) {
      const a = le(e[n]);
      a && (t += a + " ");
    }
  else if (et(e))
    for (const n in e)
      e[n] && (t += n + " ");
  return t.trim();
}
function Yp(e) {
  if (!e) return null;
  let { class: t, style: n } = e;
  return t && !ct(t) && (e.class = le(t)), n && (e.style = he(n)), e;
}
const qp = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", Xp = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", Jp = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics", Zp = /* @__PURE__ */ _a(qp), Qp = /* @__PURE__ */ _a(Xp), eS = /* @__PURE__ */ _a(Jp), tS = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", nS = /* @__PURE__ */ _a(tS);
function im(e) {
  return !!e || e === "";
}
const om = (e) => !!(e && e.__v_isRef === !0), Re = (e) => ct(e) ? e : e == null ? "" : Ae(e) || et(e) && (e.toString === am || !Te(e.toString)) ? om(e) ? Re(e.value) : JSON.stringify(e, rm, 2) : String(e), rm = (e, t) => om(t) ? rm(e, t.value) : al(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(
    (n, [a, l], i) => (n[ds(a, i) + " =>"] = l, n),
    {}
  )
} : nm(t) ? {
  [`Set(${t.size})`]: [...t.values()].map((n) => ds(n))
} : xa(t) ? ds(t) : et(t) && !Ae(t) && !lm(t) ? String(t) : t, ds = (e, t = "") => {
  var n;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    xa(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e
  );
};
var rt = {};
function _n(e, ...t) {
  console.warn(`[Vue warn] ${e}`, ...t);
}
let Xt;
class sm {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Xt, !t && Xt && (this.index = (Xt.scopes || (Xt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].pause();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, n;
      if (this.scopes)
        for (t = 0, n = this.scopes.length; t < n; t++)
          this.scopes[t].resume();
      for (t = 0, n = this.effects.length; t < n; t++)
        this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const n = Xt;
      try {
        return Xt = this, t();
      } finally {
        Xt = n;
      }
    } else rt.NODE_ENV !== "production" && _n("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Xt, Xt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Xt = this.prevScope, this.prevScope = void 0);
  }
  stop(t) {
    if (this._active) {
      this._active = !1;
      let n, a;
      for (n = 0, a = this.effects.length; n < a; n++)
        this.effects[n].stop();
      for (this.effects.length = 0, n = 0, a = this.cleanups.length; n < a; n++)
        this.cleanups[n]();
      if (this.cleanups.length = 0, this.scopes) {
        for (n = 0, a = this.scopes.length; n < a; n++)
          this.scopes[n].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !t) {
        const l = this.parent.scopes.pop();
        l && l !== this && (this.parent.scopes[this.index] = l, l.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Jl(e) {
  return new sm(e);
}
function um() {
  return Xt;
}
function Dt(e, t = !1) {
  Xt ? Xt.cleanups.push(e) : rt.NODE_ENV !== "production" && !t && _n(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
let lt;
const fs = /* @__PURE__ */ new WeakSet();
class cm {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Xt && Xt.active && Xt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, fs.has(this) && (fs.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || fm(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Dd(this), vm(this);
    const t = lt, n = $n;
    lt = this, $n = !0;
    try {
      return this.fn();
    } finally {
      rt.NODE_ENV !== "production" && lt !== this && _n(
        "Active effect was not restored correctly - this is likely a Vue internal bug."
      ), mm(this), lt = t, $n = n, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep)
        oc(t);
      this.deps = this.depsTail = void 0, Dd(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? fs.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    js(this) && this.run();
  }
  get dirty() {
    return js(this);
  }
}
let dm = 0, Oi, $i;
function fm(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = $i, $i = e;
    return;
  }
  e.next = Oi, Oi = e;
}
function lc() {
  dm++;
}
function ic() {
  if (--dm > 0)
    return;
  if ($i) {
    let t = $i;
    for ($i = void 0; t; ) {
      const n = t.next;
      t.next = void 0, t.flags &= -9, t = n;
    }
  }
  let e;
  for (; Oi; ) {
    let t = Oi;
    for (Oi = void 0; t; ) {
      const n = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (a) {
          e || (e = a);
        }
      t = n;
    }
  }
  if (e) throw e;
}
function vm(e) {
  for (let t = e.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function mm(e) {
  let t, n = e.depsTail, a = n;
  for (; a; ) {
    const l = a.prevDep;
    a.version === -1 ? (a === n && (n = l), oc(a), aS(a)) : t = a, a.dep.activeLink = a.prevActiveLink, a.prevActiveLink = void 0, a = l;
  }
  e.deps = t, e.depsTail = n;
}
function js(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (hm(t.dep.computed) || t.dep.version !== t.version))
      return !0;
  return !!e._dirty;
}
function hm(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Fi) || (e.globalVersion = Fi, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !js(e))))
    return;
  e.flags |= 2;
  const t = e.dep, n = lt, a = $n;
  lt = e, $n = !0;
  try {
    vm(e);
    const l = e.fn(e._value);
    (t.version === 0 || $a(l, e._value)) && (e.flags |= 128, e._value = l, t.version++);
  } catch (l) {
    throw t.version++, l;
  } finally {
    lt = n, $n = a, mm(e), e.flags &= -3;
  }
}
function oc(e, t = !1) {
  const { dep: n, prevSub: a, nextSub: l } = e;
  if (a && (a.nextSub = l, e.prevSub = void 0), l && (l.prevSub = a, e.nextSub = void 0), rt.NODE_ENV !== "production" && n.subsHead === e && (n.subsHead = l), n.subs === e && (n.subs = a, !a && n.computed)) {
    n.computed.flags &= -5;
    for (let i = n.computed.deps; i; i = i.nextDep)
      oc(i, !0);
  }
  !t && !--n.sc && n.map && n.map.delete(n.key);
}
function aS(e) {
  const { prevDep: t, nextDep: n } = e;
  t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0);
}
let $n = !0;
const gm = [];
function Bn() {
  gm.push($n), $n = !1;
}
function Mn() {
  const e = gm.pop();
  $n = e === void 0 ? !0 : e;
}
function Dd(e) {
  const { cleanup: t } = e;
  if (e.cleanup = void 0, t) {
    const n = lt;
    lt = void 0;
    try {
      t();
    } finally {
      lt = n;
    }
  }
}
let Fi = 0;
class lS {
  constructor(t, n) {
    this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class rc {
  // TODO isolatedDeclarations "__v_skip"
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0, rt.NODE_ENV !== "production" && (this.subsHead = void 0);
  }
  track(t) {
    if (!lt || !$n || lt === this.computed)
      return;
    let n = this.activeLink;
    if (n === void 0 || n.sub !== lt)
      n = this.activeLink = new lS(lt, this), lt.deps ? (n.prevDep = lt.depsTail, lt.depsTail.nextDep = n, lt.depsTail = n) : lt.deps = lt.depsTail = n, ym(n);
    else if (n.version === -1 && (n.version = this.version, n.nextDep)) {
      const a = n.nextDep;
      a.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = a), n.prevDep = lt.depsTail, n.nextDep = void 0, lt.depsTail.nextDep = n, lt.depsTail = n, lt.deps === n && (lt.deps = a);
    }
    return rt.NODE_ENV !== "production" && lt.onTrack && lt.onTrack(
      pt(
        {
          effect: lt
        },
        t
      )
    ), n;
  }
  trigger(t) {
    this.version++, Fi++, this.notify(t);
  }
  notify(t) {
    lc();
    try {
      if (rt.NODE_ENV !== "production")
        for (let n = this.subsHead; n; n = n.nextSub)
          n.sub.onTrigger && !(n.sub.flags & 8) && n.sub.onTrigger(
            pt(
              {
                effect: n.sub
              },
              t
            )
          );
      for (let n = this.subs; n; n = n.prevSub)
        n.sub.notify() && n.sub.dep.notify();
    } finally {
      ic();
    }
  }
}
function ym(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let a = t.deps; a; a = a.nextDep)
        ym(a);
    }
    const n = e.dep.subs;
    n !== e && (e.prevSub = n, n && (n.nextSub = e)), rt.NODE_ENV !== "production" && e.dep.subsHead === void 0 && (e.dep.subsHead = e), e.dep.subs = e;
  }
}
const er = /* @__PURE__ */ new WeakMap(), ll = Symbol(
  rt.NODE_ENV !== "production" ? "Object iterate" : ""
), Ws = Symbol(
  rt.NODE_ENV !== "production" ? "Map keys iterate" : ""
), Hi = Symbol(
  rt.NODE_ENV !== "production" ? "Array iterate" : ""
);
function $t(e, t, n) {
  if ($n && lt) {
    let a = er.get(e);
    a || er.set(e, a = /* @__PURE__ */ new Map());
    let l = a.get(n);
    l || (a.set(n, l = new rc()), l.map = a, l.key = n), rt.NODE_ENV !== "production" ? l.track({
      target: e,
      type: t,
      key: n
    }) : l.track();
  }
}
function Jn(e, t, n, a, l, i) {
  const o = er.get(e);
  if (!o) {
    Fi++;
    return;
  }
  const r = (s) => {
    s && (rt.NODE_ENV !== "production" ? s.trigger({
      target: e,
      type: t,
      key: n,
      newValue: a,
      oldValue: l,
      oldTarget: i
    }) : s.trigger());
  };
  if (lc(), t === "clear")
    o.forEach(r);
  else {
    const s = Ae(e), d = s && ac(n);
    if (s && n === "length") {
      const u = Number(a);
      o.forEach((c, f) => {
        (f === "length" || f === Hi || !xa(f) && f >= u) && r(c);
      });
    } else
      switch ((n !== void 0 || o.has(void 0)) && r(o.get(n)), d && r(o.get(Hi)), t) {
        case "add":
          s ? d && r(o.get("length")) : (r(o.get(ll)), al(e) && r(o.get(Ws)));
          break;
        case "delete":
          s || (r(o.get(ll)), al(e) && r(o.get(Ws)));
          break;
        case "set":
          al(e) && r(o.get(ll));
          break;
      }
  }
  ic();
}
function iS(e, t) {
  const n = er.get(e);
  return n && n.get(t);
}
function Ol(e) {
  const t = Pe(e);
  return t === e ? t : ($t(t, "iterate", Hi), sn(e) ? t : t.map(Ut));
}
function Ir(e) {
  return $t(e = Pe(e), "iterate", Hi), e;
}
const oS = {
  __proto__: null,
  [Symbol.iterator]() {
    return vs(this, Symbol.iterator, Ut);
  },
  concat(...e) {
    return Ol(this).concat(
      ...e.map((t) => Ae(t) ? Ol(t) : t)
    );
  },
  entries() {
    return vs(this, "entries", (e) => (e[1] = Ut(e[1]), e));
  },
  every(e, t) {
    return ua(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return ua(this, "filter", e, t, (n) => n.map(Ut), arguments);
  },
  find(e, t) {
    return ua(this, "find", e, t, Ut, arguments);
  },
  findIndex(e, t) {
    return ua(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return ua(this, "findLast", e, t, Ut, arguments);
  },
  findLastIndex(e, t) {
    return ua(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return ua(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return ms(this, "includes", e);
  },
  indexOf(...e) {
    return ms(this, "indexOf", e);
  },
  join(e) {
    return Ol(this).join(e);
  },
  // keys() iterator only reads `length`, no optimization required
  lastIndexOf(...e) {
    return ms(this, "lastIndexOf", e);
  },
  map(e, t) {
    return ua(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return xi(this, "pop");
  },
  push(...e) {
    return xi(this, "push", e);
  },
  reduce(e, ...t) {
    return Ad(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return Ad(this, "reduceRight", e, t);
  },
  shift() {
    return xi(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return ua(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return xi(this, "splice", e);
  },
  toReversed() {
    return Ol(this).toReversed();
  },
  toSorted(e) {
    return Ol(this).toSorted(e);
  },
  toSpliced(...e) {
    return Ol(this).toSpliced(...e);
  },
  unshift(...e) {
    return xi(this, "unshift", e);
  },
  values() {
    return vs(this, "values", Ut);
  }
};
function vs(e, t, n) {
  const a = Ir(e), l = a[t]();
  return a !== e && !sn(e) && (l._next = l.next, l.next = () => {
    const i = l._next();
    return i.done || (i.value = n(i.value)), i;
  }), l;
}
const rS = Array.prototype;
function ua(e, t, n, a, l, i) {
  const o = Ir(e), r = o !== e && !sn(e), s = o[t];
  if (s !== rS[t]) {
    const c = s.apply(e, i);
    return r ? Ut(c) : c;
  }
  let d = n;
  o !== e && (r ? d = function(c, f) {
    return n.call(this, Ut(c), f, e);
  } : n.length > 2 && (d = function(c, f) {
    return n.call(this, c, f, e);
  }));
  const u = s.call(o, d, a);
  return r && l ? l(u) : u;
}
function Ad(e, t, n, a) {
  const l = Ir(e);
  let i = n;
  return l !== e && (sn(e) ? n.length > 3 && (i = function(o, r, s) {
    return n.call(this, o, r, s, e);
  }) : i = function(o, r, s) {
    return n.call(this, o, Ut(r), s, e);
  }), l[t](i, ...a);
}
function ms(e, t, n) {
  const a = Pe(e);
  $t(a, "iterate", Hi);
  const l = a[t](...n);
  return (l === -1 || l === !1) && zi(n[0]) ? (n[0] = Pe(n[0]), a[t](...n)) : l;
}
function xi(e, t, n = []) {
  Bn(), lc();
  const a = Pe(e)[t].apply(e, n);
  return ic(), Mn(), a;
}
const sS = /* @__PURE__ */ _a("__proto__,__v_isRef,__isVue"), bm = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(xa)
);
function uS(e) {
  xa(e) || (e = String(e));
  const t = Pe(this);
  return $t(t, "has", e), t.hasOwnProperty(e);
}
class pm {
  constructor(t = !1, n = !1) {
    this._isReadonly = t, this._isShallow = n;
  }
  get(t, n, a) {
    if (n === "__v_skip") return t.__v_skip;
    const l = this._isReadonly, i = this._isShallow;
    if (n === "__v_isReactive")
      return !l;
    if (n === "__v_isReadonly")
      return l;
    if (n === "__v_isShallow")
      return i;
    if (n === "__v_raw")
      return a === (l ? i ? Cm : km : i ? xm : _m).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(a) ? t : void 0;
    const o = Ae(t);
    if (!l) {
      let s;
      if (o && (s = oS[n]))
        return s;
      if (n === "hasOwnProperty")
        return uS;
    }
    const r = Reflect.get(
      t,
      n,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      mt(t) ? t : a
    );
    if ((xa(n) ? bm.has(n) : sS(n)) || (l || $t(t, "get", n), i))
      return r;
    if (mt(r)) {
      const s = o && ac(n) ? r : r.value;
      return l && et(s) ? vl(s) : s;
    }
    return et(r) ? l ? vl(r) : It(r) : r;
  }
}
class Sm extends pm {
  constructor(t = !1) {
    super(!1, t);
  }
  set(t, n, a, l) {
    let i = t[n];
    if (!this._isShallow) {
      const s = na(i);
      if (!sn(a) && !na(a) && (i = Pe(i), a = Pe(a)), !Ae(t) && mt(i) && !mt(a))
        return s ? (rt.NODE_ENV !== "production" && _n(
          `Set operation on key "${String(n)}" failed: target is readonly.`,
          t[n]
        ), !0) : (i.value = a, !0);
    }
    const o = Ae(t) && ac(n) ? Number(n) < t.length : Ke(t, n), r = Reflect.set(
      t,
      n,
      a,
      mt(t) ? t : l
    );
    return t === Pe(l) && (o ? $a(a, i) && Jn(t, "set", n, a, i) : Jn(t, "add", n, a)), r;
  }
  deleteProperty(t, n) {
    const a = Ke(t, n), l = t[n], i = Reflect.deleteProperty(t, n);
    return i && a && Jn(t, "delete", n, void 0, l), i;
  }
  has(t, n) {
    const a = Reflect.has(t, n);
    return (!xa(n) || !bm.has(n)) && $t(t, "has", n), a;
  }
  ownKeys(t) {
    return $t(
      t,
      "iterate",
      Ae(t) ? "length" : ll
    ), Reflect.ownKeys(t);
  }
}
class wm extends pm {
  constructor(t = !1) {
    super(!0, t);
  }
  set(t, n) {
    return rt.NODE_ENV !== "production" && _n(
      `Set operation on key "${String(n)}" failed: target is readonly.`,
      t
    ), !0;
  }
  deleteProperty(t, n) {
    return rt.NODE_ENV !== "production" && _n(
      `Delete operation on key "${String(n)}" failed: target is readonly.`,
      t
    ), !0;
  }
}
const cS = /* @__PURE__ */ new Sm(), dS = /* @__PURE__ */ new wm(), fS = /* @__PURE__ */ new Sm(!0), vS = /* @__PURE__ */ new wm(!0), Us = (e) => e, Do = (e) => Reflect.getPrototypeOf(e);
function mS(e, t, n) {
  return function(...a) {
    const l = this.__v_raw, i = Pe(l), o = al(i), r = e === "entries" || e === Symbol.iterator && o, s = e === "keys" && o, d = l[e](...a), u = n ? Us : t ? tr : Ut;
    return !t && $t(
      i,
      "iterate",
      s ? Ws : ll
    ), {
      // iterator protocol
      next() {
        const { value: c, done: f } = d.next();
        return f ? { value: c, done: f } : {
          value: r ? [u(c[0]), u(c[1])] : u(c),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Ao(e) {
  return function(...t) {
    if (rt.NODE_ENV !== "production") {
      const n = t[0] ? `on key "${t[0]}" ` : "";
      _n(
        `${wn(e)} operation ${n}failed: target is readonly.`,
        Pe(this)
      );
    }
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function hS(e, t) {
  const n = {
    get(l) {
      const i = this.__v_raw, o = Pe(i), r = Pe(l);
      e || ($a(l, r) && $t(o, "get", l), $t(o, "get", r));
      const { has: s } = Do(o), d = t ? Us : e ? tr : Ut;
      if (s.call(o, l))
        return d(i.get(l));
      if (s.call(o, r))
        return d(i.get(r));
      i !== o && i.get(l);
    },
    get size() {
      const l = this.__v_raw;
      return !e && $t(Pe(l), "iterate", ll), l.size;
    },
    has(l) {
      const i = this.__v_raw, o = Pe(i), r = Pe(l);
      return e || ($a(l, r) && $t(o, "has", l), $t(o, "has", r)), l === r ? i.has(l) : i.has(l) || i.has(r);
    },
    forEach(l, i) {
      const o = this, r = o.__v_raw, s = Pe(r), d = t ? Us : e ? tr : Ut;
      return !e && $t(s, "iterate", ll), r.forEach((u, c) => l.call(i, d(u), d(c), o));
    }
  };
  return pt(
    n,
    e ? {
      add: Ao("add"),
      set: Ao("set"),
      delete: Ao("delete"),
      clear: Ao("clear")
    } : {
      add(l) {
        !t && !sn(l) && !na(l) && (l = Pe(l));
        const i = Pe(this);
        return Do(i).has.call(i, l) || (i.add(l), Jn(i, "add", l, l)), this;
      },
      set(l, i) {
        !t && !sn(i) && !na(i) && (i = Pe(i));
        const o = Pe(this), { has: r, get: s } = Do(o);
        let d = r.call(o, l);
        d ? rt.NODE_ENV !== "production" && Td(o, r, l) : (l = Pe(l), d = r.call(o, l));
        const u = s.call(o, l);
        return o.set(l, i), d ? $a(i, u) && Jn(o, "set", l, i, u) : Jn(o, "add", l, i), this;
      },
      delete(l) {
        const i = Pe(this), { has: o, get: r } = Do(i);
        let s = o.call(i, l);
        s ? rt.NODE_ENV !== "production" && Td(i, o, l) : (l = Pe(l), s = o.call(i, l));
        const d = r ? r.call(i, l) : void 0, u = i.delete(l);
        return s && Jn(i, "delete", l, void 0, d), u;
      },
      clear() {
        const l = Pe(this), i = l.size !== 0, o = rt.NODE_ENV !== "production" ? al(l) ? new Map(l) : new Set(l) : void 0, r = l.clear();
        return i && Jn(
          l,
          "clear",
          void 0,
          void 0,
          o
        ), r;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((l) => {
    n[l] = mS(l, e, t);
  }), n;
}
function Nr(e, t) {
  const n = hS(e, t);
  return (a, l, i) => l === "__v_isReactive" ? !e : l === "__v_isReadonly" ? e : l === "__v_raw" ? a : Reflect.get(
    Ke(n, l) && l in a ? n : a,
    l,
    i
  );
}
const gS = {
  get: /* @__PURE__ */ Nr(!1, !1)
}, yS = {
  get: /* @__PURE__ */ Nr(!1, !0)
}, bS = {
  get: /* @__PURE__ */ Nr(!0, !1)
}, pS = {
  get: /* @__PURE__ */ Nr(!0, !0)
};
function Td(e, t, n) {
  const a = Pe(n);
  if (a !== n && t.call(e, a)) {
    const l = nc(e);
    _n(
      `Reactive ${l} contains both the raw and reactive versions of the same object${l === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const _m = /* @__PURE__ */ new WeakMap(), xm = /* @__PURE__ */ new WeakMap(), km = /* @__PURE__ */ new WeakMap(), Cm = /* @__PURE__ */ new WeakMap();
function SS(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function wS(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : SS(nc(e));
}
function It(e) {
  return na(e) ? e : Dr(
    e,
    !1,
    cS,
    gS,
    _m
  );
}
function Vm(e) {
  return Dr(
    e,
    !1,
    fS,
    yS,
    xm
  );
}
function vl(e) {
  return Dr(
    e,
    !0,
    dS,
    bS,
    km
  );
}
function Qn(e) {
  return Dr(
    e,
    !0,
    vS,
    pS,
    Cm
  );
}
function Dr(e, t, n, a, l) {
  if (!et(e))
    return rt.NODE_ENV !== "production" && _n(
      `value cannot be made ${t ? "readonly" : "reactive"}: ${String(
        e
      )}`
    ), e;
  if (e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const i = wS(e);
  if (i === 0)
    return e;
  const o = l.get(e);
  if (o)
    return o;
  const r = new Proxy(
    e,
    i === 2 ? a : n
  );
  return l.set(e, r), r;
}
function il(e) {
  return na(e) ? il(e.__v_raw) : !!(e && e.__v_isReactive);
}
function na(e) {
  return !!(e && e.__v_isReadonly);
}
function sn(e) {
  return !!(e && e.__v_isShallow);
}
function zi(e) {
  return e ? !!e.__v_raw : !1;
}
function Pe(e) {
  const t = e && e.__v_raw;
  return t ? Pe(t) : e;
}
function Em(e) {
  return !Ke(e, "__v_skip") && Object.isExtensible(e) && Qo(e, "__v_skip", !0), e;
}
const Ut = (e) => et(e) ? It(e) : e, tr = (e) => et(e) ? vl(e) : e;
function mt(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function Z(e) {
  return Pm(e, !1);
}
function fe(e) {
  return Pm(e, !0);
}
function Pm(e, t) {
  return mt(e) ? e : new _S(e, t);
}
class _S {
  constructor(t, n) {
    this.dep = new rc(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = n ? t : Pe(t), this._value = n ? t : Ut(t), this.__v_isShallow = n;
  }
  get value() {
    return rt.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track(), this._value;
  }
  set value(t) {
    const n = this._rawValue, a = this.__v_isShallow || sn(t) || na(t);
    t = a ? t : Pe(t), $a(t, n) && (this._rawValue = t, this._value = a ? t : Ut(t), rt.NODE_ENV !== "production" ? this.dep.trigger({
      target: this,
      type: "set",
      key: "value",
      newValue: t,
      oldValue: n
    }) : this.dep.trigger());
  }
}
function bt(e) {
  return mt(e) ? e.value : e;
}
function un(e) {
  return Te(e) ? e() : bt(e);
}
const xS = {
  get: (e, t, n) => t === "__v_raw" ? e : bt(Reflect.get(e, t, n)),
  set: (e, t, n, a) => {
    const l = e[t];
    return mt(l) && !mt(n) ? (l.value = n, !0) : Reflect.set(e, t, n, a);
  }
};
function Im(e) {
  return il(e) ? e : new Proxy(e, xS);
}
function ci(e) {
  rt.NODE_ENV !== "production" && !zi(e) && _n("toRefs() expects a reactive object but received a plain one.");
  const t = Ae(e) ? new Array(e.length) : {};
  for (const n in e)
    t[n] = Nm(e, n);
  return t;
}
class kS {
  constructor(t, n, a) {
    this._object = t, this._key = n, this._defaultValue = a, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const t = this._object[this._key];
    return this._value = t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return iS(Pe(this._object), this._key);
  }
}
class CS {
  constructor(t) {
    this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function R(e, t, n) {
  return mt(e) ? e : Te(e) ? new CS(e) : et(e) && arguments.length > 1 ? Nm(e, t, n) : Z(e);
}
function Nm(e, t, n) {
  const a = e[t];
  return mt(a) ? a : new kS(e, t, n);
}
class VS {
  constructor(t, n, a) {
    this.fn = t, this.setter = n, this._value = void 0, this.dep = new rc(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Fi - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = a;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    lt !== this)
      return fm(this, !0), !0;
  }
  get value() {
    const t = rt.NODE_ENV !== "production" ? this.dep.track({
      target: this,
      type: "get",
      key: "value"
    }) : this.dep.track();
    return hm(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter ? this.setter(t) : rt.NODE_ENV !== "production" && _n("Write operation failed: computed value is readonly");
  }
}
function ES(e, t, n = !1) {
  let a, l;
  return Te(e) ? a = e : (a = e.get, l = e.set), new VS(a, l, n);
}
const To = {}, nr = /* @__PURE__ */ new WeakMap();
let Za;
function PS(e, t = !1, n = Za) {
  if (n) {
    let a = nr.get(n);
    a || nr.set(n, a = []), a.push(e);
  } else rt.NODE_ENV !== "production" && !t && _n(
    "onWatcherCleanup() was called when there was no active watcher to associate with."
  );
}
function IS(e, t, n = it) {
  const { immediate: a, deep: l, once: i, scheduler: o, augmentJob: r, call: s } = n, d = (k) => {
    (n.onWarn || _n)(
      "Invalid watch source: ",
      k,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, u = (k) => l ? k : sn(k) || l === !1 || l === 0 ? ya(k, 1) : ya(k);
  let c, f, v, m, h = !1, g = !1;
  if (mt(e) ? (f = () => e.value, h = sn(e)) : il(e) ? (f = () => u(e), h = !0) : Ae(e) ? (g = !0, h = e.some((k) => il(k) || sn(k)), f = () => e.map((k) => {
    if (mt(k))
      return k.value;
    if (il(k))
      return u(k);
    if (Te(k))
      return s ? s(k, 2) : k();
    rt.NODE_ENV !== "production" && d(k);
  })) : Te(e) ? t ? f = s ? () => s(e, 2) : e : f = () => {
    if (v) {
      Bn();
      try {
        v();
      } finally {
        Mn();
      }
    }
    const k = Za;
    Za = c;
    try {
      return s ? s(e, 3, [m]) : e(m);
    } finally {
      Za = k;
    }
  } : (f = Bt, rt.NODE_ENV !== "production" && d(e)), t && l) {
    const k = f, P = l === !0 ? 1 / 0 : l;
    f = () => ya(k(), P);
  }
  const p = um(), y = () => {
    c.stop(), p && p.active && ec(p.effects, c);
  };
  if (i && t) {
    const k = t;
    t = (...P) => {
      k(...P), y();
    };
  }
  let _ = g ? new Array(e.length).fill(To) : To;
  const E = (k) => {
    if (!(!(c.flags & 1) || !c.dirty && !k))
      if (t) {
        const P = c.run();
        if (l || h || (g ? P.some((A, D) => $a(A, _[D])) : $a(P, _))) {
          v && v();
          const A = Za;
          Za = c;
          try {
            const D = [
              P,
              // pass undefined as the old value when it's changed for the first time
              _ === To ? void 0 : g && _[0] === To ? [] : _,
              m
            ];
            _ = P, s ? s(t, 3, D) : (
              // @ts-expect-error
              t(...D)
            );
          } finally {
            Za = A;
          }
        }
      } else
        c.run();
  };
  return r && r(E), c = new cm(f), c.scheduler = o ? () => o(E, !1) : E, m = (k) => PS(k, !1, c), v = c.onStop = () => {
    const k = nr.get(c);
    if (k) {
      if (s)
        s(k, 4);
      else
        for (const P of k) P();
      nr.delete(c);
    }
  }, rt.NODE_ENV !== "production" && (c.onTrack = n.onTrack, c.onTrigger = n.onTrigger), t ? a ? E(!0) : _ = c.run() : o ? o(E.bind(null, !0), !0) : c.run(), y.pause = c.pause.bind(c), y.resume = c.resume.bind(c), y.stop = y, y;
}
function ya(e, t = 1 / 0, n) {
  if (t <= 0 || !et(e) || e.__v_skip || (n = n || /* @__PURE__ */ new Map(), (n.get(e) || 0) >= t))
    return e;
  if (n.set(e, t), t--, mt(e))
    ya(e.value, t, n);
  else if (Ae(e))
    for (let a = 0; a < e.length; a++)
      ya(e[a], t, n);
  else if (nm(e) || al(e))
    e.forEach((a) => {
      ya(a, t, n);
    });
  else if (lm(e)) {
    for (const a in e)
      ya(e[a], t, n);
    for (const a of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, a) && ya(e[a], t, n);
  }
  return e;
}
var q = {};
const ol = [];
function jo(e) {
  ol.push(e);
}
function Wo() {
  ol.pop();
}
let hs = !1;
function be(e, ...t) {
  if (hs) return;
  hs = !0, Bn();
  const n = ol.length ? ol[ol.length - 1].component : null, a = n && n.appContext.config.warnHandler, l = NS();
  if (a)
    di(
      a,
      n,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        e + t.map((i) => {
          var o, r;
          return (r = (o = i.toString) == null ? void 0 : o.call(i)) != null ? r : JSON.stringify(i);
        }).join(""),
        n && n.proxy,
        l.map(
          ({ vnode: i }) => `at <${Mr(n, i.type)}>`
        ).join(`
`),
        l
      ]
    );
  else {
    const i = [`[Vue warn]: ${e}`, ...t];
    l.length && i.push(`
`, ...DS(l)), console.warn(...i);
  }
  Mn(), hs = !1;
}
function NS() {
  let e = ol[ol.length - 1];
  if (!e)
    return [];
  const t = [];
  for (; e; ) {
    const n = t[0];
    n && n.vnode === e ? n.recurseCount++ : t.push({
      vnode: e,
      recurseCount: 0
    });
    const a = e.component && e.component.parent;
    e = a && a.vnode;
  }
  return t;
}
function DS(e) {
  const t = [];
  return e.forEach((n, a) => {
    t.push(...a === 0 ? [] : [`
`], ...AS(n));
  }), t;
}
function AS({ vnode: e, recurseCount: t }) {
  const n = t > 0 ? `... (${t} recursive calls)` : "", a = e.component ? e.component.parent == null : !1, l = ` at <${Mr(
    e.component,
    e.type,
    a
  )}`, i = ">" + n;
  return e.props ? [l, ...TS(e.props), i] : [l + i];
}
function TS(e) {
  const t = [], n = Object.keys(e);
  return n.slice(0, 3).forEach((a) => {
    t.push(...Dm(a, e[a]));
  }), n.length > 3 && t.push(" ..."), t;
}
function Dm(e, t, n) {
  return ct(t) ? (t = JSON.stringify(t), n ? t : [`${e}=${t}`]) : typeof t == "number" || typeof t == "boolean" || t == null ? n ? t : [`${e}=${t}`] : mt(t) ? (t = Dm(e, Pe(t.value), !0), n ? t : [`${e}=Ref<`, t, ">"]) : Te(t) ? [`${e}=fn${t.name ? `<${t.name}>` : ""}`] : (t = Pe(t), n ? t : [`${e}=`, t]);
}
function OS(e, t) {
  q.NODE_ENV !== "production" && e !== void 0 && (typeof e != "number" ? be(`${t} is not a valid number - got ${JSON.stringify(e)}.`) : isNaN(e) && be(`${t} is NaN - the duration expression might be incorrect.`));
}
const sc = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush",
  15: "component update",
  16: "app unmount cleanup function"
};
function di(e, t, n, a) {
  try {
    return a ? e(...a) : e();
  } catch (l) {
    mo(l, t, n);
  }
}
function Rn(e, t, n, a) {
  if (Te(e)) {
    const l = di(e, t, n, a);
    return l && tc(l) && l.catch((i) => {
      mo(i, t, n);
    }), l;
  }
  if (Ae(e)) {
    const l = [];
    for (let i = 0; i < e.length; i++)
      l.push(Rn(e[i], t, n, a));
    return l;
  } else q.NODE_ENV !== "production" && be(
    `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof e}`
  );
}
function mo(e, t, n, a = !0) {
  const l = t ? t.vnode : null, { errorHandler: i, throwUnhandledErrorInProduction: o } = t && t.appContext.config || it;
  if (t) {
    let r = t.parent;
    const s = t.proxy, d = q.NODE_ENV !== "production" ? sc[n] : `https://vuejs.org/error-reference/#runtime-${n}`;
    for (; r; ) {
      const u = r.ec;
      if (u) {
        for (let c = 0; c < u.length; c++)
          if (u[c](e, s, d) === !1)
            return;
      }
      r = r.parent;
    }
    if (i) {
      Bn(), di(i, null, 10, [
        e,
        s,
        d
      ]), Mn();
      return;
    }
  }
  $S(e, n, l, a, o);
}
function $S(e, t, n, a = !0, l = !1) {
  if (q.NODE_ENV !== "production") {
    const i = sc[t];
    if (n && jo(n), be(`Unhandled error${i ? ` during execution of ${i}` : ""}`), n && Wo(), a)
      throw e;
    console.error(e);
  } else {
    if (l)
      throw e;
    console.error(e);
  }
}
const rn = [];
let Xn = -1;
const Yl = [];
let Aa = null, jl = 0;
const Am = /* @__PURE__ */ Promise.resolve();
let ar = null;
const BS = 100;
function He(e) {
  const t = ar || Am;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function MS(e) {
  let t = Xn + 1, n = rn.length;
  for (; t < n; ) {
    const a = t + n >>> 1, l = rn[a], i = ji(l);
    i < e || i === e && l.flags & 2 ? t = a + 1 : n = a;
  }
  return t;
}
function Ar(e) {
  if (!(e.flags & 1)) {
    const t = ji(e), n = rn[rn.length - 1];
    !n || // fast path when the job id is larger than the tail
    !(e.flags & 2) && t >= ji(n) ? rn.push(e) : rn.splice(MS(t), 0, e), e.flags |= 1, Tm();
  }
}
function Tm() {
  ar || (ar = Am.then(Bm));
}
function Om(e) {
  Ae(e) ? Yl.push(...e) : Aa && e.id === -1 ? Aa.splice(jl + 1, 0, e) : e.flags & 1 || (Yl.push(e), e.flags |= 1), Tm();
}
function Od(e, t, n = Xn + 1) {
  for (q.NODE_ENV !== "production" && (t = t || /* @__PURE__ */ new Map()); n < rn.length; n++) {
    const a = rn[n];
    if (a && a.flags & 2) {
      if (e && a.id !== e.uid || q.NODE_ENV !== "production" && uc(t, a))
        continue;
      rn.splice(n, 1), n--, a.flags & 4 && (a.flags &= -2), a(), a.flags & 4 || (a.flags &= -2);
    }
  }
}
function $m(e) {
  if (Yl.length) {
    const t = [...new Set(Yl)].sort(
      (n, a) => ji(n) - ji(a)
    );
    if (Yl.length = 0, Aa) {
      Aa.push(...t);
      return;
    }
    for (Aa = t, q.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map()), jl = 0; jl < Aa.length; jl++) {
      const n = Aa[jl];
      q.NODE_ENV !== "production" && uc(e, n) || (n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2);
    }
    Aa = null, jl = 0;
  }
}
const ji = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function Bm(e) {
  q.NODE_ENV !== "production" && (e = e || /* @__PURE__ */ new Map());
  const t = q.NODE_ENV !== "production" ? (n) => uc(e, n) : Bt;
  try {
    for (Xn = 0; Xn < rn.length; Xn++) {
      const n = rn[Xn];
      if (n && !(n.flags & 8)) {
        if (q.NODE_ENV !== "production" && t(n))
          continue;
        n.flags & 4 && (n.flags &= -2), di(
          n,
          n.i,
          n.i ? 15 : 14
        ), n.flags & 4 || (n.flags &= -2);
      }
    }
  } finally {
    for (; Xn < rn.length; Xn++) {
      const n = rn[Xn];
      n && (n.flags &= -2);
    }
    Xn = -1, rn.length = 0, $m(e), ar = null, (rn.length || Yl.length) && Bm(e);
  }
}
function uc(e, t) {
  const n = e.get(t) || 0;
  if (n > BS) {
    const a = t.i, l = a && wc(a.type);
    return mo(
      `Maximum recursive updates exceeded${l ? ` in component <${l}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,
      null,
      10
    ), !0;
  }
  return e.set(t, n + 1), !1;
}
let On = !1;
const Uo = /* @__PURE__ */ new Map();
q.NODE_ENV !== "production" && (vo().__VUE_HMR_RUNTIME__ = {
  createRecord: gs(Mm),
  rerender: gs(FS),
  reload: gs(HS)
});
const ml = /* @__PURE__ */ new Map();
function RS(e) {
  const t = e.type.__hmrId;
  let n = ml.get(t);
  n || (Mm(t, e.type), n = ml.get(t)), n.instances.add(e);
}
function LS(e) {
  ml.get(e.type.__hmrId).instances.delete(e);
}
function Mm(e, t) {
  return ml.has(e) ? !1 : (ml.set(e, {
    initialDef: lr(t),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function lr(e) {
  return Ih(e) ? e.__vccOpts : e;
}
function FS(e, t) {
  const n = ml.get(e);
  n && (n.initialDef.render = t, [...n.instances].forEach((a) => {
    t && (a.render = t, lr(a.type).render = t), a.renderCache = [], On = !0, a.job.flags & 8 || a.update(), On = !1;
  }));
}
function HS(e, t) {
  const n = ml.get(e);
  if (!n) return;
  t = lr(t), $d(n.initialDef, t);
  const a = [...n.instances];
  for (let l = 0; l < a.length; l++) {
    const i = a[l], o = lr(i.type);
    let r = Uo.get(o);
    r || (o !== n.initialDef && $d(o, t), Uo.set(o, r = /* @__PURE__ */ new Set())), r.add(i), i.appContext.propsCache.delete(i.type), i.appContext.emitsCache.delete(i.type), i.appContext.optionsCache.delete(i.type), i.ceReload ? (r.add(i), i.ceReload(t.styles), r.delete(i)) : i.parent ? Ar(() => {
      i.job.flags & 8 || (On = !0, i.parent.update(), On = !1, r.delete(i));
    }) : i.appContext.reload ? i.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    ), i.root.ce && i !== i.root && i.root.ce._removeChildStyle(o);
  }
  Om(() => {
    Uo.clear();
  });
}
function $d(e, t) {
  pt(e, t);
  for (const n in e)
    n !== "__file" && !(n in t) && delete e[n];
}
function gs(e) {
  return (t, n) => {
    try {
      return e(t, n);
    } catch (a) {
      console.error(a), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let Zn, Ni = [], Gs = !1;
function ho(e, ...t) {
  Zn ? Zn.emit(e, ...t) : Gs || Ni.push({ event: e, args: t });
}
function Rm(e, t) {
  var n, a;
  Zn = e, Zn ? (Zn.enabled = !0, Ni.forEach(({ event: l, args: i }) => Zn.emit(l, ...i)), Ni = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  // eslint-disable-next-line no-restricted-syntax
  !((a = (n = window.navigator) == null ? void 0 : n.userAgent) != null && a.includes("jsdom")) ? ((t.__VUE_DEVTOOLS_HOOK_REPLAY__ = t.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((i) => {
    Rm(i, t);
  }), setTimeout(() => {
    Zn || (t.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Gs = !0, Ni = []);
  }, 3e3)) : (Gs = !0, Ni = []);
}
function zS(e, t) {
  ho("app:init", e, t, {
    Fragment: ye,
    Text: xl,
    Comment: _t,
    Static: Ko
  });
}
function jS(e) {
  ho("app:unmount", e);
}
const WS = /* @__PURE__ */ cc(
  "component:added"
  /* COMPONENT_ADDED */
), Lm = /* @__PURE__ */ cc(
  "component:updated"
  /* COMPONENT_UPDATED */
), US = /* @__PURE__ */ cc(
  "component:removed"
  /* COMPONENT_REMOVED */
), GS = (e) => {
  Zn && typeof Zn.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !Zn.cleanupBuffer(e) && US(e);
};
// @__NO_SIDE_EFFECTS__
function cc(e) {
  return (t) => {
    ho(
      e,
      t.appContext.app,
      t.uid,
      t.parent ? t.parent.uid : void 0,
      t
    );
  };
}
const KS = /* @__PURE__ */ Fm(
  "perf:start"
  /* PERFORMANCE_START */
), YS = /* @__PURE__ */ Fm(
  "perf:end"
  /* PERFORMANCE_END */
);
function Fm(e) {
  return (t, n, a) => {
    ho(e, t.appContext.app, t.uid, t, n, a);
  };
}
function qS(e, t, n) {
  ho(
    "component:emit",
    e.appContext.app,
    e,
    t,
    n
  );
}
let Nt = null, Hm = null;
function ir(e) {
  const t = Nt;
  return Nt = e, Hm = e && e.type.__scopeId || null, t;
}
function ge(e, t = Nt, n) {
  if (!t || e._n)
    return e;
  const a = (...l) => {
    a._d && cr(-1);
    const i = ir(t);
    let o;
    try {
      o = e(...l);
    } finally {
      ir(i), a._d && cr(1);
    }
    return q.NODE_ENV !== "production" && Lm(t), o;
  };
  return a._n = !0, a._c = !0, a._d = !0, a;
}
function zm(e) {
  Fp(e) && be("Do not use built-in directive ids as custom directive id: " + e);
}
function dt(e, t) {
  if (Nt === null)
    return q.NODE_ENV !== "production" && be("withDirectives can only be used inside render functions."), e;
  const n = Br(Nt), a = e.dirs || (e.dirs = []);
  for (let l = 0; l < t.length; l++) {
    let [i, o, r, s = it] = t[l];
    i && (Te(i) && (i = {
      mounted: i,
      updated: i
    }), i.deep && ya(o), a.push({
      dir: i,
      instance: n,
      value: o,
      oldValue: void 0,
      arg: r,
      modifiers: s
    }));
  }
  return e;
}
function Ga(e, t, n, a) {
  const l = e.dirs, i = t && t.dirs;
  for (let o = 0; o < l.length; o++) {
    const r = l[o];
    i && (r.oldValue = i[o].value);
    let s = r.dir[a];
    s && (Bn(), Rn(s, n, 8, [
      e.el,
      r,
      e,
      t
    ]), Mn());
  }
}
const jm = Symbol("_vte"), Wm = (e) => e.__isTeleport, rl = (e) => e && (e.disabled || e.disabled === ""), Bd = (e) => e && (e.defer || e.defer === ""), Md = (e) => typeof SVGElement < "u" && e instanceof SVGElement, Rd = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement, Ks = (e, t) => {
  const n = e && e.to;
  if (ct(n))
    if (t) {
      const a = t(n);
      return q.NODE_ENV !== "production" && !a && !rl(e) && be(
        `Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), a;
    } else
      return q.NODE_ENV !== "production" && be(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return q.NODE_ENV !== "production" && !n && !rl(e) && be(`Invalid Teleport target: ${n}`), n;
}, Um = {
  name: "Teleport",
  __isTeleport: !0,
  process(e, t, n, a, l, i, o, r, s, d) {
    const {
      mc: u,
      pc: c,
      pbc: f,
      o: { insert: v, querySelector: m, createText: h, createComment: g }
    } = d, p = rl(t.props);
    let { shapeFlag: y, children: _, dynamicChildren: E } = t;
    if (q.NODE_ENV !== "production" && On && (s = !1, E = null), e == null) {
      const k = t.el = q.NODE_ENV !== "production" ? g("teleport start") : h(""), P = t.anchor = q.NODE_ENV !== "production" ? g("teleport end") : h("");
      v(k, n, a), v(P, n, a);
      const A = (N, V) => {
        y & 16 && u(
          _,
          N,
          V,
          l,
          i,
          o,
          r,
          s
        );
      }, D = () => {
        const N = t.target = Ks(t.props, m), V = Gm(N, t, h, v);
        N ? (o !== "svg" && Md(N) ? o = "svg" : o !== "mathml" && Rd(N) && (o = "mathml"), l && l.isCE && (l.ce._teleportTargets || (l.ce._teleportTargets = /* @__PURE__ */ new Set())).add(N), p || (A(N, V), Go(t, !1))) : q.NODE_ENV !== "production" && !p && be(
          "Invalid Teleport target on mount:",
          N,
          `(${typeof N})`
        );
      };
      p && (A(n, P), Go(t, !0)), Bd(t.props) ? (t.el.__isMounted = !1, ln(() => {
        D(), delete t.el.__isMounted;
      }, i)) : D();
    } else {
      if (Bd(t.props) && e.el.__isMounted === !1) {
        ln(() => {
          Um.process(
            e,
            t,
            n,
            a,
            l,
            i,
            o,
            r,
            s,
            d
          );
        }, i);
        return;
      }
      t.el = e.el, t.targetStart = e.targetStart;
      const k = t.anchor = e.anchor, P = t.target = e.target, A = t.targetAnchor = e.targetAnchor, D = rl(e.props), N = D ? n : P, V = D ? k : A;
      if (o === "svg" || Md(P) ? o = "svg" : (o === "mathml" || Rd(P)) && (o = "mathml"), E ? (f(
        e.dynamicChildren,
        E,
        N,
        l,
        i,
        o,
        r
      ), Mi(e, t, q.NODE_ENV === "production")) : s || c(
        e,
        t,
        N,
        V,
        l,
        i,
        o,
        r,
        !1
      ), p)
        D ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Oo(
          t,
          n,
          k,
          d,
          1
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const I = t.target = Ks(
          t.props,
          m
        );
        I ? Oo(
          t,
          I,
          null,
          d,
          0
        ) : q.NODE_ENV !== "production" && be(
          "Invalid Teleport target on update:",
          P,
          `(${typeof P})`
        );
      } else D && Oo(
        t,
        P,
        A,
        d,
        1
      );
      Go(t, p);
    }
  },
  remove(e, t, n, { um: a, o: { remove: l } }, i) {
    const {
      shapeFlag: o,
      children: r,
      anchor: s,
      targetStart: d,
      targetAnchor: u,
      target: c,
      props: f
    } = e;
    if (c && (l(d), l(u)), i && l(s), o & 16) {
      const v = i || !rl(f);
      for (let m = 0; m < r.length; m++) {
        const h = r[m];
        a(
          h,
          t,
          n,
          v,
          !!h.dynamicChildren
        );
      }
    }
  },
  move: Oo,
  hydrate: XS
};
function Oo(e, t, n, { o: { insert: a }, m: l }, i = 2) {
  i === 0 && a(e.targetAnchor, t, n);
  const { el: o, anchor: r, shapeFlag: s, children: d, props: u } = e, c = i === 2;
  if (c && a(o, t, n), (!c || rl(u)) && s & 16)
    for (let f = 0; f < d.length; f++)
      l(
        d[f],
        t,
        n,
        2
      );
  c && a(r, t, n);
}
function XS(e, t, n, a, l, i, {
  o: { nextSibling: o, parentNode: r, querySelector: s, insert: d, createText: u }
}, c) {
  function f(h, g, p, y) {
    g.anchor = c(
      o(h),
      g,
      r(h),
      n,
      a,
      l,
      i
    ), g.targetStart = p, g.targetAnchor = y;
  }
  const v = t.target = Ks(
    t.props,
    s
  ), m = rl(t.props);
  if (v) {
    const h = v._lpa || v.firstChild;
    if (t.shapeFlag & 16)
      if (m)
        f(
          e,
          t,
          h,
          h && o(h)
        );
      else {
        t.anchor = o(e);
        let g = h;
        for (; g; ) {
          if (g && g.nodeType === 8) {
            if (g.data === "teleport start anchor")
              t.targetStart = g;
            else if (g.data === "teleport anchor") {
              t.targetAnchor = g, v._lpa = t.targetAnchor && o(t.targetAnchor);
              break;
            }
          }
          g = o(g);
        }
        t.targetAnchor || Gm(v, t, u, d), c(
          h && o(h),
          t,
          v,
          n,
          a,
          l,
          i
        );
      }
    Go(t, m);
  } else m && t.shapeFlag & 16 && f(e, t, e, o(e));
  return t.anchor && o(t.anchor);
}
const JS = Um;
function Go(e, t) {
  const n = e.ctx;
  if (n && n.ut) {
    let a, l;
    for (t ? (a = e.el, l = e.anchor) : (a = e.targetStart, l = e.targetAnchor); a && a !== l; )
      a.nodeType === 1 && a.setAttribute("data-v-owner", n.uid), a = a.nextSibling;
    n.ut();
  }
}
function Gm(e, t, n, a) {
  const l = t.targetStart = n(""), i = t.targetAnchor = n("");
  return l[jm] = i, e && (a(l, e), a(i, e)), i;
}
const va = Symbol("_leaveCb"), $o = Symbol("_enterCb");
function Km() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return At(() => {
    e.isMounted = !0;
  }), Wt(() => {
    e.isUnmounting = !0;
  }), e;
}
const Pn = [Function, Array], Ym = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: Pn,
  onEnter: Pn,
  onAfterEnter: Pn,
  onEnterCancelled: Pn,
  // leave
  onBeforeLeave: Pn,
  onLeave: Pn,
  onAfterLeave: Pn,
  onLeaveCancelled: Pn,
  // appear
  onBeforeAppear: Pn,
  onAppear: Pn,
  onAfterAppear: Pn,
  onAppearCancelled: Pn
}, qm = (e) => {
  const t = e.subTree;
  return t.component ? qm(t.component) : t;
}, ZS = {
  name: "BaseTransition",
  props: Ym,
  setup(e, { slots: t }) {
    const n = Ha(), a = Km();
    return () => {
      const l = t.default && dc(t.default(), !0);
      if (!l || !l.length)
        return;
      const i = Xm(l), o = Pe(e), { mode: r } = o;
      if (q.NODE_ENV !== "production" && r && r !== "in-out" && r !== "out-in" && r !== "default" && be(`invalid <transition> mode: ${r}`), a.isLeaving)
        return ys(i);
      const s = Ld(i);
      if (!s)
        return ys(i);
      let d = Wi(
        s,
        o,
        a,
        n,
        // #11061, ensure enterHooks is fresh after clone
        (c) => d = c
      );
      s.type !== _t && hl(s, d);
      let u = n.subTree && Ld(n.subTree);
      if (u && u.type !== _t && !Qa(u, s) && qm(n).type !== _t) {
        let c = Wi(
          u,
          o,
          a,
          n
        );
        if (hl(u, c), r === "out-in" && s.type !== _t)
          return a.isLeaving = !0, c.afterLeave = () => {
            a.isLeaving = !1, n.job.flags & 8 || n.update(), delete c.afterLeave, u = void 0;
          }, ys(i);
        r === "in-out" && s.type !== _t ? c.delayLeave = (f, v, m) => {
          const h = Jm(
            a,
            u
          );
          h[String(u.key)] = u, f[va] = () => {
            v(), f[va] = void 0, delete d.delayedLeave, u = void 0;
          }, d.delayedLeave = () => {
            m(), delete d.delayedLeave, u = void 0;
          };
        } : u = void 0;
      } else u && (u = void 0);
      return i;
    };
  }
};
function Xm(e) {
  let t = e[0];
  if (e.length > 1) {
    let n = !1;
    for (const a of e)
      if (a.type !== _t) {
        if (q.NODE_ENV !== "production" && n) {
          be(
            "<transition> can only be used on a single element or component. Use <transition-group> for lists."
          );
          break;
        }
        if (t = a, n = !0, q.NODE_ENV === "production") break;
      }
  }
  return t;
}
const QS = ZS;
function Jm(e, t) {
  const { leavingVNodes: n } = e;
  let a = n.get(t.type);
  return a || (a = /* @__PURE__ */ Object.create(null), n.set(t.type, a)), a;
}
function Wi(e, t, n, a, l) {
  const {
    appear: i,
    mode: o,
    persisted: r = !1,
    onBeforeEnter: s,
    onEnter: d,
    onAfterEnter: u,
    onEnterCancelled: c,
    onBeforeLeave: f,
    onLeave: v,
    onAfterLeave: m,
    onLeaveCancelled: h,
    onBeforeAppear: g,
    onAppear: p,
    onAfterAppear: y,
    onAppearCancelled: _
  } = t, E = String(e.key), k = Jm(n, e), P = (N, V) => {
    N && Rn(
      N,
      a,
      9,
      V
    );
  }, A = (N, V) => {
    const I = V[1];
    P(N, V), Ae(N) ? N.every((w) => w.length <= 1) && I() : N.length <= 1 && I();
  }, D = {
    mode: o,
    persisted: r,
    beforeEnter(N) {
      let V = s;
      if (!n.isMounted)
        if (i)
          V = g || s;
        else
          return;
      N[va] && N[va](
        !0
        /* cancelled */
      );
      const I = k[E];
      I && Qa(e, I) && I.el[va] && I.el[va](), P(V, [N]);
    },
    enter(N) {
      let V = d, I = u, w = c;
      if (!n.isMounted)
        if (i)
          V = p || d, I = y || u, w = _ || c;
        else
          return;
      let T = !1;
      const M = N[$o] = (W) => {
        T || (T = !0, W ? P(w, [N]) : P(I, [N]), D.delayedLeave && D.delayedLeave(), N[$o] = void 0);
      };
      V ? A(V, [N, M]) : M();
    },
    leave(N, V) {
      const I = String(e.key);
      if (N[$o] && N[$o](
        !0
        /* cancelled */
      ), n.isUnmounting)
        return V();
      P(f, [N]);
      let w = !1;
      const T = N[va] = (M) => {
        w || (w = !0, V(), M ? P(h, [N]) : P(m, [N]), N[va] = void 0, k[I] === e && delete k[I]);
      };
      k[I] = e, v ? A(v, [N, T]) : T();
    },
    clone(N) {
      const V = Wi(
        N,
        t,
        n,
        a,
        l
      );
      return l && l(V), V;
    }
  };
  return D;
}
function ys(e) {
  if (go(e))
    return e = Ln(e), e.children = null, e;
}
function Ld(e) {
  if (!go(e))
    return Wm(e.type) && e.children ? Xm(e.children) : e;
  if (e.component)
    return e.component.subTree;
  const { shapeFlag: t, children: n } = e;
  if (n) {
    if (t & 16)
      return n[0];
    if (t & 32 && Te(n.default))
      return n.default();
  }
}
function hl(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, hl(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
function dc(e, t = !1, n) {
  let a = [], l = 0;
  for (let i = 0; i < e.length; i++) {
    let o = e[i];
    const r = n == null ? o.key : String(n) + String(o.key != null ? o.key : i);
    o.type === ye ? (o.patchFlag & 128 && l++, a = a.concat(
      dc(o.children, t, r)
    )) : (t || o.type !== _t) && a.push(r != null ? Ln(o, { key: r }) : o);
  }
  if (l > 1)
    for (let i = 0; i < a.length; i++)
      a[i].patchFlag = -2;
  return a;
}
// @__NO_SIDE_EFFECTS__
function fc(e, t) {
  return Te(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    pt({ name: e.name }, t, { setup: e })
  ) : e;
}
function Yt() {
  const e = Ha();
  return e ? (e.appContext.config.idPrefix || "v") + "-" + e.ids[0] + e.ids[1]++ : (q.NODE_ENV !== "production" && be(
    "useId() is called when there is no active component instance to be associated with."
  ), "");
}
function Zm(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
const Fd = /* @__PURE__ */ new WeakSet(), or = /* @__PURE__ */ new WeakMap();
function Bi(e, t, n, a, l = !1) {
  if (Ae(e)) {
    e.forEach(
      (h, g) => Bi(
        h,
        t && (Ae(t) ? t[g] : t),
        n,
        a,
        l
      )
    );
    return;
  }
  if (ql(a) && !l) {
    a.shapeFlag & 512 && a.type.__asyncResolved && a.component.subTree.component && Bi(e, t, n, a.component.subTree);
    return;
  }
  const i = a.shapeFlag & 4 ? Br(a.component) : a.el, o = l ? null : i, { i: r, r: s } = e;
  if (q.NODE_ENV !== "production" && !r) {
    be(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const d = t && t.r, u = r.refs === it ? r.refs = {} : r.refs, c = r.setupState, f = Pe(c), v = c === it ? tm : (h) => q.NODE_ENV !== "production" && (Ke(f, h) && !mt(f[h]) && be(
    `Template ref "${h}" used on a non-ref value. It will not work in the production build.`
  ), Fd.has(f[h])) ? !1 : Ke(f, h), m = (h) => q.NODE_ENV === "production" || !Fd.has(h);
  if (d != null && d !== s) {
    if (Hd(t), ct(d))
      u[d] = null, v(d) && (c[d] = null);
    else if (mt(d)) {
      m(d) && (d.value = null);
      const h = t;
      h.k && (u[h.k] = null);
    }
  }
  if (Te(s))
    di(s, r, 12, [o, u]);
  else {
    const h = ct(s), g = mt(s);
    if (h || g) {
      const p = () => {
        if (e.f) {
          const y = h ? v(s) ? c[s] : u[s] : m(s) || !e.k ? s.value : u[e.k];
          if (l)
            Ae(y) && ec(y, i);
          else if (Ae(y))
            y.includes(i) || y.push(i);
          else if (h)
            u[s] = [i], v(s) && (c[s] = u[s]);
          else {
            const _ = [i];
            m(s) && (s.value = _), e.k && (u[e.k] = _);
          }
        } else h ? (u[s] = o, v(s) && (c[s] = o)) : g ? (m(s) && (s.value = o), e.k && (u[e.k] = o)) : q.NODE_ENV !== "production" && be("Invalid template ref type:", s, `(${typeof s})`);
      };
      if (o) {
        const y = () => {
          p(), or.delete(e);
        };
        y.id = -1, or.set(e, y), ln(y, n);
      } else
        Hd(e), p();
    } else q.NODE_ENV !== "production" && be("Invalid template ref type:", s, `(${typeof s})`);
  }
}
function Hd(e) {
  const t = or.get(e);
  t && (t.flags |= 8, or.delete(e));
}
vo().requestIdleCallback;
vo().cancelIdleCallback;
const ql = (e) => !!e.type.__asyncLoader, go = (e) => e.type.__isKeepAlive;
function Qm(e, t) {
  eh(e, "a", t);
}
function vc(e, t) {
  eh(e, "da", t);
}
function eh(e, t, n = Ft) {
  const a = e.__wdc || (e.__wdc = () => {
    let l = n;
    for (; l; ) {
      if (l.isDeactivated)
        return;
      l = l.parent;
    }
    return e();
  });
  if (Tr(t, a, n), n) {
    let l = n.parent;
    for (; l && l.parent; )
      go(l.parent.vnode) && ew(a, t, n, l), l = l.parent;
  }
}
function ew(e, t, n, a) {
  const l = Tr(
    t,
    e,
    a,
    !0
    /* prepend */
  );
  Or(() => {
    ec(a[t], l);
  }, n);
}
function Tr(e, t, n = Ft, a = !1) {
  if (n) {
    const l = n[e] || (n[e] = []), i = t.__weh || (t.__weh = (...o) => {
      Bn();
      const r = yo(n), s = Rn(t, n, e, o);
      return r(), Mn(), s;
    });
    return a ? l.unshift(i) : l.push(i), i;
  } else if (q.NODE_ENV !== "production") {
    const l = Ja(sc[e].replace(/ hook$/, ""));
    be(
      `${l} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const ka = (e) => (t, n = Ft) => {
  (!Gi || e === "sp") && Tr(e, (...a) => t(...a), n);
}, fi = ka("bm"), At = ka("m"), th = ka(
  "bu"
), mc = ka("u"), Wt = ka(
  "bum"
), Or = ka("um"), tw = ka(
  "sp"
), nw = ka("rtg"), aw = ka("rtc");
function lw(e, t = Ft) {
  Tr("ec", e, t);
}
const nh = "components";
function xe(e, t) {
  return ah(nh, e, !0, t) || e;
}
const iw = Symbol.for("v-ndc");
function ow(e) {
  return ct(e) && ah(nh, e, !1) || e;
}
function ah(e, t, n = !0, a = !1) {
  const l = Nt || Ft;
  if (l) {
    const i = l.type;
    {
      const r = wc(
        i,
        !1
      );
      if (r && (r === t || r === Ht(t) || r === wn(Ht(t))))
        return i;
    }
    const o = (
      // local registration
      // check instance[type] first which is resolved for options API
      zd(l[e] || i[e], t) || // global registration
      zd(l.appContext[e], t)
    );
    return !o && a ? i : (q.NODE_ENV !== "production" && n && !o && be(`Failed to resolve ${e.slice(0, -1)}: ${t}
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.`), o);
  } else q.NODE_ENV !== "production" && be(
    `resolve${wn(e.slice(0, -1))} can only be used in render() or setup().`
  );
}
function zd(e, t) {
  return e && (e[t] || e[Ht(t)] || e[wn(Ht(t))]);
}
function ba(e, t, n, a) {
  let l;
  const i = n, o = Ae(e);
  if (o || ct(e)) {
    const r = o && il(e);
    let s = !1, d = !1;
    r && (s = !sn(e), d = na(e), e = Ir(e)), l = new Array(e.length);
    for (let u = 0, c = e.length; u < c; u++)
      l[u] = t(
        s ? d ? tr(Ut(e[u])) : Ut(e[u]) : e[u],
        u,
        void 0,
        i
      );
  } else if (typeof e == "number") {
    q.NODE_ENV !== "production" && !Number.isInteger(e) && be(`The v-for range expect an integer value but got ${e}.`), l = new Array(e);
    for (let r = 0; r < e; r++)
      l[r] = t(r + 1, r, void 0, i);
  } else if (et(e))
    if (e[Symbol.iterator])
      l = Array.from(
        e,
        (r, s) => t(r, s, void 0, i)
      );
    else {
      const r = Object.keys(e);
      l = new Array(r.length);
      for (let s = 0, d = r.length; s < d; s++) {
        const u = r[s];
        l[s] = t(e[u], u, s, i);
      }
    }
  else
    l = [];
  return l;
}
function Zl(e, t) {
  for (let n = 0; n < t.length; n++) {
    const a = t[n];
    if (Ae(a))
      for (let l = 0; l < a.length; l++)
        e[a[l].name] = a[l].fn;
    else a && (e[a.name] = a.key ? (...l) => {
      const i = a.fn(...l);
      return i && (i.key = a.key), i;
    } : a.fn);
  }
  return e;
}
function Ys(e, t, n = {}, a, l) {
  if (Nt.ce || Nt.parent && ql(Nt.parent) && Nt.parent.ce) {
    const d = Object.keys(n).length > 0;
    return t !== "default" && (n.name = t), De(), vt(
      ye,
      null,
      [b("slot", n, a)],
      d ? -2 : 64
    );
  }
  let i = e[t];
  q.NODE_ENV !== "production" && i && i.length > 1 && (be(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), i = () => []), i && i._c && (i._d = !1), De();
  const o = i && lh(i(n)), r = n.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  o && o.key, s = vt(
    ye,
    {
      key: (r && !xa(r) ? r : `_${t}`) + // #7256 force differentiate fallback content from actual content
      (!o && a ? "_fb" : "")
    },
    o || [],
    o && e._ === 1 ? 64 : -2
  );
  return i && i._c && (i._d = !0), s;
}
function lh(e) {
  return e.some((t) => Ba(t) ? !(t.type === _t || t.type === ye && !lh(t.children)) : !0) ? e : null;
}
const qs = (e) => e ? Eh(e) ? Br(e) : qs(e.parent) : null, sl = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ pt(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => q.NODE_ENV !== "production" ? Qn(e.props) : e.props,
    $attrs: (e) => q.NODE_ENV !== "production" ? Qn(e.attrs) : e.attrs,
    $slots: (e) => q.NODE_ENV !== "production" ? Qn(e.slots) : e.slots,
    $refs: (e) => q.NODE_ENV !== "production" ? Qn(e.refs) : e.refs,
    $parent: (e) => qs(e.parent),
    $root: (e) => qs(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => rh(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      Ar(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = He.bind(e.proxy)),
    $watch: (e) => Rw.bind(e)
  })
), hc = (e) => e === "_" || e === "$", bs = (e, t) => e !== it && !e.__isScriptSetup && Ke(e, t), ih = {
  get({ _: e }, t) {
    if (t === "__v_skip")
      return !0;
    const { ctx: n, setupState: a, data: l, props: i, accessCache: o, type: r, appContext: s } = e;
    if (q.NODE_ENV !== "production" && t === "__isVue")
      return !0;
    let d;
    if (t[0] !== "$") {
      const v = o[t];
      if (v !== void 0)
        switch (v) {
          case 1:
            return a[t];
          case 2:
            return l[t];
          case 4:
            return n[t];
          case 3:
            return i[t];
        }
      else {
        if (bs(a, t))
          return o[t] = 1, a[t];
        if (l !== it && Ke(l, t))
          return o[t] = 2, l[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (d = e.propsOptions[0]) && Ke(d, t)
        )
          return o[t] = 3, i[t];
        if (n !== it && Ke(n, t))
          return o[t] = 4, n[t];
        Xs && (o[t] = 0);
      }
    }
    const u = sl[t];
    let c, f;
    if (u)
      return t === "$attrs" ? ($t(e.attrs, "get", ""), q.NODE_ENV !== "production" && ur()) : q.NODE_ENV !== "production" && t === "$slots" && $t(e, "get", t), u(e);
    if (
      // css module (injected by vue-loader)
      (c = r.__cssModules) && (c = c[t])
    )
      return c;
    if (n !== it && Ke(n, t))
      return o[t] = 4, n[t];
    if (
      // global properties
      f = s.config.globalProperties, Ke(f, t)
    )
      return f[t];
    q.NODE_ENV !== "production" && Nt && (!ct(t) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    t.indexOf("__v") !== 0) && (l !== it && hc(t[0]) && Ke(l, t) ? be(
      `Property ${JSON.stringify(
        t
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : e === Nt && be(
      `Property ${JSON.stringify(t)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: e }, t, n) {
    const { data: a, setupState: l, ctx: i } = e;
    return bs(l, t) ? (l[t] = n, !0) : q.NODE_ENV !== "production" && l.__isScriptSetup && Ke(l, t) ? (be(`Cannot mutate <script setup> binding "${t}" from Options API.`), !1) : a !== it && Ke(a, t) ? (a[t] = n, !0) : Ke(e.props, t) ? (q.NODE_ENV !== "production" && be(`Attempting to mutate prop "${t}". Props are readonly.`), !1) : t[0] === "$" && t.slice(1) in e ? (q.NODE_ENV !== "production" && be(
      `Attempting to mutate public property "${t}". Properties starting with $ are reserved and readonly.`
    ), !1) : (q.NODE_ENV !== "production" && t in e.appContext.config.globalProperties ? Object.defineProperty(i, t, {
      enumerable: !0,
      configurable: !0,
      value: n
    }) : i[t] = n, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: n, ctx: a, appContext: l, propsOptions: i, type: o }
  }, r) {
    let s, d;
    return !!(n[r] || e !== it && r[0] !== "$" && Ke(e, r) || bs(t, r) || (s = i[0]) && Ke(s, r) || Ke(a, r) || Ke(sl, r) || Ke(l.config.globalProperties, r) || (d = o.__cssModules) && d[r]);
  },
  defineProperty(e, t, n) {
    return n.get != null ? e._.accessCache[t] = 0 : Ke(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n);
  }
};
q.NODE_ENV !== "production" && (ih.ownKeys = (e) => (be(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(e)));
function rw(e) {
  const t = {};
  return Object.defineProperty(t, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => e
  }), Object.keys(sl).forEach((n) => {
    Object.defineProperty(t, n, {
      configurable: !0,
      enumerable: !1,
      get: () => sl[n](e),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: Bt
    });
  }), t;
}
function sw(e) {
  const {
    ctx: t,
    propsOptions: [n]
  } = e;
  n && Object.keys(n).forEach((a) => {
    Object.defineProperty(t, a, {
      enumerable: !0,
      configurable: !0,
      get: () => e.props[a],
      set: Bt
    });
  });
}
function uw(e) {
  const { ctx: t, setupState: n } = e;
  Object.keys(Pe(n)).forEach((a) => {
    if (!n.__isScriptSetup) {
      if (hc(a[0])) {
        be(
          `setup() return property ${JSON.stringify(
            a
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(t, a, {
        enumerable: !0,
        configurable: !0,
        get: () => n[a],
        set: Bt
      });
    }
  });
}
function jd(e) {
  return Ae(e) ? e.reduce(
    (t, n) => (t[n] = null, t),
    {}
  ) : e;
}
function cw() {
  const e = /* @__PURE__ */ Object.create(null);
  return (t, n) => {
    e[n] ? be(`${t} property "${n}" is already defined in ${e[n]}.`) : e[n] = t;
  };
}
let Xs = !0;
function dw(e) {
  const t = rh(e), n = e.proxy, a = e.ctx;
  Xs = !1, t.beforeCreate && Wd(t.beforeCreate, e, "bc");
  const {
    // state
    data: l,
    computed: i,
    methods: o,
    watch: r,
    provide: s,
    inject: d,
    // lifecycle
    created: u,
    beforeMount: c,
    mounted: f,
    beforeUpdate: v,
    updated: m,
    activated: h,
    deactivated: g,
    beforeDestroy: p,
    beforeUnmount: y,
    destroyed: _,
    unmounted: E,
    render: k,
    renderTracked: P,
    renderTriggered: A,
    errorCaptured: D,
    serverPrefetch: N,
    // public API
    expose: V,
    inheritAttrs: I,
    // assets
    components: w,
    directives: T,
    filters: M
  } = t, W = q.NODE_ENV !== "production" ? cw() : null;
  if (q.NODE_ENV !== "production") {
    const [ee] = e.propsOptions;
    if (ee)
      for (const Y in ee)
        W("Props", Y);
  }
  if (d && fw(d, a, W), o)
    for (const ee in o) {
      const Y = o[ee];
      Te(Y) ? (q.NODE_ENV !== "production" ? Object.defineProperty(a, ee, {
        value: Y.bind(n),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : a[ee] = Y.bind(n), q.NODE_ENV !== "production" && W("Methods", ee)) : q.NODE_ENV !== "production" && be(
        `Method "${ee}" has type "${typeof Y}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (l) {
    q.NODE_ENV !== "production" && !Te(l) && be(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const ee = l.call(n, n);
    if (q.NODE_ENV !== "production" && tc(ee) && be(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !et(ee))
      q.NODE_ENV !== "production" && be("data() should return an object.");
    else if (e.data = It(ee), q.NODE_ENV !== "production")
      for (const Y in ee)
        W("Data", Y), hc(Y[0]) || Object.defineProperty(a, Y, {
          configurable: !0,
          enumerable: !0,
          get: () => ee[Y],
          set: Bt
        });
  }
  if (Xs = !0, i)
    for (const ee in i) {
      const Y = i[ee], L = Te(Y) ? Y.bind(n, n) : Te(Y.get) ? Y.get.bind(n, n) : Bt;
      q.NODE_ENV !== "production" && L === Bt && be(`Computed property "${ee}" has no getter.`);
      const H = !Te(Y) && Te(Y.set) ? Y.set.bind(n) : q.NODE_ENV !== "production" ? () => {
        be(
          `Write operation failed: computed property "${ee}" is readonly.`
        );
      } : Bt, j = x({
        get: L,
        set: H
      });
      Object.defineProperty(a, ee, {
        enumerable: !0,
        configurable: !0,
        get: () => j.value,
        set: (U) => j.value = U
      }), q.NODE_ENV !== "production" && W("Computed", ee);
    }
  if (r)
    for (const ee in r)
      oh(r[ee], a, n, ee);
  if (s) {
    const ee = Te(s) ? s.call(n) : s;
    Reflect.ownKeys(ee).forEach((Y) => {
      at(Y, ee[Y]);
    });
  }
  u && Wd(u, e, "c");
  function J(ee, Y) {
    Ae(Y) ? Y.forEach((L) => ee(L.bind(n))) : Y && ee(Y.bind(n));
  }
  if (J(fi, c), J(At, f), J(th, v), J(mc, m), J(Qm, h), J(vc, g), J(lw, D), J(aw, P), J(nw, A), J(Wt, y), J(Or, E), J(tw, N), Ae(V))
    if (V.length) {
      const ee = e.exposed || (e.exposed = {});
      V.forEach((Y) => {
        Object.defineProperty(ee, Y, {
          get: () => n[Y],
          set: (L) => n[Y] = L,
          enumerable: !0
        });
      });
    } else e.exposed || (e.exposed = {});
  k && e.render === Bt && (e.render = k), I != null && (e.inheritAttrs = I), w && (e.components = w), T && (e.directives = T), N && Zm(e);
}
function fw(e, t, n = Bt) {
  Ae(e) && (e = Js(e));
  for (const a in e) {
    const l = e[a];
    let i;
    et(l) ? "default" in l ? i = Me(
      l.from || a,
      l.default,
      !0
    ) : i = Me(l.from || a) : i = Me(l), mt(i) ? Object.defineProperty(t, a, {
      enumerable: !0,
      configurable: !0,
      get: () => i.value,
      set: (o) => i.value = o
    }) : t[a] = i, q.NODE_ENV !== "production" && n("Inject", a);
  }
}
function Wd(e, t, n) {
  Rn(
    Ae(e) ? e.map((a) => a.bind(t.proxy)) : e.bind(t.proxy),
    t,
    n
  );
}
function oh(e, t, n, a) {
  let l = a.includes(".") ? bh(n, a) : () => n[a];
  if (ct(e)) {
    const i = t[e];
    Te(i) ? me(l, i) : q.NODE_ENV !== "production" && be(`Invalid watch handler specified by key "${e}"`, i);
  } else if (Te(e))
    me(l, e.bind(n));
  else if (et(e))
    if (Ae(e))
      e.forEach((i) => oh(i, t, n, a));
    else {
      const i = Te(e.handler) ? e.handler.bind(n) : t[e.handler];
      Te(i) ? me(l, i, e) : q.NODE_ENV !== "production" && be(`Invalid watch handler specified by key "${e.handler}"`, i);
    }
  else q.NODE_ENV !== "production" && be(`Invalid watch option: "${a}"`, e);
}
function rh(e) {
  const t = e.type, { mixins: n, extends: a } = t, {
    mixins: l,
    optionsCache: i,
    config: { optionMergeStrategies: o }
  } = e.appContext, r = i.get(t);
  let s;
  return r ? s = r : !l.length && !n && !a ? s = t : (s = {}, l.length && l.forEach(
    (d) => rr(s, d, o, !0)
  ), rr(s, t, o)), et(t) && i.set(t, s), s;
}
function rr(e, t, n, a = !1) {
  const { mixins: l, extends: i } = t;
  i && rr(e, i, n, !0), l && l.forEach(
    (o) => rr(e, o, n, !0)
  );
  for (const o in t)
    if (a && o === "expose")
      q.NODE_ENV !== "production" && be(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const r = vw[o] || n && n[o];
      e[o] = r ? r(e[o], t[o]) : t[o];
    }
  return e;
}
const vw = {
  data: Ud,
  props: Gd,
  emits: Gd,
  // objects
  methods: Di,
  computed: Di,
  // lifecycle
  beforeCreate: an,
  created: an,
  beforeMount: an,
  mounted: an,
  beforeUpdate: an,
  updated: an,
  beforeDestroy: an,
  beforeUnmount: an,
  destroyed: an,
  unmounted: an,
  activated: an,
  deactivated: an,
  errorCaptured: an,
  serverPrefetch: an,
  // assets
  components: Di,
  directives: Di,
  // watch
  watch: hw,
  // provide / inject
  provide: Ud,
  inject: mw
};
function Ud(e, t) {
  return t ? e ? function() {
    return pt(
      Te(e) ? e.call(this, this) : e,
      Te(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function mw(e, t) {
  return Di(Js(e), Js(t));
}
function Js(e) {
  if (Ae(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++)
      t[e[n]] = e[n];
    return t;
  }
  return e;
}
function an(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Di(e, t) {
  return e ? pt(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function Gd(e, t) {
  return e ? Ae(e) && Ae(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : pt(
    /* @__PURE__ */ Object.create(null),
    jd(e),
    jd(t ?? {})
  ) : t;
}
function hw(e, t) {
  if (!e) return t;
  if (!t) return e;
  const n = pt(/* @__PURE__ */ Object.create(null), e);
  for (const a in t)
    n[a] = an(e[a], t[a]);
  return n;
}
function sh() {
  return {
    app: null,
    config: {
      isNativeTag: tm,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let gw = 0;
function yw(e, t) {
  return function(a, l = null) {
    Te(a) || (a = pt({}, a)), l != null && !et(l) && (q.NODE_ENV !== "production" && be("root props passed to app.mount() must be an object."), l = null);
    const i = sh(), o = /* @__PURE__ */ new WeakSet(), r = [];
    let s = !1;
    const d = i.app = {
      _uid: gw++,
      _component: a,
      _props: l,
      _container: null,
      _context: i,
      _instance: null,
      version: af,
      get config() {
        return i.config;
      },
      set config(u) {
        q.NODE_ENV !== "production" && be(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(u, ...c) {
        return o.has(u) ? q.NODE_ENV !== "production" && be("Plugin has already been applied to target app.") : u && Te(u.install) ? (o.add(u), u.install(d, ...c)) : Te(u) ? (o.add(u), u(d, ...c)) : q.NODE_ENV !== "production" && be(
          'A plugin must either be a function or an object with an "install" function.'
        ), d;
      },
      mixin(u) {
        return i.mixins.includes(u) ? q.NODE_ENV !== "production" && be(
          "Mixin has already been applied to target app" + (u.name ? `: ${u.name}` : "")
        ) : i.mixins.push(u), d;
      },
      component(u, c) {
        return q.NODE_ENV !== "production" && nu(u, i.config), c ? (q.NODE_ENV !== "production" && i.components[u] && be(`Component "${u}" has already been registered in target app.`), i.components[u] = c, d) : i.components[u];
      },
      directive(u, c) {
        return q.NODE_ENV !== "production" && zm(u), c ? (q.NODE_ENV !== "production" && i.directives[u] && be(`Directive "${u}" has already been registered in target app.`), i.directives[u] = c, d) : i.directives[u];
      },
      mount(u, c, f) {
        if (s)
          q.NODE_ENV !== "production" && be(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          q.NODE_ENV !== "production" && u.__vue_app__ && be(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const v = d._ceVNode || b(a, l);
          return v.appContext = i, f === !0 ? f = "svg" : f === !1 && (f = void 0), q.NODE_ENV !== "production" && (i.reload = () => {
            const m = Ln(v);
            m.el = null, e(m, u, f);
          }), e(v, u, f), s = !0, d._container = u, u.__vue_app__ = d, q.NODE_ENV !== "production" && (d._instance = v.component, zS(d, af)), Br(v.component);
        }
      },
      onUnmount(u) {
        q.NODE_ENV !== "production" && typeof u != "function" && be(
          `Expected function as first argument to app.onUnmount(), but got ${typeof u}`
        ), r.push(u);
      },
      unmount() {
        s ? (Rn(
          r,
          d._instance,
          16
        ), e(null, d._container), q.NODE_ENV !== "production" && (d._instance = null, jS(d)), delete d._container.__vue_app__) : q.NODE_ENV !== "production" && be("Cannot unmount an app that is not mounted.");
      },
      provide(u, c) {
        return q.NODE_ENV !== "production" && u in i.provides && (Ke(i.provides, u) ? be(
          `App already provides property with key "${String(u)}". It will be overwritten with the new value.`
        ) : be(
          `App already provides property with key "${String(u)}" inherited from its parent element. It will be overwritten with the new value.`
        )), i.provides[u] = c, d;
      },
      runWithContext(u) {
        const c = Xl;
        Xl = d;
        try {
          return u();
        } finally {
          Xl = c;
        }
      }
    };
    return d;
  };
}
let Xl = null;
function at(e, t) {
  if (!Ft)
    q.NODE_ENV !== "production" && be("provide() can only be used inside setup().");
  else {
    let n = Ft.provides;
    const a = Ft.parent && Ft.parent.provides;
    a === n && (n = Ft.provides = Object.create(a)), n[e] = t;
  }
}
function Me(e, t, n = !1) {
  const a = Ha();
  if (a || Xl) {
    let l = Xl ? Xl._context.provides : a ? a.parent == null || a.ce ? a.vnode.appContext && a.vnode.appContext.provides : a.parent.provides : void 0;
    if (l && e in l)
      return l[e];
    if (arguments.length > 1)
      return n && Te(t) ? t.call(a && a.proxy) : t;
    q.NODE_ENV !== "production" && be(`injection "${String(e)}" not found.`);
  } else q.NODE_ENV !== "production" && be("inject() can only be used inside setup() or functional components.");
}
const uh = {}, ch = () => Object.create(uh), dh = (e) => Object.getPrototypeOf(e) === uh;
function bw(e, t, n, a = !1) {
  const l = {}, i = ch();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), fh(e, t, l, i);
  for (const o in e.propsOptions[0])
    o in l || (l[o] = void 0);
  q.NODE_ENV !== "production" && mh(t || {}, l, e), n ? e.props = a ? l : Vm(l) : e.type.props ? e.props = l : e.props = i, e.attrs = i;
}
function pw(e) {
  for (; e; ) {
    if (e.type.__hmrId) return !0;
    e = e.parent;
  }
}
function Sw(e, t, n, a) {
  const {
    props: l,
    attrs: i,
    vnode: { patchFlag: o }
  } = e, r = Pe(l), [s] = e.propsOptions;
  let d = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(q.NODE_ENV !== "production" && pw(e)) && (a || o > 0) && !(o & 16)
  ) {
    if (o & 8) {
      const u = e.vnode.dynamicProps;
      for (let c = 0; c < u.length; c++) {
        let f = u[c];
        if ($r(e.emitsOptions, f))
          continue;
        const v = t[f];
        if (s)
          if (Ke(i, f))
            v !== i[f] && (i[f] = v, d = !0);
          else {
            const m = Ht(f);
            l[m] = Zs(
              s,
              r,
              m,
              v,
              e,
              !1
            );
          }
        else
          v !== i[f] && (i[f] = v, d = !0);
      }
    }
  } else {
    fh(e, t, l, i) && (d = !0);
    let u;
    for (const c in r)
      (!t || // for camelCase
      !Ke(t, c) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((u = pa(c)) === c || !Ke(t, u))) && (s ? n && // for camelCase
      (n[c] !== void 0 || // for kebab-case
      n[u] !== void 0) && (l[c] = Zs(
        s,
        r,
        c,
        void 0,
        e,
        !0
      )) : delete l[c]);
    if (i !== r)
      for (const c in i)
        (!t || !Ke(t, c)) && (delete i[c], d = !0);
  }
  d && Jn(e.attrs, "set", ""), q.NODE_ENV !== "production" && mh(t || {}, l, e);
}
function fh(e, t, n, a) {
  const [l, i] = e.propsOptions;
  let o = !1, r;
  if (t)
    for (let s in t) {
      if (Ti(s))
        continue;
      const d = t[s];
      let u;
      l && Ke(l, u = Ht(s)) ? !i || !i.includes(u) ? n[u] = d : (r || (r = {}))[u] = d : $r(e.emitsOptions, s) || (!(s in a) || d !== a[s]) && (a[s] = d, o = !0);
    }
  if (i) {
    const s = Pe(n), d = r || it;
    for (let u = 0; u < i.length; u++) {
      const c = i[u];
      n[c] = Zs(
        l,
        s,
        c,
        d[c],
        e,
        !Ke(d, c)
      );
    }
  }
  return o;
}
function Zs(e, t, n, a, l, i) {
  const o = e[n];
  if (o != null) {
    const r = Ke(o, "default");
    if (r && a === void 0) {
      const s = o.default;
      if (o.type !== Function && !o.skipFactory && Te(s)) {
        const { propsDefaults: d } = l;
        if (n in d)
          a = d[n];
        else {
          const u = yo(l);
          a = d[n] = s.call(
            null,
            t
          ), u();
        }
      } else
        a = s;
      l.ce && l.ce._setProp(n, a);
    }
    o[
      0
      /* shouldCast */
    ] && (i && !r ? a = !1 : o[
      1
      /* shouldCastTrue */
    ] && (a === "" || a === pa(n)) && (a = !0));
  }
  return a;
}
const ww = /* @__PURE__ */ new WeakMap();
function vh(e, t, n = !1) {
  const a = n ? ww : t.propsCache, l = a.get(e);
  if (l)
    return l;
  const i = e.props, o = {}, r = [];
  let s = !1;
  if (!Te(e)) {
    const u = (c) => {
      s = !0;
      const [f, v] = vh(c, t, !0);
      pt(o, f), v && r.push(...v);
    };
    !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u);
  }
  if (!i && !s)
    return et(e) && a.set(e, Kl), Kl;
  if (Ae(i))
    for (let u = 0; u < i.length; u++) {
      q.NODE_ENV !== "production" && !ct(i[u]) && be("props must be strings when using array syntax.", i[u]);
      const c = Ht(i[u]);
      Kd(c) && (o[c] = it);
    }
  else if (i) {
    q.NODE_ENV !== "production" && !et(i) && be("invalid props options", i);
    for (const u in i) {
      const c = Ht(u);
      if (Kd(c)) {
        const f = i[u], v = o[c] = Ae(f) || Te(f) ? { type: f } : pt({}, f), m = v.type;
        let h = !1, g = !0;
        if (Ae(m))
          for (let p = 0; p < m.length; ++p) {
            const y = m[p], _ = Te(y) && y.name;
            if (_ === "Boolean") {
              h = !0;
              break;
            } else _ === "String" && (g = !1);
          }
        else
          h = Te(m) && m.name === "Boolean";
        v[
          0
          /* shouldCast */
        ] = h, v[
          1
          /* shouldCastTrue */
        ] = g, (h || Ke(v, "default")) && r.push(c);
      }
    }
  }
  const d = [o, r];
  return et(e) && a.set(e, d), d;
}
function Kd(e) {
  return e[0] !== "$" && !Ti(e) ? !0 : (q.NODE_ENV !== "production" && be(`Invalid prop name: "${e}" is a reserved property.`), !1);
}
function _w(e) {
  return e === null ? "null" : typeof e == "function" ? e.name || "" : typeof e == "object" && e.constructor && e.constructor.name || "";
}
function mh(e, t, n) {
  const a = Pe(t), l = n.propsOptions[0], i = Object.keys(e).map((o) => Ht(o));
  for (const o in l) {
    let r = l[o];
    r != null && xw(
      o,
      a[o],
      r,
      q.NODE_ENV !== "production" ? Qn(a) : a,
      !i.includes(o)
    );
  }
}
function xw(e, t, n, a, l) {
  const { type: i, required: o, validator: r, skipCheck: s } = n;
  if (o && l) {
    be('Missing required prop: "' + e + '"');
    return;
  }
  if (!(t == null && !o)) {
    if (i != null && i !== !0 && !s) {
      let d = !1;
      const u = Ae(i) ? i : [i], c = [];
      for (let f = 0; f < u.length && !d; f++) {
        const { valid: v, expectedType: m } = Cw(t, u[f]);
        c.push(m || ""), d = v;
      }
      if (!d) {
        be(Vw(e, t, c));
        return;
      }
    }
    r && !r(t, a) && be('Invalid prop: custom validator check failed for prop "' + e + '".');
  }
}
const kw = /* @__PURE__ */ _a(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function Cw(e, t) {
  let n;
  const a = _w(t);
  if (a === "null")
    n = e === null;
  else if (kw(a)) {
    const l = typeof e;
    n = l === a.toLowerCase(), !n && l === "object" && (n = e instanceof t);
  } else a === "Object" ? n = et(e) : a === "Array" ? n = Ae(e) : n = e instanceof t;
  return {
    valid: n,
    expectedType: a
  };
}
function Vw(e, t, n) {
  if (n.length === 0)
    return `Prop type [] for prop "${e}" won't match anything. Did you mean to use type Array instead?`;
  let a = `Invalid prop: type check failed for prop "${e}". Expected ${n.map(wn).join(" | ")}`;
  const l = n[0], i = nc(t), o = Yd(t, l), r = Yd(t, i);
  return n.length === 1 && qd(l) && !Ew(l, i) && (a += ` with value ${o}`), a += `, got ${i} `, qd(i) && (a += `with value ${r}.`), a;
}
function Yd(e, t) {
  return t === "String" ? `"${e}"` : t === "Number" ? `${Number(e)}` : `${e}`;
}
function qd(e) {
  return ["string", "number", "boolean"].some((n) => e.toLowerCase() === n);
}
function Ew(...e) {
  return e.some((t) => t.toLowerCase() === "boolean");
}
const gc = (e) => e === "_" || e === "_ctx" || e === "$stable", yc = (e) => Ae(e) ? e.map(An) : [An(e)], Pw = (e, t, n) => {
  if (t._n)
    return t;
  const a = ge((...l) => (q.NODE_ENV !== "production" && Ft && !(n === null && Nt) && !(n && n.root !== Ft.root) && be(
    `Slot "${e}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), yc(t(...l))), n);
  return a._c = !1, a;
}, hh = (e, t, n) => {
  const a = e._ctx;
  for (const l in e) {
    if (gc(l)) continue;
    const i = e[l];
    if (Te(i))
      t[l] = Pw(l, i, a);
    else if (i != null) {
      q.NODE_ENV !== "production" && be(
        `Non-function value encountered for slot "${l}". Prefer function slots for better performance.`
      );
      const o = yc(i);
      t[l] = () => o;
    }
  }
}, gh = (e, t) => {
  q.NODE_ENV !== "production" && !go(e.vnode) && be(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const n = yc(t);
  e.slots.default = () => n;
}, Qs = (e, t, n) => {
  for (const a in t)
    (n || !gc(a)) && (e[a] = t[a]);
}, Iw = (e, t, n) => {
  const a = e.slots = ch();
  if (e.vnode.shapeFlag & 32) {
    const l = t._;
    l ? (Qs(a, t, n), n && Qo(a, "_", l, !0)) : hh(t, a);
  } else t && gh(e, t);
}, Nw = (e, t, n) => {
  const { vnode: a, slots: l } = e;
  let i = !0, o = it;
  if (a.shapeFlag & 32) {
    const r = t._;
    r ? q.NODE_ENV !== "production" && On ? (Qs(l, t, n), Jn(e, "set", "$slots")) : n && r === 1 ? i = !1 : Qs(l, t, n) : (i = !t.$stable, hh(t, l)), o = t;
  } else t && (gh(e, t), o = { default: 1 });
  if (i)
    for (const r in l)
      !gc(r) && o[r] == null && delete l[r];
};
let ki, ma;
function $l(e, t) {
  e.appContext.config.performance && sr() && ma.mark(`vue-${t}-${e.uid}`), q.NODE_ENV !== "production" && KS(e, t, sr() ? ma.now() : Date.now());
}
function Bl(e, t) {
  if (e.appContext.config.performance && sr()) {
    const n = `vue-${t}-${e.uid}`, a = n + ":end", l = `<${Mr(e, e.type)}> ${t}`;
    ma.mark(a), ma.measure(l, n, a), ma.clearMeasures(l), ma.clearMarks(n), ma.clearMarks(a);
  }
  q.NODE_ENV !== "production" && YS(e, t, sr() ? ma.now() : Date.now());
}
function sr() {
  return ki !== void 0 || (typeof window < "u" && window.performance ? (ki = !0, ma = window.performance) : ki = !1), ki;
}
function Dw() {
  const e = [];
  if (q.NODE_ENV !== "production" && e.length) {
    const t = e.length > 1;
    console.warn(
      `Feature flag${t ? "s" : ""} ${e.join(", ")} ${t ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const ln = Gw;
function Aw(e) {
  return Tw(e);
}
function Tw(e, t) {
  Dw();
  const n = vo();
  n.__VUE__ = !0, q.NODE_ENV !== "production" && Rm(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
  const {
    insert: a,
    remove: l,
    patchProp: i,
    createElement: o,
    createText: r,
    createComment: s,
    setText: d,
    setElementText: u,
    parentNode: c,
    nextSibling: f,
    setScopeId: v = Bt,
    insertStaticContent: m
  } = e, h = (C, O, $, K = null, X = null, te = null, ue = void 0, se = null, ce = q.NODE_ENV !== "production" && On ? !1 : !!O.dynamicChildren) => {
    if (C === O)
      return;
    C && !Qa(C, O) && (K = G(C), F(C, X, te, !0), C = null), O.patchFlag === -2 && (ce = !1, O.dynamicChildren = null);
    const { type: ae, ref: Ie, shapeFlag: we } = O;
    switch (ae) {
      case xl:
        g(C, O, $, K);
        break;
      case _t:
        p(C, O, $, K);
        break;
      case Ko:
        C == null ? y(O, $, K, ue) : q.NODE_ENV !== "production" && _(C, O, $, ue);
        break;
      case ye:
        T(
          C,
          O,
          $,
          K,
          X,
          te,
          ue,
          se,
          ce
        );
        break;
      default:
        we & 1 ? P(
          C,
          O,
          $,
          K,
          X,
          te,
          ue,
          se,
          ce
        ) : we & 6 ? M(
          C,
          O,
          $,
          K,
          X,
          te,
          ue,
          se,
          ce
        ) : we & 64 || we & 128 ? ae.process(
          C,
          O,
          $,
          K,
          X,
          te,
          ue,
          se,
          ce,
          Se
        ) : q.NODE_ENV !== "production" && be("Invalid VNode type:", ae, `(${typeof ae})`);
    }
    Ie != null && X ? Bi(Ie, C && C.ref, te, O || C, !O) : Ie == null && C && C.ref != null && Bi(C.ref, null, te, C, !0);
  }, g = (C, O, $, K) => {
    if (C == null)
      a(
        O.el = r(O.children),
        $,
        K
      );
    else {
      const X = O.el = C.el;
      O.children !== C.children && d(X, O.children);
    }
  }, p = (C, O, $, K) => {
    C == null ? a(
      O.el = s(O.children || ""),
      $,
      K
    ) : O.el = C.el;
  }, y = (C, O, $, K) => {
    [C.el, C.anchor] = m(
      C.children,
      O,
      $,
      K,
      C.el,
      C.anchor
    );
  }, _ = (C, O, $, K) => {
    if (O.children !== C.children) {
      const X = f(C.anchor);
      k(C), [O.el, O.anchor] = m(
        O.children,
        $,
        X,
        K
      );
    } else
      O.el = C.el, O.anchor = C.anchor;
  }, E = ({ el: C, anchor: O }, $, K) => {
    let X;
    for (; C && C !== O; )
      X = f(C), a(C, $, K), C = X;
    a(O, $, K);
  }, k = ({ el: C, anchor: O }) => {
    let $;
    for (; C && C !== O; )
      $ = f(C), l(C), C = $;
    l(O);
  }, P = (C, O, $, K, X, te, ue, se, ce) => {
    O.type === "svg" ? ue = "svg" : O.type === "math" && (ue = "mathml"), C == null ? A(
      O,
      $,
      K,
      X,
      te,
      ue,
      se,
      ce
    ) : V(
      C,
      O,
      X,
      te,
      ue,
      se,
      ce
    );
  }, A = (C, O, $, K, X, te, ue, se) => {
    let ce, ae;
    const { props: Ie, shapeFlag: we, transition: Ne, dirs: $e } = C;
    if (ce = C.el = o(
      C.type,
      te,
      Ie && Ie.is,
      Ie
    ), we & 8 ? u(ce, C.children) : we & 16 && N(
      C.children,
      ce,
      null,
      K,
      X,
      ps(C, te),
      ue,
      se
    ), $e && Ga(C, null, K, "created"), D(ce, C, C.scopeId, ue, K), Ie) {
      for (const Je in Ie)
        Je !== "value" && !Ti(Je) && i(ce, Je, null, Ie[Je], te, K);
      "value" in Ie && i(ce, "value", null, Ie.value, te), (ae = Ie.onVnodeBeforeMount) && Yn(ae, K, C);
    }
    q.NODE_ENV !== "production" && (Qo(ce, "__vnode", C, !0), Qo(ce, "__vueParentComponent", K, !0)), $e && Ga(C, null, K, "beforeMount");
    const Fe = Ow(X, Ne);
    Fe && Ne.beforeEnter(ce), a(ce, O, $), ((ae = Ie && Ie.onVnodeMounted) || Fe || $e) && ln(() => {
      ae && Yn(ae, K, C), Fe && Ne.enter(ce), $e && Ga(C, null, K, "mounted");
    }, X);
  }, D = (C, O, $, K, X) => {
    if ($ && v(C, $), K)
      for (let te = 0; te < K.length; te++)
        v(C, K[te]);
    if (X) {
      let te = X.subTree;
      if (q.NODE_ENV !== "production" && te.patchFlag > 0 && te.patchFlag & 2048 && (te = pc(te.children) || te), O === te || wh(te.type) && (te.ssContent === O || te.ssFallback === O)) {
        const ue = X.vnode;
        D(
          C,
          ue,
          ue.scopeId,
          ue.slotScopeIds,
          X.parent
        );
      }
    }
  }, N = (C, O, $, K, X, te, ue, se, ce = 0) => {
    for (let ae = ce; ae < C.length; ae++) {
      const Ie = C[ae] = se ? Ta(C[ae]) : An(C[ae]);
      h(
        null,
        Ie,
        O,
        $,
        K,
        X,
        te,
        ue,
        se
      );
    }
  }, V = (C, O, $, K, X, te, ue) => {
    const se = O.el = C.el;
    q.NODE_ENV !== "production" && (se.__vnode = O);
    let { patchFlag: ce, dynamicChildren: ae, dirs: Ie } = O;
    ce |= C.patchFlag & 16;
    const we = C.props || it, Ne = O.props || it;
    let $e;
    if ($ && Ka($, !1), ($e = Ne.onVnodeBeforeUpdate) && Yn($e, $, O, C), Ie && Ga(O, C, $, "beforeUpdate"), $ && Ka($, !0), q.NODE_ENV !== "production" && On && (ce = 0, ue = !1, ae = null), (we.innerHTML && Ne.innerHTML == null || we.textContent && Ne.textContent == null) && u(se, ""), ae ? (I(
      C.dynamicChildren,
      ae,
      se,
      $,
      K,
      ps(O, X),
      te
    ), q.NODE_ENV !== "production" && Mi(C, O)) : ue || L(
      C,
      O,
      se,
      null,
      $,
      K,
      ps(O, X),
      te,
      !1
    ), ce > 0) {
      if (ce & 16)
        w(se, we, Ne, $, X);
      else if (ce & 2 && we.class !== Ne.class && i(se, "class", null, Ne.class, X), ce & 4 && i(se, "style", we.style, Ne.style, X), ce & 8) {
        const Fe = O.dynamicProps;
        for (let Je = 0; Je < Fe.length; Je++) {
          const Ge = Fe[Je], qt = we[Ge], dn = Ne[Ge];
          (dn !== qt || Ge === "value") && i(se, Ge, qt, dn, X, $);
        }
      }
      ce & 1 && C.children !== O.children && u(se, O.children);
    } else !ue && ae == null && w(se, we, Ne, $, X);
    (($e = Ne.onVnodeUpdated) || Ie) && ln(() => {
      $e && Yn($e, $, O, C), Ie && Ga(O, C, $, "updated");
    }, K);
  }, I = (C, O, $, K, X, te, ue) => {
    for (let se = 0; se < O.length; se++) {
      const ce = C[se], ae = O[se], Ie = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        ce.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (ce.type === ye || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Qa(ce, ae) || // - In the case of a component, it could contain anything.
        ce.shapeFlag & 198) ? c(ce.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          $
        )
      );
      h(
        ce,
        ae,
        Ie,
        null,
        K,
        X,
        te,
        ue,
        !0
      );
    }
  }, w = (C, O, $, K, X) => {
    if (O !== $) {
      if (O !== it)
        for (const te in O)
          !Ti(te) && !(te in $) && i(
            C,
            te,
            O[te],
            null,
            X,
            K
          );
      for (const te in $) {
        if (Ti(te)) continue;
        const ue = $[te], se = O[te];
        ue !== se && te !== "value" && i(C, te, se, ue, X, K);
      }
      "value" in $ && i(C, "value", O.value, $.value, X);
    }
  }, T = (C, O, $, K, X, te, ue, se, ce) => {
    const ae = O.el = C ? C.el : r(""), Ie = O.anchor = C ? C.anchor : r("");
    let { patchFlag: we, dynamicChildren: Ne, slotScopeIds: $e } = O;
    q.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (On || we & 2048) && (we = 0, ce = !1, Ne = null), $e && (se = se ? se.concat($e) : $e), C == null ? (a(ae, $, K), a(Ie, $, K), N(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      O.children || [],
      $,
      Ie,
      X,
      te,
      ue,
      se,
      ce
    )) : we > 0 && we & 64 && Ne && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    C.dynamicChildren ? (I(
      C.dynamicChildren,
      Ne,
      $,
      X,
      te,
      ue,
      se
    ), q.NODE_ENV !== "production" ? Mi(C, O) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (O.key != null || X && O === X.subTree) && Mi(
        C,
        O,
        !0
        /* shallow */
      )
    )) : L(
      C,
      O,
      $,
      Ie,
      X,
      te,
      ue,
      se,
      ce
    );
  }, M = (C, O, $, K, X, te, ue, se, ce) => {
    O.slotScopeIds = se, C == null ? O.shapeFlag & 512 ? X.ctx.activate(
      O,
      $,
      K,
      ue,
      ce
    ) : W(
      O,
      $,
      K,
      X,
      te,
      ue,
      ce
    ) : J(C, O, ce);
  }, W = (C, O, $, K, X, te, ue) => {
    const se = C.component = Jw(
      C,
      K,
      X
    );
    if (q.NODE_ENV !== "production" && se.type.__hmrId && RS(se), q.NODE_ENV !== "production" && (jo(C), $l(se, "mount")), go(C) && (se.ctx.renderer = Se), q.NODE_ENV !== "production" && $l(se, "init"), Qw(se, !1, ue), q.NODE_ENV !== "production" && Bl(se, "init"), q.NODE_ENV !== "production" && On && (C.el = null), se.asyncDep) {
      if (X && X.registerDep(se, ee, ue), !C.el) {
        const ce = se.subTree = b(_t);
        p(null, ce, O, $), C.placeholder = ce.el;
      }
    } else
      ee(
        se,
        C,
        O,
        $,
        X,
        te,
        ue
      );
    q.NODE_ENV !== "production" && (Wo(), Bl(se, "mount"));
  }, J = (C, O, $) => {
    const K = O.component = C.component;
    if (Ww(C, O, $))
      if (K.asyncDep && !K.asyncResolved) {
        q.NODE_ENV !== "production" && jo(O), Y(K, O, $), q.NODE_ENV !== "production" && Wo();
        return;
      } else
        K.next = O, K.update();
    else
      O.el = C.el, K.vnode = O;
  }, ee = (C, O, $, K, X, te, ue) => {
    const se = () => {
      if (C.isMounted) {
        let { next: we, bu: Ne, u: $e, parent: Fe, vnode: Je } = C;
        {
          const Gn = yh(C);
          if (Gn) {
            we && (we.el = Je.el, Y(C, we, ue)), Gn.asyncDep.then(() => {
              C.isUnmounted || se();
            });
            return;
          }
        }
        let Ge = we, qt;
        q.NODE_ENV !== "production" && jo(we || C.vnode), Ka(C, !1), we ? (we.el = Je.el, Y(C, we, ue)) : we = Je, Ne && zl(Ne), (qt = we.props && we.props.onVnodeBeforeUpdate) && Yn(qt, Fe, we, Je), Ka(C, !0), q.NODE_ENV !== "production" && $l(C, "render");
        const dn = Jd(C);
        q.NODE_ENV !== "production" && Bl(C, "render");
        const Un = C.subTree;
        C.subTree = dn, q.NODE_ENV !== "production" && $l(C, "patch"), h(
          Un,
          dn,
          // parent may have changed if it's in a teleport
          c(Un.el),
          // anchor may have changed if it's in a fragment
          G(Un),
          C,
          X,
          te
        ), q.NODE_ENV !== "production" && Bl(C, "patch"), we.el = dn.el, Ge === null && Uw(C, dn.el), $e && ln($e, X), (qt = we.props && we.props.onVnodeUpdated) && ln(
          () => Yn(qt, Fe, we, Je),
          X
        ), q.NODE_ENV !== "production" && Lm(C), q.NODE_ENV !== "production" && Wo();
      } else {
        let we;
        const { el: Ne, props: $e } = O, { bm: Fe, m: Je, parent: Ge, root: qt, type: dn } = C, Un = ql(O);
        Ka(C, !1), Fe && zl(Fe), !Un && (we = $e && $e.onVnodeBeforeMount) && Yn(we, Ge, O), Ka(C, !0);
        {
          qt.ce && // @ts-expect-error _def is private
          qt.ce._def.shadowRoot !== !1 && qt.ce._injectChildStyle(dn), q.NODE_ENV !== "production" && $l(C, "render");
          const Gn = C.subTree = Jd(C);
          q.NODE_ENV !== "production" && Bl(C, "render"), q.NODE_ENV !== "production" && $l(C, "patch"), h(
            null,
            Gn,
            $,
            K,
            C,
            X,
            te
          ), q.NODE_ENV !== "production" && Bl(C, "patch"), O.el = Gn.el;
        }
        if (Je && ln(Je, X), !Un && (we = $e && $e.onVnodeMounted)) {
          const Gn = O;
          ln(
            () => Yn(we, Ge, Gn),
            X
          );
        }
        (O.shapeFlag & 256 || Ge && ql(Ge.vnode) && Ge.vnode.shapeFlag & 256) && C.a && ln(C.a, X), C.isMounted = !0, q.NODE_ENV !== "production" && WS(C), O = $ = K = null;
      }
    };
    C.scope.on();
    const ce = C.effect = new cm(se);
    C.scope.off();
    const ae = C.update = ce.run.bind(ce), Ie = C.job = ce.runIfDirty.bind(ce);
    Ie.i = C, Ie.id = C.uid, ce.scheduler = () => Ar(Ie), Ka(C, !0), q.NODE_ENV !== "production" && (ce.onTrack = C.rtc ? (we) => zl(C.rtc, we) : void 0, ce.onTrigger = C.rtg ? (we) => zl(C.rtg, we) : void 0), ae();
  }, Y = (C, O, $) => {
    O.component = C;
    const K = C.vnode.props;
    C.vnode = O, C.next = null, Sw(C, O.props, K, $), Nw(C, O.children, $), Bn(), Od(C), Mn();
  }, L = (C, O, $, K, X, te, ue, se, ce = !1) => {
    const ae = C && C.children, Ie = C ? C.shapeFlag : 0, we = O.children, { patchFlag: Ne, shapeFlag: $e } = O;
    if (Ne > 0) {
      if (Ne & 128) {
        j(
          ae,
          we,
          $,
          K,
          X,
          te,
          ue,
          se,
          ce
        );
        return;
      } else if (Ne & 256) {
        H(
          ae,
          we,
          $,
          K,
          X,
          te,
          ue,
          se,
          ce
        );
        return;
      }
    }
    $e & 8 ? (Ie & 16 && B(ae, X, te), we !== ae && u($, we)) : Ie & 16 ? $e & 16 ? j(
      ae,
      we,
      $,
      K,
      X,
      te,
      ue,
      se,
      ce
    ) : B(ae, X, te, !0) : (Ie & 8 && u($, ""), $e & 16 && N(
      we,
      $,
      K,
      X,
      te,
      ue,
      se,
      ce
    ));
  }, H = (C, O, $, K, X, te, ue, se, ce) => {
    C = C || Kl, O = O || Kl;
    const ae = C.length, Ie = O.length, we = Math.min(ae, Ie);
    let Ne;
    for (Ne = 0; Ne < we; Ne++) {
      const $e = O[Ne] = ce ? Ta(O[Ne]) : An(O[Ne]);
      h(
        C[Ne],
        $e,
        $,
        null,
        X,
        te,
        ue,
        se,
        ce
      );
    }
    ae > Ie ? B(
      C,
      X,
      te,
      !0,
      !1,
      we
    ) : N(
      O,
      $,
      K,
      X,
      te,
      ue,
      se,
      ce,
      we
    );
  }, j = (C, O, $, K, X, te, ue, se, ce) => {
    let ae = 0;
    const Ie = O.length;
    let we = C.length - 1, Ne = Ie - 1;
    for (; ae <= we && ae <= Ne; ) {
      const $e = C[ae], Fe = O[ae] = ce ? Ta(O[ae]) : An(O[ae]);
      if (Qa($e, Fe))
        h(
          $e,
          Fe,
          $,
          null,
          X,
          te,
          ue,
          se,
          ce
        );
      else
        break;
      ae++;
    }
    for (; ae <= we && ae <= Ne; ) {
      const $e = C[we], Fe = O[Ne] = ce ? Ta(O[Ne]) : An(O[Ne]);
      if (Qa($e, Fe))
        h(
          $e,
          Fe,
          $,
          null,
          X,
          te,
          ue,
          se,
          ce
        );
      else
        break;
      we--, Ne--;
    }
    if (ae > we) {
      if (ae <= Ne) {
        const $e = Ne + 1, Fe = $e < Ie ? O[$e].el : K;
        for (; ae <= Ne; )
          h(
            null,
            O[ae] = ce ? Ta(O[ae]) : An(O[ae]),
            $,
            Fe,
            X,
            te,
            ue,
            se,
            ce
          ), ae++;
      }
    } else if (ae > Ne)
      for (; ae <= we; )
        F(C[ae], X, te, !0), ae++;
    else {
      const $e = ae, Fe = ae, Je = /* @__PURE__ */ new Map();
      for (ae = Fe; ae <= Ne; ae++) {
        const nn = O[ae] = ce ? Ta(O[ae]) : An(O[ae]);
        nn.key != null && (q.NODE_ENV !== "production" && Je.has(nn.key) && be(
          "Duplicate keys found during update:",
          JSON.stringify(nn.key),
          "Make sure keys are unique."
        ), Je.set(nn.key, ae));
      }
      let Ge, qt = 0;
      const dn = Ne - Fe + 1;
      let Un = !1, Gn = 0;
      const _i = new Array(dn);
      for (ae = 0; ae < dn; ae++) _i[ae] = 0;
      for (ae = $e; ae <= we; ae++) {
        const nn = C[ae];
        if (qt >= dn) {
          F(nn, X, te, !0);
          continue;
        }
        let Kn;
        if (nn.key != null)
          Kn = Je.get(nn.key);
        else
          for (Ge = Fe; Ge <= Ne; Ge++)
            if (_i[Ge - Fe] === 0 && Qa(nn, O[Ge])) {
              Kn = Ge;
              break;
            }
        Kn === void 0 ? F(nn, X, te, !0) : (_i[Kn - Fe] = ae + 1, Kn >= Gn ? Gn = Kn : Un = !0, h(
          nn,
          O[Kn],
          $,
          null,
          X,
          te,
          ue,
          se,
          ce
        ), qt++);
      }
      const Ed = Un ? $w(_i) : Kl;
      for (Ge = Ed.length - 1, ae = dn - 1; ae >= 0; ae--) {
        const nn = Fe + ae, Kn = O[nn], Pd = O[nn + 1], Id = nn + 1 < Ie ? (
          // #13559, fallback to el placeholder for unresolved async component
          Pd.el || Pd.placeholder
        ) : K;
        _i[ae] === 0 ? h(
          null,
          Kn,
          $,
          Id,
          X,
          te,
          ue,
          se,
          ce
        ) : Un && (Ge < 0 || ae !== Ed[Ge] ? U(Kn, $, Id, 2) : Ge--);
      }
    }
  }, U = (C, O, $, K, X = null) => {
    const { el: te, type: ue, transition: se, children: ce, shapeFlag: ae } = C;
    if (ae & 6) {
      U(C.component.subTree, O, $, K);
      return;
    }
    if (ae & 128) {
      C.suspense.move(O, $, K);
      return;
    }
    if (ae & 64) {
      ue.move(C, O, $, Se);
      return;
    }
    if (ue === ye) {
      a(te, O, $);
      for (let we = 0; we < ce.length; we++)
        U(ce[we], O, $, K);
      a(C.anchor, O, $);
      return;
    }
    if (ue === Ko) {
      E(C, O, $);
      return;
    }
    if (K !== 2 && ae & 1 && se)
      if (K === 0)
        se.beforeEnter(te), a(te, O, $), ln(() => se.enter(te), X);
      else {
        const { leave: we, delayLeave: Ne, afterLeave: $e } = se, Fe = () => {
          C.ctx.isUnmounted ? l(te) : a(te, O, $);
        }, Je = () => {
          te._isLeaving && te[va](
            !0
            /* cancelled */
          ), we(te, () => {
            Fe(), $e && $e();
          });
        };
        Ne ? Ne(te, Fe, Je) : Je();
      }
    else
      a(te, O, $);
  }, F = (C, O, $, K = !1, X = !1) => {
    const {
      type: te,
      props: ue,
      ref: se,
      children: ce,
      dynamicChildren: ae,
      shapeFlag: Ie,
      patchFlag: we,
      dirs: Ne,
      cacheIndex: $e
    } = C;
    if (we === -2 && (X = !1), se != null && (Bn(), Bi(se, null, $, C, !0), Mn()), $e != null && (O.renderCache[$e] = void 0), Ie & 256) {
      O.ctx.deactivate(C);
      return;
    }
    const Fe = Ie & 1 && Ne, Je = !ql(C);
    let Ge;
    if (Je && (Ge = ue && ue.onVnodeBeforeUnmount) && Yn(Ge, O, C), Ie & 6)
      _e(C.component, $, K);
    else {
      if (Ie & 128) {
        C.suspense.unmount($, K);
        return;
      }
      Fe && Ga(C, null, O, "beforeUnmount"), Ie & 64 ? C.type.remove(
        C,
        O,
        $,
        Se,
        K
      ) : ae && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !ae.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (te !== ye || we > 0 && we & 64) ? B(
        ae,
        O,
        $,
        !1,
        !0
      ) : (te === ye && we & 384 || !X && Ie & 16) && B(ce, O, $), K && oe(C);
    }
    (Je && (Ge = ue && ue.onVnodeUnmounted) || Fe) && ln(() => {
      Ge && Yn(Ge, O, C), Fe && Ga(C, null, O, "unmounted");
    }, $);
  }, oe = (C) => {
    const { type: O, el: $, anchor: K, transition: X } = C;
    if (O === ye) {
      q.NODE_ENV !== "production" && C.patchFlag > 0 && C.patchFlag & 2048 && X && !X.persisted ? C.children.forEach((ue) => {
        ue.type === _t ? l(ue.el) : oe(ue);
      }) : ve($, K);
      return;
    }
    if (O === Ko) {
      k(C);
      return;
    }
    const te = () => {
      l($), X && !X.persisted && X.afterLeave && X.afterLeave();
    };
    if (C.shapeFlag & 1 && X && !X.persisted) {
      const { leave: ue, delayLeave: se } = X, ce = () => ue($, te);
      se ? se(C.el, te, ce) : ce();
    } else
      te();
  }, ve = (C, O) => {
    let $;
    for (; C !== O; )
      $ = f(C), l(C), C = $;
    l(O);
  }, _e = (C, O, $) => {
    q.NODE_ENV !== "production" && C.type.__hmrId && LS(C);
    const { bum: K, scope: X, job: te, subTree: ue, um: se, m: ce, a: ae } = C;
    Xd(ce), Xd(ae), K && zl(K), X.stop(), te && (te.flags |= 8, F(ue, C, O, $)), se && ln(se, O), ln(() => {
      C.isUnmounted = !0;
    }, O), q.NODE_ENV !== "production" && GS(C);
  }, B = (C, O, $, K = !1, X = !1, te = 0) => {
    for (let ue = te; ue < C.length; ue++)
      F(C[ue], O, $, K, X);
  }, G = (C) => {
    if (C.shapeFlag & 6)
      return G(C.component.subTree);
    if (C.shapeFlag & 128)
      return C.suspense.next();
    const O = f(C.anchor || C.el), $ = O && O[jm];
    return $ ? f($) : O;
  };
  let ie = !1;
  const de = (C, O, $) => {
    C == null ? O._vnode && F(O._vnode, null, null, !0) : h(
      O._vnode || null,
      C,
      O,
      null,
      null,
      null,
      $
    ), O._vnode = C, ie || (ie = !0, Od(), $m(), ie = !1);
  }, Se = {
    p: h,
    um: F,
    m: U,
    r: oe,
    mt: W,
    mc: N,
    pc: L,
    pbc: I,
    n: G,
    o: e
  };
  return {
    render: de,
    hydrate: void 0,
    createApp: yw(de)
  };
}
function ps({ type: e, props: t }, n) {
  return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n;
}
function Ka({ effect: e, job: t }, n) {
  n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
}
function Ow(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted;
}
function Mi(e, t, n = !1) {
  const a = e.children, l = t.children;
  if (Ae(a) && Ae(l))
    for (let i = 0; i < a.length; i++) {
      const o = a[i];
      let r = l[i];
      r.shapeFlag & 1 && !r.dynamicChildren && ((r.patchFlag <= 0 || r.patchFlag === 32) && (r = l[i] = Ta(l[i]), r.el = o.el), !n && r.patchFlag !== -2 && Mi(o, r)), r.type === xl && // avoid cached text nodes retaining detached dom nodes
      r.patchFlag !== -1 && (r.el = o.el), r.type === _t && !r.el && (r.el = o.el), q.NODE_ENV !== "production" && r.el && (r.el.__vnode = r);
    }
}
function $w(e) {
  const t = e.slice(), n = [0];
  let a, l, i, o, r;
  const s = e.length;
  for (a = 0; a < s; a++) {
    const d = e[a];
    if (d !== 0) {
      if (l = n[n.length - 1], e[l] < d) {
        t[a] = l, n.push(a);
        continue;
      }
      for (i = 0, o = n.length - 1; i < o; )
        r = i + o >> 1, e[n[r]] < d ? i = r + 1 : o = r;
      d < e[n[i]] && (i > 0 && (t[a] = n[i - 1]), n[i] = a);
    }
  }
  for (i = n.length, o = n[i - 1]; i-- > 0; )
    n[i] = o, o = t[o];
  return n;
}
function yh(e) {
  const t = e.subTree.component;
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : yh(t);
}
function Xd(e) {
  if (e)
    for (let t = 0; t < e.length; t++)
      e[t].flags |= 8;
}
const Bw = Symbol.for("v-scx"), Mw = () => {
  {
    const e = Me(Bw);
    return e || q.NODE_ENV !== "production" && be(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), e;
  }
};
function ut(e, t) {
  return bc(e, null, t);
}
function me(e, t, n) {
  return q.NODE_ENV !== "production" && !Te(t) && be(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), bc(e, t, n);
}
function bc(e, t, n = it) {
  const { immediate: a, deep: l, flush: i, once: o } = n;
  q.NODE_ENV !== "production" && !t && (a !== void 0 && be(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), l !== void 0 && be(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ), o !== void 0 && be(
    'watch() "once" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const r = pt({}, n);
  q.NODE_ENV !== "production" && (r.onWarn = be);
  const s = t && a || !t && i !== "post";
  let d;
  if (Gi) {
    if (i === "sync") {
      const v = Mw();
      d = v.__watcherHandles || (v.__watcherHandles = []);
    } else if (!s) {
      const v = () => {
      };
      return v.stop = Bt, v.resume = Bt, v.pause = Bt, v;
    }
  }
  const u = Ft;
  r.call = (v, m, h) => Rn(v, u, m, h);
  let c = !1;
  i === "post" ? r.scheduler = (v) => {
    ln(v, u && u.suspense);
  } : i !== "sync" && (c = !0, r.scheduler = (v, m) => {
    m ? v() : Ar(v);
  }), r.augmentJob = (v) => {
    t && (v.flags |= 4), c && (v.flags |= 2, u && (v.id = u.uid, v.i = u));
  };
  const f = IS(e, t, r);
  return Gi && (d ? d.push(f) : s && f()), f;
}
function Rw(e, t, n) {
  const a = this.proxy, l = ct(e) ? e.includes(".") ? bh(a, e) : () => a[e] : e.bind(a, a);
  let i;
  Te(t) ? i = t : (i = t.handler, n = t);
  const o = yo(this), r = bc(l, i.bind(a), n);
  return o(), r;
}
function bh(e, t) {
  const n = t.split(".");
  return () => {
    let a = e;
    for (let l = 0; l < n.length && a; l++)
      a = a[n[l]];
    return a;
  };
}
const Lw = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Ht(t)}Modifiers`] || e[`${pa(t)}Modifiers`];
function Fw(e, t, ...n) {
  if (e.isUnmounted) return;
  const a = e.vnode.props || it;
  if (q.NODE_ENV !== "production") {
    const {
      emitsOptions: u,
      propsOptions: [c]
    } = e;
    if (u)
      if (!(t in u))
        (!c || !(Ja(Ht(t)) in c)) && be(
          `Component emitted event "${t}" but it is neither declared in the emits option nor as an "${Ja(Ht(t))}" prop.`
        );
      else {
        const f = u[t];
        Te(f) && (f(...n) || be(
          `Invalid event arguments: event validation failed for event "${t}".`
        ));
      }
  }
  let l = n;
  const i = t.startsWith("update:"), o = i && Lw(a, t.slice(7));
  if (o && (o.trim && (l = n.map((u) => ct(u) ? u.trim() : u)), o.number && (l = n.map(zs))), q.NODE_ENV !== "production" && qS(e, t, l), q.NODE_ENV !== "production") {
    const u = t.toLowerCase();
    u !== t && a[Ja(u)] && be(
      `Event "${u}" is emitted in component ${Mr(
        e,
        e.type
      )} but the handler is registered for "${t}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${pa(
        t
      )}" instead of "${t}".`
    );
  }
  let r, s = a[r = Ja(t)] || // also try camelCase event handler (#2249)
  a[r = Ja(Ht(t))];
  !s && i && (s = a[r = Ja(pa(t))]), s && Rn(
    s,
    e,
    6,
    l
  );
  const d = a[r + "Once"];
  if (d) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[r])
      return;
    e.emitted[r] = !0, Rn(
      d,
      e,
      6,
      l
    );
  }
}
const Hw = /* @__PURE__ */ new WeakMap();
function ph(e, t, n = !1) {
  const a = n ? Hw : t.emitsCache, l = a.get(e);
  if (l !== void 0)
    return l;
  const i = e.emits;
  let o = {}, r = !1;
  if (!Te(e)) {
    const s = (d) => {
      const u = ph(d, t, !0);
      u && (r = !0, pt(o, u));
    };
    !n && t.mixins.length && t.mixins.forEach(s), e.extends && s(e.extends), e.mixins && e.mixins.forEach(s);
  }
  return !i && !r ? (et(e) && a.set(e, null), null) : (Ae(i) ? i.forEach((s) => o[s] = null) : pt(o, i), et(e) && a.set(e, o), o);
}
function $r(e, t) {
  return !e || !fo(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Ke(e, t[0].toLowerCase() + t.slice(1)) || Ke(e, pa(t)) || Ke(e, t));
}
let eu = !1;
function ur() {
  eu = !0;
}
function Jd(e) {
  const {
    type: t,
    vnode: n,
    proxy: a,
    withProxy: l,
    propsOptions: [i],
    slots: o,
    attrs: r,
    emit: s,
    render: d,
    renderCache: u,
    props: c,
    data: f,
    setupState: v,
    ctx: m,
    inheritAttrs: h
  } = e, g = ir(e);
  let p, y;
  q.NODE_ENV !== "production" && (eu = !1);
  try {
    if (n.shapeFlag & 4) {
      const k = l || a, P = q.NODE_ENV !== "production" && v.__isScriptSetup ? new Proxy(k, {
        get(A, D, N) {
          return be(
            `Property '${String(
              D
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          ), Reflect.get(A, D, N);
        }
      }) : k;
      p = An(
        d.call(
          P,
          k,
          u,
          q.NODE_ENV !== "production" ? Qn(c) : c,
          v,
          f,
          m
        )
      ), y = r;
    } else {
      const k = t;
      q.NODE_ENV !== "production" && r === c && ur(), p = An(
        k.length > 1 ? k(
          q.NODE_ENV !== "production" ? Qn(c) : c,
          q.NODE_ENV !== "production" ? {
            get attrs() {
              return ur(), Qn(r);
            },
            slots: o,
            emit: s
          } : { attrs: r, slots: o, emit: s }
        ) : k(
          q.NODE_ENV !== "production" ? Qn(c) : c,
          null
        )
      ), y = t.props ? r : zw(r);
    }
  } catch (k) {
    Ri.length = 0, mo(k, e, 1), p = b(_t);
  }
  let _ = p, E;
  if (q.NODE_ENV !== "production" && p.patchFlag > 0 && p.patchFlag & 2048 && ([_, E] = Sh(p)), y && h !== !1) {
    const k = Object.keys(y), { shapeFlag: P } = _;
    if (k.length) {
      if (P & 7)
        i && k.some(Zo) && (y = jw(
          y,
          i
        )), _ = Ln(_, y, !1, !0);
      else if (q.NODE_ENV !== "production" && !eu && _.type !== _t) {
        const A = Object.keys(r), D = [], N = [];
        for (let V = 0, I = A.length; V < I; V++) {
          const w = A[V];
          fo(w) ? Zo(w) || D.push(w[2].toLowerCase() + w.slice(3)) : N.push(w);
        }
        N.length && be(
          `Extraneous non-props attributes (${N.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text or teleport root nodes.`
        ), D.length && be(
          `Extraneous non-emits event listeners (${D.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return n.dirs && (q.NODE_ENV !== "production" && !Zd(_) && be(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), _ = Ln(_, null, !1, !0), _.dirs = _.dirs ? _.dirs.concat(n.dirs) : n.dirs), n.transition && (q.NODE_ENV !== "production" && !Zd(_) && be(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), hl(_, n.transition)), q.NODE_ENV !== "production" && E ? E(_) : p = _, ir(g), p;
}
const Sh = (e) => {
  const t = e.children, n = e.dynamicChildren, a = pc(t, !1);
  if (a) {
    if (q.NODE_ENV !== "production" && a.patchFlag > 0 && a.patchFlag & 2048)
      return Sh(a);
  } else return [e, void 0];
  const l = t.indexOf(a), i = n ? n.indexOf(a) : -1, o = (r) => {
    t[l] = r, n && (i > -1 ? n[i] = r : r.patchFlag > 0 && (e.dynamicChildren = [...n, r]));
  };
  return [An(a), o];
};
function pc(e, t = !0) {
  let n;
  for (let a = 0; a < e.length; a++) {
    const l = e[a];
    if (Ba(l)) {
      if (l.type !== _t || l.children === "v-if") {
        if (n)
          return;
        if (n = l, q.NODE_ENV !== "production" && t && n.patchFlag > 0 && n.patchFlag & 2048)
          return pc(n.children);
      }
    } else
      return;
  }
  return n;
}
const zw = (e) => {
  let t;
  for (const n in e)
    (n === "class" || n === "style" || fo(n)) && ((t || (t = {}))[n] = e[n]);
  return t;
}, jw = (e, t) => {
  const n = {};
  for (const a in e)
    (!Zo(a) || !(a.slice(9) in t)) && (n[a] = e[a]);
  return n;
}, Zd = (e) => e.shapeFlag & 7 || e.type === _t;
function Ww(e, t, n) {
  const { props: a, children: l, component: i } = e, { props: o, children: r, patchFlag: s } = t, d = i.emitsOptions;
  if (q.NODE_ENV !== "production" && (l || r) && On || t.dirs || t.transition)
    return !0;
  if (n && s >= 0) {
    if (s & 1024)
      return !0;
    if (s & 16)
      return a ? Qd(a, o, d) : !!o;
    if (s & 8) {
      const u = t.dynamicProps;
      for (let c = 0; c < u.length; c++) {
        const f = u[c];
        if (o[f] !== a[f] && !$r(d, f))
          return !0;
      }
    }
  } else
    return (l || r) && (!r || !r.$stable) ? !0 : a === o ? !1 : a ? o ? Qd(a, o, d) : !0 : !!o;
  return !1;
}
function Qd(e, t, n) {
  const a = Object.keys(t);
  if (a.length !== Object.keys(e).length)
    return !0;
  for (let l = 0; l < a.length; l++) {
    const i = a[l];
    if (t[i] !== e[i] && !$r(n, i))
      return !0;
  }
  return !1;
}
function Uw({ vnode: e, parent: t }, n) {
  for (; t; ) {
    const a = t.subTree;
    if (a.suspense && a.suspense.activeBranch === e && (a.el = e.el), a === e)
      (e = t.vnode).el = n, t = t.parent;
    else
      break;
  }
}
const wh = (e) => e.__isSuspense;
function Gw(e, t) {
  t && t.pendingBranch ? Ae(e) ? t.effects.push(...e) : t.effects.push(e) : Om(e);
}
const ye = Symbol.for("v-fgt"), xl = Symbol.for("v-txt"), _t = Symbol.for("v-cmt"), Ko = Symbol.for("v-stc"), Ri = [];
let yn = null;
function De(e = !1) {
  Ri.push(yn = e ? null : []);
}
function Kw() {
  Ri.pop(), yn = Ri[Ri.length - 1] || null;
}
let Ui = 1;
function cr(e, t = !1) {
  Ui += e, e < 0 && yn && t && (yn.hasOnce = !0);
}
function _h(e) {
  return e.dynamicChildren = Ui > 0 ? yn || Kl : null, Kw(), Ui > 0 && yn && yn.push(e), e;
}
function Qe(e, t, n, a, l, i) {
  return _h(
    S(
      e,
      t,
      n,
      a,
      l,
      i,
      !0
    )
  );
}
function vt(e, t, n, a, l) {
  return _h(
    b(
      e,
      t,
      n,
      a,
      l,
      !0
    )
  );
}
function Ba(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function Qa(e, t) {
  if (q.NODE_ENV !== "production" && t.shapeFlag & 6 && e.component) {
    const n = Uo.get(t.type);
    if (n && n.has(e.component))
      return e.shapeFlag &= -257, t.shapeFlag &= -513, !1;
  }
  return e.type === t.type && e.key === t.key;
}
const Yw = (...e) => kh(
  ...e
), xh = ({ key: e }) => e ?? null, Yo = ({
  ref: e,
  ref_key: t,
  ref_for: n
}) => (typeof e == "number" && (e = "" + e), e != null ? ct(e) || mt(e) || Te(e) ? { i: Nt, r: e, k: t, f: !!n } : e : null);
function S(e, t = null, n = null, a = 0, l = null, i = e === ye ? 0 : 1, o = !1, r = !1) {
  const s = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && xh(t),
    ref: t && Yo(t),
    scopeId: Hm,
    slotScopeIds: null,
    children: n,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: i,
    patchFlag: a,
    dynamicProps: l,
    dynamicChildren: null,
    appContext: null,
    ctx: Nt
  };
  return r ? (Sc(s, n), i & 128 && e.normalize(s)) : n && (s.shapeFlag |= ct(n) ? 8 : 16), q.NODE_ENV !== "production" && s.key !== s.key && be("VNode created with invalid key (NaN). VNode type:", s.type), Ui > 0 && // avoid a block node from tracking itself
  !o && // has current parent block
  yn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (s.patchFlag > 0 || i & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  s.patchFlag !== 32 && yn.push(s), s;
}
const b = q.NODE_ENV !== "production" ? Yw : kh;
function kh(e, t = null, n = null, a = 0, l = null, i = !1) {
  if ((!e || e === iw) && (q.NODE_ENV !== "production" && !e && be(`Invalid vnode type when creating vnode: ${e}.`), e = _t), Ba(e)) {
    const r = Ln(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return n && Sc(r, n), Ui > 0 && !i && yn && (r.shapeFlag & 6 ? yn[yn.indexOf(e)] = r : yn.push(r)), r.patchFlag = -2, r;
  }
  if (Ih(e) && (e = e.__vccOpts), t) {
    t = Ch(t);
    let { class: r, style: s } = t;
    r && !ct(r) && (t.class = le(r)), et(s) && (zi(s) && !Ae(s) && (s = pt({}, s)), t.style = he(s));
  }
  const o = ct(e) ? 1 : wh(e) ? 128 : Wm(e) ? 64 : et(e) ? 4 : Te(e) ? 2 : 0;
  return q.NODE_ENV !== "production" && o & 4 && zi(e) && (e = Pe(e), be(
    "Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    e
  )), S(
    e,
    t,
    n,
    a,
    l,
    o,
    i,
    !0
  );
}
function Ch(e) {
  return e ? zi(e) || dh(e) ? pt({}, e) : e : null;
}
function Ln(e, t, n = !1, a = !1) {
  const { props: l, ref: i, patchFlag: o, children: r, transition: s } = e, d = t ? Q(l || {}, t) : l, u = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: d,
    key: d && xh(d),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      n && i ? Ae(i) ? i.concat(Yo(t)) : [i, Yo(t)] : Yo(t)
    ) : i,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: q.NODE_ENV !== "production" && o === -1 && Ae(r) ? r.map(Vh) : r,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== ye ? o === -1 ? 16 : o | 16 : o,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: s,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Ln(e.ssContent),
    ssFallback: e.ssFallback && Ln(e.ssFallback),
    placeholder: e.placeholder,
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return s && a && hl(
    u,
    s.clone(u)
  ), u;
}
function Vh(e) {
  const t = Ln(e);
  return Ae(e.children) && (t.children = e.children.map(Vh)), t;
}
function ze(e = " ", t = 0) {
  return b(xl, null, e, t);
}
function Vt(e = "", t = !1) {
  return t ? (De(), vt(_t, null, e)) : b(_t, null, e);
}
function An(e) {
  return e == null || typeof e == "boolean" ? b(_t) : Ae(e) ? b(
    ye,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : Ba(e) ? Ta(e) : b(xl, null, String(e));
}
function Ta(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : Ln(e);
}
function Sc(e, t) {
  let n = 0;
  const { shapeFlag: a } = e;
  if (t == null)
    t = null;
  else if (Ae(t))
    n = 16;
  else if (typeof t == "object")
    if (a & 65) {
      const l = t.default;
      l && (l._c && (l._d = !1), Sc(e, l()), l._c && (l._d = !0));
      return;
    } else {
      n = 32;
      const l = t._;
      !l && !dh(t) ? t._ctx = Nt : l === 3 && Nt && (Nt.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else Te(t) ? (t = { default: t, _ctx: Nt }, n = 32) : (t = String(t), a & 64 ? (n = 16, t = [ze(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n;
}
function Q(...e) {
  const t = {};
  for (let n = 0; n < e.length; n++) {
    const a = e[n];
    for (const l in a)
      if (l === "class")
        t.class !== a.class && (t.class = le([t.class, a.class]));
      else if (l === "style")
        t.style = he([t.style, a.style]);
      else if (fo(l)) {
        const i = t[l], o = a[l];
        o && i !== o && !(Ae(i) && i.includes(o)) && (t[l] = i ? [].concat(i, o) : o);
      } else l !== "" && (t[l] = a[l]);
  }
  return t;
}
function Yn(e, t, n, a = null) {
  Rn(e, t, 7, [
    n,
    a
  ]);
}
const qw = sh();
let Xw = 0;
function Jw(e, t, n) {
  const a = e.type, l = (t ? t.appContext : e.appContext) || qw, i = {
    uid: Xw++,
    vnode: e,
    type: a,
    parent: t,
    appContext: l,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new sm(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(l.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: vh(a, l),
    emitsOptions: ph(a, l),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: it,
    // inheritAttrs
    inheritAttrs: a.inheritAttrs,
    // state
    ctx: it,
    data: it,
    props: it,
    attrs: it,
    slots: it,
    refs: it,
    setupState: it,
    setupContext: null,
    // suspense related
    suspense: n,
    suspenseId: n ? n.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return q.NODE_ENV !== "production" ? i.ctx = rw(i) : i.ctx = { _: i }, i.root = t ? t.root : i, i.emit = Fw.bind(null, i), e.ce && e.ce(i), i;
}
let Ft = null;
const Ha = () => Ft || Nt;
let dr, tu;
{
  const e = vo(), t = (n, a) => {
    let l;
    return (l = e[n]) || (l = e[n] = []), l.push(a), (i) => {
      l.length > 1 ? l.forEach((o) => o(i)) : l[0](i);
    };
  };
  dr = t(
    "__VUE_INSTANCE_SETTERS__",
    (n) => Ft = n
  ), tu = t(
    "__VUE_SSR_SETTERS__",
    (n) => Gi = n
  );
}
const yo = (e) => {
  const t = Ft;
  return dr(e), e.scope.on(), () => {
    e.scope.off(), dr(t);
  };
}, ef = () => {
  Ft && Ft.scope.off(), dr(null);
}, Zw = /* @__PURE__ */ _a("slot,component");
function nu(e, { isNativeTag: t }) {
  (Zw(e) || t(e)) && be(
    "Do not use built-in or reserved HTML elements as component id: " + e
  );
}
function Eh(e) {
  return e.vnode.shapeFlag & 4;
}
let Gi = !1;
function Qw(e, t = !1, n = !1) {
  t && tu(t);
  const { props: a, children: l } = e.vnode, i = Eh(e);
  bw(e, a, i, t), Iw(e, l, n || t);
  const o = i ? e0(e, t) : void 0;
  return t && tu(!1), o;
}
function e0(e, t) {
  var n;
  const a = e.type;
  if (q.NODE_ENV !== "production") {
    if (a.name && nu(a.name, e.appContext.config), a.components) {
      const i = Object.keys(a.components);
      for (let o = 0; o < i.length; o++)
        nu(i[o], e.appContext.config);
    }
    if (a.directives) {
      const i = Object.keys(a.directives);
      for (let o = 0; o < i.length; o++)
        zm(i[o]);
    }
    a.compilerOptions && t0() && be(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, ih), q.NODE_ENV !== "production" && sw(e);
  const { setup: l } = a;
  if (l) {
    Bn();
    const i = e.setupContext = l.length > 1 ? a0(e) : null, o = yo(e), r = di(
      l,
      e,
      0,
      [
        q.NODE_ENV !== "production" ? Qn(e.props) : e.props,
        i
      ]
    ), s = tc(r);
    if (Mn(), o(), (s || e.sp) && !ql(e) && Zm(e), s) {
      if (r.then(ef, ef), t)
        return r.then((d) => {
          tf(e, d, t);
        }).catch((d) => {
          mo(d, e, 0);
        });
      if (e.asyncDep = r, q.NODE_ENV !== "production" && !e.suspense) {
        const d = (n = a.name) != null ? n : "Anonymous";
        be(
          `Component <${d}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      tf(e, r, t);
  } else
    Ph(e, t);
}
function tf(e, t, n) {
  Te(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : et(t) ? (q.NODE_ENV !== "production" && Ba(t) && be(
    "setup() should not return VNodes directly - return a render function instead."
  ), q.NODE_ENV !== "production" && (e.devtoolsRawSetupState = t), e.setupState = Im(t), q.NODE_ENV !== "production" && uw(e)) : q.NODE_ENV !== "production" && t !== void 0 && be(
    `setup() should return an object. Received: ${t === null ? "null" : typeof t}`
  ), Ph(e, n);
}
const t0 = () => !0;
function Ph(e, t, n) {
  const a = e.type;
  e.render || (e.render = a.render || Bt);
  {
    const l = yo(e);
    Bn();
    try {
      dw(e);
    } finally {
      Mn(), l();
    }
  }
  q.NODE_ENV !== "production" && !a.render && e.render === Bt && !t && (a.template ? be(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
  ) : be("Component is missing template or render function: ", a));
}
const nf = q.NODE_ENV !== "production" ? {
  get(e, t) {
    return ur(), $t(e, "get", ""), e[t];
  },
  set() {
    return be("setupContext.attrs is readonly."), !1;
  },
  deleteProperty() {
    return be("setupContext.attrs is readonly."), !1;
  }
} : {
  get(e, t) {
    return $t(e, "get", ""), e[t];
  }
};
function n0(e) {
  return new Proxy(e.slots, {
    get(t, n) {
      return $t(e, "get", "$slots"), t[n];
    }
  });
}
function a0(e) {
  const t = (n) => {
    if (q.NODE_ENV !== "production" && (e.exposed && be("expose() should be called only once per setup()."), n != null)) {
      let a = typeof n;
      a === "object" && (Ae(n) ? a = "array" : mt(n) && (a = "ref")), a !== "object" && be(
        `expose() should be passed a plain object, received ${a}.`
      );
    }
    e.exposed = n || {};
  };
  if (q.NODE_ENV !== "production") {
    let n, a;
    return Object.freeze({
      get attrs() {
        return n || (n = new Proxy(e.attrs, nf));
      },
      get slots() {
        return a || (a = n0(e));
      },
      get emit() {
        return (l, ...i) => e.emit(l, ...i);
      },
      expose: t
    });
  } else
    return {
      attrs: new Proxy(e.attrs, nf),
      slots: e.slots,
      emit: e.emit,
      expose: t
    };
}
function Br(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Im(Em(e.exposed)), {
    get(t, n) {
      if (n in t)
        return t[n];
      if (n in sl)
        return sl[n](e);
    },
    has(t, n) {
      return n in t || n in sl;
    }
  })) : e.proxy;
}
const l0 = /(?:^|[-_])\w/g, i0 = (e) => e.replace(l0, (t) => t.toUpperCase()).replace(/[-_]/g, "");
function wc(e, t = !0) {
  return Te(e) ? e.displayName || e.name : e.name || t && e.__name;
}
function Mr(e, t, n = !1) {
  let a = wc(t);
  if (!a && t.__file) {
    const l = t.__file.match(/([^/\\]+)\.\w+$/);
    l && (a = l[1]);
  }
  if (!a && e && e.parent) {
    const l = (i) => {
      for (const o in i)
        if (i[o] === t)
          return o;
    };
    a = l(
      e.components || e.parent.type.components
    ) || l(e.appContext.components);
  }
  return a ? i0(a) : n ? "App" : "Anonymous";
}
function Ih(e) {
  return Te(e) && "__vccOpts" in e;
}
const x = (e, t) => {
  const n = ES(e, t, Gi);
  if (q.NODE_ENV !== "production") {
    const a = Ha();
    a && a.appContext.config.warnRecursiveComputed && (n._warnRecursive = !0);
  }
  return n;
};
function jn(e, t, n) {
  try {
    cr(-1);
    const a = arguments.length;
    return a === 2 ? et(t) && !Ae(t) ? Ba(t) ? b(e, null, [t]) : b(e, t) : b(e, null, t) : (a > 3 ? n = Array.prototype.slice.call(arguments, 2) : a === 3 && Ba(n) && (n = [n]), b(e, t, n));
  } finally {
    cr(1);
  }
}
function o0() {
  if (q.NODE_ENV === "production" || typeof window > "u")
    return;
  const e = { style: "color:#3ba776" }, t = { style: "color:#1677ff" }, n = { style: "color:#f5222d" }, a = { style: "color:#eb2f96" }, l = {
    __vue_custom_formatter: !0,
    header(c) {
      if (!et(c))
        return null;
      if (c.__isVue)
        return ["div", e, "VueInstance"];
      if (mt(c)) {
        Bn();
        const f = c.value;
        return Mn(), [
          "div",
          {},
          ["span", e, u(c)],
          "<",
          r(f),
          ">"
        ];
      } else {
        if (il(c))
          return [
            "div",
            {},
            ["span", e, sn(c) ? "ShallowReactive" : "Reactive"],
            "<",
            r(c),
            `>${na(c) ? " (readonly)" : ""}`
          ];
        if (na(c))
          return [
            "div",
            {},
            ["span", e, sn(c) ? "ShallowReadonly" : "Readonly"],
            "<",
            r(c),
            ">"
          ];
      }
      return null;
    },
    hasBody(c) {
      return c && c.__isVue;
    },
    body(c) {
      if (c && c.__isVue)
        return [
          "div",
          {},
          ...i(c.$)
        ];
    }
  };
  function i(c) {
    const f = [];
    c.type.props && c.props && f.push(o("props", Pe(c.props))), c.setupState !== it && f.push(o("setup", c.setupState)), c.data !== it && f.push(o("data", Pe(c.data)));
    const v = s(c, "computed");
    v && f.push(o("computed", v));
    const m = s(c, "inject");
    return m && f.push(o("injected", m)), f.push([
      "div",
      {},
      [
        "span",
        {
          style: a.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: c }]
    ]), f;
  }
  function o(c, f) {
    return f = pt({}, f), Object.keys(f).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        c
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(f).map((v) => [
          "div",
          {},
          ["span", a, v + ": "],
          r(f[v], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function r(c, f = !0) {
    return typeof c == "number" ? ["span", t, c] : typeof c == "string" ? ["span", n, JSON.stringify(c)] : typeof c == "boolean" ? ["span", a, c] : et(c) ? ["object", { object: f ? Pe(c) : c }] : ["span", n, String(c)];
  }
  function s(c, f) {
    const v = c.type;
    if (Te(v))
      return;
    const m = {};
    for (const h in c.ctx)
      d(v, h, f) && (m[h] = c.ctx[h]);
    return m;
  }
  function d(c, f, v) {
    const m = c[v];
    if (Ae(m) && m.includes(f) || et(m) && f in m || c.extends && d(c.extends, f, v) || c.mixins && c.mixins.some((h) => d(h, f, v)))
      return !0;
  }
  function u(c) {
    return sn(c) ? "ShallowRef" : c.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(l) : window.devtoolsFormatters = [l];
}
const af = "3.5.22", fn = q.NODE_ENV !== "production" ? be : Bt;
var Fn = {};
let au;
const lf = typeof window < "u" && window.trustedTypes;
if (lf)
  try {
    au = /* @__PURE__ */ lf.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch (e) {
    Fn.NODE_ENV !== "production" && fn(`Error creating trusted types policy: ${e}`);
  }
const Nh = au ? (e) => au.createHTML(e) : (e) => e, r0 = "http://www.w3.org/2000/svg", s0 = "http://www.w3.org/1998/Math/MathML", fa = typeof document < "u" ? document : null, of = fa && /* @__PURE__ */ fa.createElement("template"), u0 = {
  insert: (e, t, n) => {
    t.insertBefore(e, n || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, n, a) => {
    const l = t === "svg" ? fa.createElementNS(r0, e) : t === "mathml" ? fa.createElementNS(s0, e) : n ? fa.createElement(e, { is: n }) : fa.createElement(e);
    return e === "select" && a && a.multiple != null && l.setAttribute("multiple", a.multiple), l;
  },
  createText: (e) => fa.createTextNode(e),
  createComment: (e) => fa.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => fa.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, n, a, l, i) {
    const o = n ? n.previousSibling : t.lastChild;
    if (l && (l === i || l.nextSibling))
      for (; t.insertBefore(l.cloneNode(!0), n), !(l === i || !(l = l.nextSibling)); )
        ;
    else {
      of.innerHTML = Nh(
        a === "svg" ? `<svg>${e}</svg>` : a === "mathml" ? `<math>${e}</math>` : e
      );
      const r = of.content;
      if (a === "svg" || a === "mathml") {
        const s = r.firstChild;
        for (; s.firstChild; )
          r.appendChild(s.firstChild);
        r.removeChild(s);
      }
      t.insertBefore(r, n);
    }
    return [
      // first
      o ? o.nextSibling : t.firstChild,
      // last
      n ? n.previousSibling : t.lastChild
    ];
  }
}, Ia = "transition", Ci = "animation", Ql = Symbol("_vtc"), Dh = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, Ah = /* @__PURE__ */ pt(
  {},
  Ym,
  Dh
), c0 = (e) => (e.displayName = "Transition", e.props = Ah, e), Ma = /* @__PURE__ */ c0(
  (e, { slots: t }) => jn(QS, Th(e), t)
), Ya = (e, t = []) => {
  Ae(e) ? e.forEach((n) => n(...t)) : e && e(...t);
}, rf = (e) => e ? Ae(e) ? e.some((t) => t.length > 1) : e.length > 1 : !1;
function Th(e) {
  const t = {};
  for (const w in e)
    w in Dh || (t[w] = e[w]);
  if (e.css === !1)
    return t;
  const {
    name: n = "v",
    type: a,
    duration: l,
    enterFromClass: i = `${n}-enter-from`,
    enterActiveClass: o = `${n}-enter-active`,
    enterToClass: r = `${n}-enter-to`,
    appearFromClass: s = i,
    appearActiveClass: d = o,
    appearToClass: u = r,
    leaveFromClass: c = `${n}-leave-from`,
    leaveActiveClass: f = `${n}-leave-active`,
    leaveToClass: v = `${n}-leave-to`
  } = e, m = d0(l), h = m && m[0], g = m && m[1], {
    onBeforeEnter: p,
    onEnter: y,
    onEnterCancelled: _,
    onLeave: E,
    onLeaveCancelled: k,
    onBeforeAppear: P = p,
    onAppear: A = y,
    onAppearCancelled: D = _
  } = t, N = (w, T, M, W) => {
    w._enterCancelled = W, Da(w, T ? u : r), Da(w, T ? d : o), M && M();
  }, V = (w, T) => {
    w._isLeaving = !1, Da(w, c), Da(w, v), Da(w, f), T && T();
  }, I = (w) => (T, M) => {
    const W = w ? A : y, J = () => N(T, w, M);
    Ya(W, [T, J]), sf(() => {
      Da(T, w ? s : i), qn(T, w ? u : r), rf(W) || uf(T, a, h, J);
    });
  };
  return pt(t, {
    onBeforeEnter(w) {
      Ya(p, [w]), qn(w, i), qn(w, o);
    },
    onBeforeAppear(w) {
      Ya(P, [w]), qn(w, s), qn(w, d);
    },
    onEnter: I(!1),
    onAppear: I(!0),
    onLeave(w, T) {
      w._isLeaving = !0;
      const M = () => V(w, T);
      qn(w, c), w._enterCancelled ? (qn(w, f), lu(w)) : (lu(w), qn(w, f)), sf(() => {
        w._isLeaving && (Da(w, c), qn(w, v), rf(E) || uf(w, a, g, M));
      }), Ya(E, [w, M]);
    },
    onEnterCancelled(w) {
      N(w, !1, void 0, !0), Ya(_, [w]);
    },
    onAppearCancelled(w) {
      N(w, !0, void 0, !0), Ya(D, [w]);
    },
    onLeaveCancelled(w) {
      V(w), Ya(k, [w]);
    }
  });
}
function d0(e) {
  if (e == null)
    return null;
  if (et(e))
    return [Ss(e.enter), Ss(e.leave)];
  {
    const t = Ss(e);
    return [t, t];
  }
}
function Ss(e) {
  const t = jp(e);
  return Fn.NODE_ENV !== "production" && OS(t, "<transition> explicit duration"), t;
}
function qn(e, t) {
  t.split(/\s+/).forEach((n) => n && e.classList.add(n)), (e[Ql] || (e[Ql] = /* @__PURE__ */ new Set())).add(t);
}
function Da(e, t) {
  t.split(/\s+/).forEach((a) => a && e.classList.remove(a));
  const n = e[Ql];
  n && (n.delete(t), n.size || (e[Ql] = void 0));
}
function sf(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
let f0 = 0;
function uf(e, t, n, a) {
  const l = e._endId = ++f0, i = () => {
    l === e._endId && a();
  };
  if (n != null)
    return setTimeout(i, n);
  const { type: o, timeout: r, propCount: s } = Oh(e, t);
  if (!o)
    return a();
  const d = o + "end";
  let u = 0;
  const c = () => {
    e.removeEventListener(d, f), i();
  }, f = (v) => {
    v.target === e && ++u >= s && c();
  };
  setTimeout(() => {
    u < s && c();
  }, r + 1), e.addEventListener(d, f);
}
function Oh(e, t) {
  const n = window.getComputedStyle(e), a = (m) => (n[m] || "").split(", "), l = a(`${Ia}Delay`), i = a(`${Ia}Duration`), o = cf(l, i), r = a(`${Ci}Delay`), s = a(`${Ci}Duration`), d = cf(r, s);
  let u = null, c = 0, f = 0;
  t === Ia ? o > 0 && (u = Ia, c = o, f = i.length) : t === Ci ? d > 0 && (u = Ci, c = d, f = s.length) : (c = Math.max(o, d), u = c > 0 ? o > d ? Ia : Ci : null, f = u ? u === Ia ? i.length : s.length : 0);
  const v = u === Ia && /\b(?:transform|all)(?:,|$)/.test(
    a(`${Ia}Property`).toString()
  );
  return {
    type: u,
    timeout: c,
    propCount: f,
    hasTransform: v
  };
}
function cf(e, t) {
  for (; e.length < t.length; )
    e = e.concat(e);
  return Math.max(...t.map((n, a) => df(n) + df(e[a])));
}
function df(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3;
}
function lu(e) {
  return (e ? e.ownerDocument : document).body.offsetHeight;
}
function v0(e, t, n) {
  const a = e[Ql];
  a && (t = (t ? [t, ...a] : [...a]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t;
}
const fr = Symbol("_vod"), $h = Symbol("_vsh"), Nn = {
  // used for prop mismatch check during hydration
  name: "show",
  beforeMount(e, { value: t }, { transition: n }) {
    e[fr] = e.style.display === "none" ? "" : e.style.display, n && t ? n.beforeEnter(e) : Vi(e, t);
  },
  mounted(e, { value: t }, { transition: n }) {
    n && t && n.enter(e);
  },
  updated(e, { value: t, oldValue: n }, { transition: a }) {
    !t != !n && (a ? t ? (a.beforeEnter(e), Vi(e, !0), a.enter(e)) : a.leave(e, () => {
      Vi(e, !1);
    }) : Vi(e, t));
  },
  beforeUnmount(e, { value: t }) {
    Vi(e, t);
  }
};
function Vi(e, t) {
  e.style.display = t ? e[fr] : "none", e[$h] = !t;
}
const m0 = Symbol(Fn.NODE_ENV !== "production" ? "CSS_VAR_TEXT" : ""), h0 = /(?:^|;)\s*display\s*:/;
function g0(e, t, n) {
  const a = e.style, l = ct(n);
  let i = !1;
  if (n && !l) {
    if (t)
      if (ct(t))
        for (const o of t.split(";")) {
          const r = o.slice(0, o.indexOf(":")).trim();
          n[r] == null && qo(a, r, "");
        }
      else
        for (const o in t)
          n[o] == null && qo(a, o, "");
    for (const o in n)
      o === "display" && (i = !0), qo(a, o, n[o]);
  } else if (l) {
    if (t !== n) {
      const o = a[m0];
      o && (n += ";" + o), a.cssText = n, i = h0.test(n);
    }
  } else t && e.removeAttribute("style");
  fr in e && (e[fr] = i ? a.display : "", e[$h] && (a.display = "none"));
}
const y0 = /[^\\];\s*$/, ff = /\s*!important$/;
function qo(e, t, n) {
  if (Ae(n))
    n.forEach((a) => qo(e, t, a));
  else if (n == null && (n = ""), Fn.NODE_ENV !== "production" && y0.test(n) && fn(
    `Unexpected semicolon at the end of '${t}' style value: '${n}'`
  ), t.startsWith("--"))
    e.setProperty(t, n);
  else {
    const a = b0(e, t);
    ff.test(n) ? e.setProperty(
      pa(a),
      n.replace(ff, ""),
      "important"
    ) : e[a] = n;
  }
}
const vf = ["Webkit", "Moz", "ms"], ws = {};
function b0(e, t) {
  const n = ws[t];
  if (n)
    return n;
  let a = Ht(t);
  if (a !== "filter" && a in e)
    return ws[t] = a;
  a = wn(a);
  for (let l = 0; l < vf.length; l++) {
    const i = vf[l] + a;
    if (i in e)
      return ws[t] = i;
  }
  return t;
}
const mf = "http://www.w3.org/1999/xlink";
function hf(e, t, n, a, l, i = nS(t)) {
  a && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(mf, t.slice(6, t.length)) : e.setAttributeNS(mf, t, n) : n == null || i && !im(n) ? e.removeAttribute(t) : e.setAttribute(
    t,
    i ? "" : xa(n) ? String(n) : n
  );
}
function gf(e, t, n, a, l) {
  if (t === "innerHTML" || t === "textContent") {
    n != null && (e[t] = t === "innerHTML" ? Nh(n) : n);
    return;
  }
  const i = e.tagName;
  if (t === "value" && i !== "PROGRESS" && // custom elements may use _value internally
  !i.includes("-")) {
    const r = i === "OPTION" ? e.getAttribute("value") || "" : e.value, s = n == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(n);
    (r !== s || !("_value" in e)) && (e.value = s), n == null && e.removeAttribute(t), e._value = n;
    return;
  }
  let o = !1;
  if (n === "" || n == null) {
    const r = typeof e[t];
    r === "boolean" ? n = im(n) : n == null && r === "string" ? (n = "", o = !0) : r === "number" && (n = 0, o = !0);
  }
  try {
    e[t] = n;
  } catch (r) {
    Fn.NODE_ENV !== "production" && !o && fn(
      `Failed setting prop "${t}" on <${i.toLowerCase()}>: value ${n} is invalid.`,
      r
    );
  }
  o && e.removeAttribute(l || t);
}
function Wl(e, t, n, a) {
  e.addEventListener(t, n, a);
}
function p0(e, t, n, a) {
  e.removeEventListener(t, n, a);
}
const yf = Symbol("_vei");
function S0(e, t, n, a, l = null) {
  const i = e[yf] || (e[yf] = {}), o = i[t];
  if (a && o)
    o.value = Fn.NODE_ENV !== "production" ? pf(a, t) : a;
  else {
    const [r, s] = w0(t);
    if (a) {
      const d = i[t] = k0(
        Fn.NODE_ENV !== "production" ? pf(a, t) : a,
        l
      );
      Wl(e, r, d, s);
    } else o && (p0(e, r, o, s), i[t] = void 0);
  }
}
const bf = /(?:Once|Passive|Capture)$/;
function w0(e) {
  let t;
  if (bf.test(e)) {
    t = {};
    let a;
    for (; a = e.match(bf); )
      e = e.slice(0, e.length - a[0].length), t[a[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : pa(e.slice(2)), t];
}
let _s = 0;
const _0 = /* @__PURE__ */ Promise.resolve(), x0 = () => _s || (_0.then(() => _s = 0), _s = Date.now());
function k0(e, t) {
  const n = (a) => {
    if (!a._vts)
      a._vts = Date.now();
    else if (a._vts <= n.attached)
      return;
    Rn(
      C0(a, n.value),
      t,
      5,
      [a]
    );
  };
  return n.value = e, n.attached = x0(), n;
}
function pf(e, t) {
  return Te(e) || Ae(e) ? e : (fn(
    `Wrong type passed as event handler to ${t} - did you forget @ or : in front of your prop?
Expected function or array of functions, received type ${typeof e}.`
  ), Bt);
}
function C0(e, t) {
  if (Ae(t)) {
    const n = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      n.call(e), e._stopped = !0;
    }, t.map(
      (a) => (l) => !l._stopped && a && a(l)
    );
  } else
    return t;
}
const Sf = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, V0 = (e, t, n, a, l, i) => {
  const o = l === "svg";
  t === "class" ? v0(e, a, o) : t === "style" ? g0(e, n, a) : fo(t) ? Zo(t) || S0(e, t, n, a, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : E0(e, t, a, o)) ? (gf(e, t, a), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && hf(e, t, a, o, i, t !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(t) || !ct(a)) ? gf(e, Ht(t), a, i, t) : (t === "true-value" ? e._trueValue = a : t === "false-value" && (e._falseValue = a), hf(e, t, a, o));
};
function E0(e, t, n, a) {
  if (a)
    return !!(t === "innerHTML" || t === "textContent" || t in e && Sf(t) && Te(n));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (t === "width" || t === "height") {
    const l = e.tagName;
    if (l === "IMG" || l === "VIDEO" || l === "CANVAS" || l === "SOURCE")
      return !1;
  }
  return Sf(t) && ct(n) ? !1 : t in e;
}
const Bh = /* @__PURE__ */ new WeakMap(), Mh = /* @__PURE__ */ new WeakMap(), vr = Symbol("_moveCb"), wf = Symbol("_enterCb"), P0 = (e) => (delete e.props.mode, e), I0 = /* @__PURE__ */ P0({
  name: "TransitionGroup",
  props: /* @__PURE__ */ pt({}, Ah, {
    tag: String,
    moveClass: String
  }),
  setup(e, { slots: t }) {
    const n = Ha(), a = Km();
    let l, i;
    return mc(() => {
      if (!l.length)
        return;
      const o = e.moveClass || `${e.name || "v"}-move`;
      if (!T0(
        l[0].el,
        n.vnode.el,
        o
      )) {
        l = [];
        return;
      }
      l.forEach(N0), l.forEach(D0);
      const r = l.filter(A0);
      lu(n.vnode.el), r.forEach((s) => {
        const d = s.el, u = d.style;
        qn(d, o), u.transform = u.webkitTransform = u.transitionDuration = "";
        const c = d[vr] = (f) => {
          f && f.target !== d || (!f || f.propertyName.endsWith("transform")) && (d.removeEventListener("transitionend", c), d[vr] = null, Da(d, o));
        };
        d.addEventListener("transitionend", c);
      }), l = [];
    }), () => {
      const o = Pe(e), r = Th(o);
      let s = o.tag || ye;
      if (l = [], i)
        for (let d = 0; d < i.length; d++) {
          const u = i[d];
          u.el && u.el instanceof Element && (l.push(u), hl(
            u,
            Wi(
              u,
              r,
              a,
              n
            )
          ), Bh.set(
            u,
            u.el.getBoundingClientRect()
          ));
        }
      i = t.default ? dc(t.default()) : [];
      for (let d = 0; d < i.length; d++) {
        const u = i[d];
        u.key != null ? hl(
          u,
          Wi(u, r, a, n)
        ) : Fn.NODE_ENV !== "production" && u.type !== xl && fn("<TransitionGroup> children must be keyed.");
      }
      return b(s, null, i);
    };
  }
}), _c = I0;
function N0(e) {
  const t = e.el;
  t[vr] && t[vr](), t[wf] && t[wf]();
}
function D0(e) {
  Mh.set(e, e.el.getBoundingClientRect());
}
function A0(e) {
  const t = Bh.get(e), n = Mh.get(e), a = t.left - n.left, l = t.top - n.top;
  if (a || l) {
    const i = e.el.style;
    return i.transform = i.webkitTransform = `translate(${a}px,${l}px)`, i.transitionDuration = "0s", e;
  }
}
function T0(e, t, n) {
  const a = e.cloneNode(), l = e[Ql];
  l && l.forEach((r) => {
    r.split(/\s+/).forEach((s) => s && a.classList.remove(s));
  }), n.split(/\s+/).forEach((r) => r && a.classList.add(r)), a.style.display = "none";
  const i = t.nodeType === 1 ? t : t.parentNode;
  i.appendChild(a);
  const { hasTransform: o } = Oh(a);
  return i.removeChild(a), o;
}
const _f = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return Ae(t) ? (n) => zl(t, n) : t;
};
function O0(e) {
  e.target.composing = !0;
}
function xf(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
const xs = Symbol("_assign"), $0 = {
  created(e, { modifiers: { lazy: t, trim: n, number: a } }, l) {
    e[xs] = _f(l);
    const i = a || l.props && l.props.type === "number";
    Wl(e, t ? "change" : "input", (o) => {
      if (o.target.composing) return;
      let r = e.value;
      n && (r = r.trim()), i && (r = zs(r)), e[xs](r);
    }), n && Wl(e, "change", () => {
      e.value = e.value.trim();
    }), t || (Wl(e, "compositionstart", O0), Wl(e, "compositionend", xf), Wl(e, "change", xf));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t ?? "";
  },
  beforeUpdate(e, { value: t, oldValue: n, modifiers: { lazy: a, trim: l, number: i } }, o) {
    if (e[xs] = _f(o), e.composing) return;
    const r = (i || e.type === "number") && !/^0\d/.test(e.value) ? zs(e.value) : e.value, s = t ?? "";
    r !== s && (document.activeElement === e && e.type !== "range" && (a && t === n || l && e.value.trim() === s) || (e.value = s));
  }
}, B0 = ["ctrl", "shift", "alt", "meta"], M0 = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, t) => B0.some((n) => e[`${n}Key`] && !t.includes(n))
}, ea = (e, t) => {
  const n = e._withMods || (e._withMods = {}), a = t.join(".");
  return n[a] || (n[a] = (l, ...i) => {
    for (let o = 0; o < t.length; o++) {
      const r = M0[t[o]];
      if (r && r(l, t)) return;
    }
    return e(l, ...i);
  });
}, R0 = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Rh = (e, t) => {
  const n = e._withKeys || (e._withKeys = {}), a = t.join(".");
  return n[a] || (n[a] = (l) => {
    if (!("key" in l))
      return;
    const i = pa(l.key);
    if (t.some(
      (o) => o === i || R0[o] === i
    ))
      return e(l);
  });
}, L0 = /* @__PURE__ */ pt({ patchProp: V0 }, u0);
let kf;
function Lh() {
  return kf || (kf = Aw(L0));
}
const Fh = (...e) => {
  Lh().render(...e);
}, Rr = (...e) => {
  const t = Lh().createApp(...e);
  Fn.NODE_ENV !== "production" && (H0(t), z0(t));
  const { mount: n } = t;
  return t.mount = (a) => {
    const l = j0(a);
    if (!l) return;
    const i = t._component;
    !Te(i) && !i.render && !i.template && (i.template = l.innerHTML), l.nodeType === 1 && (l.textContent = "");
    const o = n(l, !1, F0(l));
    return l instanceof Element && (l.removeAttribute("v-cloak"), l.setAttribute("data-v-app", "")), o;
  }, t;
};
function F0(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function H0(e) {
  Object.defineProperty(e.config, "isNativeTag", {
    value: (t) => Zp(t) || Qp(t) || eS(t),
    writable: !1
  });
}
function z0(e) {
  {
    const t = e.config.isCustomElement;
    Object.defineProperty(e.config, "isCustomElement", {
      get() {
        return t;
      },
      set() {
        fn(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const n = e.config.compilerOptions, a = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(e.config, "compilerOptions", {
      get() {
        return fn(a), n;
      },
      set() {
        fn(a);
      }
    });
  }
}
function j0(e) {
  if (ct(e)) {
    const t = document.querySelector(e);
    return Fn.NODE_ENV !== "production" && !t && fn(
      `Failed to mount app: mount target selector "${e}" returned null.`
    ), t;
  }
  return Fn.NODE_ENV !== "production" && window.ShadowRoot && e instanceof window.ShadowRoot && e.mode === "closed" && fn(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), e;
}
var W0 = {};
function U0() {
  o0();
}
W0.NODE_ENV !== "production" && U0();
function G0() {
  return Hh().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function Hh() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {};
}
const K0 = typeof Proxy == "function", Y0 = "devtools-plugin:setup", q0 = "plugin:settings:set";
let Ml, iu;
function X0() {
  var e;
  return Ml !== void 0 || (typeof window < "u" && window.performance ? (Ml = !0, iu = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (Ml = !0, iu = globalThis.perf_hooks.performance) : Ml = !1), Ml;
}
function J0() {
  return X0() ? iu.now() : Date.now();
}
class Z0 {
  constructor(t, n) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = n;
    const a = {};
    if (t.settings)
      for (const o in t.settings) {
        const r = t.settings[o];
        a[o] = r.defaultValue;
      }
    const l = `__vue-devtools-plugin-settings__${t.id}`;
    let i = Object.assign({}, a);
    try {
      const o = localStorage.getItem(l), r = JSON.parse(o);
      Object.assign(i, r);
    } catch {
    }
    this.fallbacks = {
      getSettings() {
        return i;
      },
      setSettings(o) {
        try {
          localStorage.setItem(l, JSON.stringify(o));
        } catch {
        }
        i = o;
      },
      now() {
        return J0();
      }
    }, n && n.on(q0, (o, r) => {
      o === this.plugin.id && this.fallbacks.setSettings(r);
    }), this.proxiedOn = new Proxy({}, {
      get: (o, r) => this.target ? this.target.on[r] : (...s) => {
        this.onQueue.push({
          method: r,
          args: s
        });
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (o, r) => this.target ? this.target[r] : r === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(r) ? (...s) => (this.targetQueue.push({
        method: r,
        args: s,
        resolve: () => {
        }
      }), this.fallbacks[r](...s)) : (...s) => new Promise((d) => {
        this.targetQueue.push({
          method: r,
          args: s,
          resolve: d
        });
      })
    });
  }
  async setRealTarget(t) {
    this.target = t;
    for (const n of this.onQueue)
      this.target.on[n.method](...n.args);
    for (const n of this.targetQueue)
      n.resolve(await this.target[n.method](...n.args));
  }
}
function Q0(e, t) {
  const n = e, a = Hh(), l = G0(), i = K0 && n.enableEarlyProxy;
  if (l && (a.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !i))
    l.emit(Y0, e, t);
  else {
    const o = i ? new Z0(n, l) : null;
    (a.__VUE_DEVTOOLS_PLUGINS__ = a.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: n,
      setupFn: t,
      proxy: o
    }), o && t(o.proxiedTarget);
  }
}
var Qt = {};
const ha = typeof document < "u";
function zh(e) {
  return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e;
}
function e_(e) {
  return e.__esModule || e[Symbol.toStringTag] === "Module" || e.default && zh(e.default);
}
const Ze = Object.assign;
function ks(e, t) {
  const n = {};
  for (const a in t) {
    const l = t[a];
    n[a] = xn(l) ? l.map(e) : e(l);
  }
  return n;
}
const Li = () => {
}, xn = Array.isArray;
function Cf(e, t) {
  const n = {};
  for (const a in e) n[a] = a in t ? t[a] : e[a];
  return n;
}
function je(e) {
  const t = Array.from(arguments).slice(1);
  console.warn.apply(console, ["[Vue Router warn]: " + e].concat(t));
}
const jh = /#/g, t_ = /&/g, n_ = /\//g, a_ = /=/g, l_ = /\?/g, Wh = /\+/g, i_ = /%5B/g, o_ = /%5D/g, Uh = /%5E/g, r_ = /%60/g, Gh = /%7B/g, s_ = /%7C/g, Kh = /%7D/g, u_ = /%20/g;
function xc(e) {
  return e == null ? "" : encodeURI("" + e).replace(s_, "|").replace(i_, "[").replace(o_, "]");
}
function c_(e) {
  return xc(e).replace(Gh, "{").replace(Kh, "}").replace(Uh, "^");
}
function ou(e) {
  return xc(e).replace(Wh, "%2B").replace(u_, "+").replace(jh, "%23").replace(t_, "%26").replace(r_, "`").replace(Gh, "{").replace(Kh, "}").replace(Uh, "^");
}
function d_(e) {
  return ou(e).replace(a_, "%3D");
}
function f_(e) {
  return xc(e).replace(jh, "%23").replace(l_, "%3F");
}
function v_(e) {
  return f_(e).replace(n_, "%2F");
}
function ei(e) {
  if (e == null) return null;
  try {
    return decodeURIComponent("" + e);
  } catch {
    Qt.NODE_ENV !== "production" && je(`Error decoding "${e}". Using original value`);
  }
  return "" + e;
}
const m_ = /\/$/, h_ = (e) => e.replace(m_, "");
function Cs(e, t, n = "/") {
  let a, l = {}, i = "", o = "";
  const r = t.indexOf("#");
  let s = t.indexOf("?");
  return s = r >= 0 && s > r ? -1 : s, s >= 0 && (a = t.slice(0, s), i = t.slice(s, r > 0 ? r : t.length), l = e(i.slice(1))), r >= 0 && (a = a || t.slice(0, r), o = t.slice(r, t.length)), a = b_(a ?? t, n), {
    fullPath: a + i + o,
    path: a,
    query: l,
    hash: ei(o)
  };
}
function g_(e, t) {
  const n = t.query ? e(t.query) : "";
  return t.path + (n && "?") + n + (t.hash || "");
}
function Vf(e, t) {
  return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/";
}
function Ef(e, t, n) {
  const a = t.matched.length - 1, l = n.matched.length - 1;
  return a > -1 && a === l && Ra(t.matched[a], n.matched[l]) && Yh(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash;
}
function Ra(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t);
}
function Yh(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1;
  for (const n in e) if (!y_(e[n], t[n])) return !1;
  return !0;
}
function y_(e, t) {
  return xn(e) ? Pf(e, t) : xn(t) ? Pf(t, e) : e === t;
}
function Pf(e, t) {
  return xn(t) ? e.length === t.length && e.every((n, a) => n === t[a]) : e.length === 1 && e[0] === t;
}
function b_(e, t) {
  if (e.startsWith("/")) return e;
  if (Qt.NODE_ENV !== "production" && !t.startsWith("/"))
    return je(`Cannot resolve a relative location without an absolute path. Trying to resolve "${e}" from "${t}". It should look like "/${t}".`), e;
  if (!e) return t;
  const n = t.split("/"), a = e.split("/"), l = a[a.length - 1];
  (l === ".." || l === ".") && a.push("");
  let i = n.length - 1, o, r;
  for (o = 0; o < a.length; o++)
    if (r = a[o], r !== ".")
      if (r === "..")
        i > 1 && i--;
      else break;
  return n.slice(0, i).join("/") + "/" + a.slice(o).join("/");
}
const Na = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
let ru = /* @__PURE__ */ function(e) {
  return e.pop = "pop", e.push = "push", e;
}({}), Vs = /* @__PURE__ */ function(e) {
  return e.back = "back", e.forward = "forward", e.unknown = "", e;
}({});
function p_(e) {
  if (!e) if (ha) {
    const t = document.querySelector("base");
    e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "");
  } else e = "/";
  return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), h_(e);
}
const S_ = /^[^#]+#/;
function w_(e, t) {
  return e.replace(S_, "#") + t;
}
function __(e, t) {
  const n = document.documentElement.getBoundingClientRect(), a = e.getBoundingClientRect();
  return {
    behavior: t.behavior,
    left: a.left - n.left - (t.left || 0),
    top: a.top - n.top - (t.top || 0)
  };
}
const Lr = () => ({
  left: window.scrollX,
  top: window.scrollY
});
function x_(e) {
  let t;
  if ("el" in e) {
    const n = e.el, a = typeof n == "string" && n.startsWith("#");
    if (Qt.NODE_ENV !== "production" && typeof e.el == "string" && (!a || !document.getElementById(e.el.slice(1))))
      try {
        const i = document.querySelector(e.el);
        if (a && i) {
          je(`The selector "${e.el}" should be passed as "el: document.querySelector('${e.el}')" because it starts with "#".`);
          return;
        }
      } catch {
        je(`The selector "${e.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
        return;
      }
    const l = typeof n == "string" ? a ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
    if (!l) {
      Qt.NODE_ENV !== "production" && je(`Couldn't find element using selector "${e.el}" returned by scrollBehavior.`);
      return;
    }
    t = __(l, e);
  } else t = e;
  "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY);
}
function If(e, t) {
  return (history.state ? history.state.position - t : -1) + e;
}
const su = /* @__PURE__ */ new Map();
function k_(e, t) {
  su.set(e, t);
}
function C_(e) {
  const t = su.get(e);
  return su.delete(e), t;
}
function mr(e) {
  return typeof e == "string" || e && typeof e == "object";
}
function qh(e) {
  return typeof e == "string" || typeof e == "symbol";
}
let wt = /* @__PURE__ */ function(e) {
  return e[e.MATCHER_NOT_FOUND = 1] = "MATCHER_NOT_FOUND", e[e.NAVIGATION_GUARD_REDIRECT = 2] = "NAVIGATION_GUARD_REDIRECT", e[e.NAVIGATION_ABORTED = 4] = "NAVIGATION_ABORTED", e[e.NAVIGATION_CANCELLED = 8] = "NAVIGATION_CANCELLED", e[e.NAVIGATION_DUPLICATED = 16] = "NAVIGATION_DUPLICATED", e;
}({});
const uu = Symbol(Qt.NODE_ENV !== "production" ? "navigation failure" : ""), V_ = {
  [wt.MATCHER_NOT_FOUND]({ location: e, currentLocation: t }) {
    return `No match for
 ${JSON.stringify(e)}${t ? `
while being at
` + JSON.stringify(t) : ""}`;
  },
  [wt.NAVIGATION_GUARD_REDIRECT]({ from: e, to: t }) {
    return `Redirected from "${e.fullPath}" to "${P_(t)}" via a navigation guard.`;
  },
  [wt.NAVIGATION_ABORTED]({ from: e, to: t }) {
    return `Navigation aborted from "${e.fullPath}" to "${t.fullPath}" via a navigation guard.`;
  },
  [wt.NAVIGATION_CANCELLED]({ from: e, to: t }) {
    return `Navigation cancelled from "${e.fullPath}" to "${t.fullPath}" with a new navigation.`;
  },
  [wt.NAVIGATION_DUPLICATED]({ from: e, to: t }) {
    return `Avoided redundant navigation to current location: "${e.fullPath}".`;
  }
};
function ti(e, t) {
  return Qt.NODE_ENV !== "production" ? Ze(new Error(V_[e](t)), {
    type: e,
    [uu]: !0
  }, t) : Ze(/* @__PURE__ */ new Error(), {
    type: e,
    [uu]: !0
  }, t);
}
function ca(e, t) {
  return e instanceof Error && uu in e && (t == null || !!(e.type & t));
}
const E_ = [
  "params",
  "query",
  "hash"
];
function P_(e) {
  if (typeof e == "string") return e;
  if (e.path != null) return e.path;
  const t = {};
  for (const n of E_) n in e && (t[n] = e[n]);
  return JSON.stringify(t, null, 2);
}
function I_(e) {
  const t = {};
  if (e === "" || e === "?") return t;
  const n = (e[0] === "?" ? e.slice(1) : e).split("&");
  for (let a = 0; a < n.length; ++a) {
    const l = n[a].replace(Wh, " "), i = l.indexOf("="), o = ei(i < 0 ? l : l.slice(0, i)), r = i < 0 ? null : ei(l.slice(i + 1));
    if (o in t) {
      let s = t[o];
      xn(s) || (s = t[o] = [s]), s.push(r);
    } else t[o] = r;
  }
  return t;
}
function Nf(e) {
  let t = "";
  for (let n in e) {
    const a = e[n];
    if (n = d_(n), a == null) {
      a !== void 0 && (t += (t.length ? "&" : "") + n);
      continue;
    }
    (xn(a) ? a.map((l) => l && ou(l)) : [a && ou(a)]).forEach((l) => {
      l !== void 0 && (t += (t.length ? "&" : "") + n, l != null && (t += "=" + l));
    });
  }
  return t;
}
function N_(e) {
  const t = {};
  for (const n in e) {
    const a = e[n];
    a !== void 0 && (t[n] = xn(a) ? a.map((l) => l == null ? null : "" + l) : a == null ? a : "" + a);
  }
  return t;
}
const D_ = Symbol(Qt.NODE_ENV !== "production" ? "router view location matched" : ""), Df = Symbol(Qt.NODE_ENV !== "production" ? "router view depth" : ""), kc = Symbol(Qt.NODE_ENV !== "production" ? "router" : ""), Xh = Symbol(Qt.NODE_ENV !== "production" ? "route location" : ""), cu = Symbol(Qt.NODE_ENV !== "production" ? "router view location" : "");
function Ei() {
  let e = [];
  function t(a) {
    return e.push(a), () => {
      const l = e.indexOf(a);
      l > -1 && e.splice(l, 1);
    };
  }
  function n() {
    e = [];
  }
  return {
    add: t,
    list: () => e.slice(),
    reset: n
  };
}
function Oa(e, t, n, a, l, i = (o) => o()) {
  const o = a && (a.enterCallbacks[l] = a.enterCallbacks[l] || []);
  return () => new Promise((r, s) => {
    const d = (f) => {
      f === !1 ? s(ti(wt.NAVIGATION_ABORTED, {
        from: n,
        to: t
      })) : f instanceof Error ? s(f) : mr(f) ? s(ti(wt.NAVIGATION_GUARD_REDIRECT, {
        from: t,
        to: f
      })) : (o && a.enterCallbacks[l] === o && typeof f == "function" && o.push(f), r());
    }, u = i(() => e.call(a && a.instances[l], t, n, Qt.NODE_ENV !== "production" ? A_(d, t, n) : d));
    let c = Promise.resolve(u);
    if (e.length < 3 && (c = c.then(d)), Qt.NODE_ENV !== "production" && e.length > 2) {
      const f = `The "next" callback was never called inside of ${e.name ? '"' + e.name + '"' : ""}:
${e.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
      if (typeof u == "object" && "then" in u) c = c.then((v) => d._called ? v : (je(f), Promise.reject(/* @__PURE__ */ new Error("Invalid navigation guard"))));
      else if (u !== void 0 && !d._called) {
        je(f), s(/* @__PURE__ */ new Error("Invalid navigation guard"));
        return;
      }
    }
    c.catch((f) => s(f));
  });
}
function A_(e, t, n) {
  let a = 0;
  return function() {
    a++ === 1 && je(`The "next" callback was called more than once in one navigation guard when going from "${n.fullPath}" to "${t.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`), e._called = !0, a === 1 && e.apply(null, arguments);
  };
}
function Es(e, t, n, a, l = (i) => i()) {
  const i = [];
  for (const o of e) {
    Qt.NODE_ENV !== "production" && !o.components && o.children && !o.children.length && je(`Record with path "${o.path}" is either missing a "component(s)" or "children" property.`);
    for (const r in o.components) {
      let s = o.components[r];
      if (Qt.NODE_ENV !== "production") {
        if (!s || typeof s != "object" && typeof s != "function")
          throw je(`Component "${r}" in record with path "${o.path}" is not a valid component. Received "${String(s)}".`), new Error("Invalid route component");
        if ("then" in s) {
          je(`Component "${r}" in record with path "${o.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
          const d = s;
          s = () => d;
        } else s.__asyncLoader && !s.__warnedDefineAsync && (s.__warnedDefineAsync = !0, je(`Component "${r}" in record with path "${o.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`));
      }
      if (!(t !== "beforeRouteEnter" && !o.instances[r]))
        if (zh(s)) {
          const d = (s.__vccOpts || s)[t];
          d && i.push(Oa(d, n, a, o, r, l));
        } else {
          let d = s();
          Qt.NODE_ENV !== "production" && !("catch" in d) && (je(`Component "${r}" in record with path "${o.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`), d = Promise.resolve(d)), i.push(() => d.then((u) => {
            if (!u) throw new Error(`Couldn't resolve component "${r}" at "${o.path}"`);
            const c = e_(u) ? u.default : u;
            o.mods[r] = u, o.components[r] = c;
            const f = (c.__vccOpts || c)[t];
            return f && Oa(f, n, a, o, r, l)();
          }));
        }
    }
  }
  return i;
}
function T_(e, t) {
  const n = [], a = [], l = [], i = Math.max(t.matched.length, e.matched.length);
  for (let o = 0; o < i; o++) {
    const r = t.matched[o];
    r && (e.matched.find((d) => Ra(d, r)) ? a.push(r) : n.push(r));
    const s = e.matched[o];
    s && (t.matched.find((d) => Ra(d, s)) || l.push(s));
  }
  return [
    n,
    a,
    l
  ];
}
function Pi(e, t) {
  const n = Ze({}, e, { matched: e.matched.map((a) => W_(a, [
    "instances",
    "children",
    "aliasOf"
  ])) });
  return { _custom: {
    type: null,
    readOnly: !0,
    display: e.fullPath,
    tooltip: t,
    value: n
  } };
}
function Bo(e) {
  return { _custom: { display: e } };
}
let O_ = 0;
function $_(e, t, n) {
  if (t.__hasDevtools) return;
  t.__hasDevtools = !0;
  const a = O_++;
  Q0({
    id: "org.vuejs.router" + (a ? "." + a : ""),
    label: "Vue Router",
    packageName: "vue-router",
    homepage: "https://router.vuejs.org",
    logo: "https://router.vuejs.org/logo.png",
    componentStateTypes: ["Routing"],
    app: e
  }, (l) => {
    typeof l.now != "function" && je("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), l.on.inspectComponent((u, c) => {
      u.instanceData && u.instanceData.state.push({
        type: "Routing",
        key: "$route",
        editable: !1,
        value: Pi(t.currentRoute.value, "Current Route")
      });
    }), l.on.visitComponentTree(({ treeNode: u, componentInstance: c }) => {
      if (c.__vrv_devtools) {
        const f = c.__vrv_devtools;
        u.tags.push({
          label: (f.name ? `${f.name.toString()}: ` : "") + f.path,
          textColor: 0,
          tooltip: "This component is rendered by &lt;router-view&gt;",
          backgroundColor: Jh
        });
      }
      xn(c.__vrl_devtools) && (c.__devtoolsApi = l, c.__vrl_devtools.forEach((f) => {
        let v = f.route.path, m = eg, h = "", g = 0;
        f.error ? (v = f.error, m = F_, g = H_) : f.isExactActive ? (m = Qh, h = "This is exactly active") : f.isActive && (m = Zh, h = "This link is active"), u.tags.push({
          label: v,
          textColor: g,
          tooltip: h,
          backgroundColor: m
        });
      }));
    }), me(t.currentRoute, () => {
      s(), l.notifyComponentUpdate(), l.sendInspectorTree(r), l.sendInspectorState(r);
    });
    const i = "router:navigations:" + a;
    l.addTimelineLayer({
      id: i,
      label: `Router${a ? " " + a : ""} Navigations`,
      color: 4237508
    }), t.onError((u, c) => {
      l.addTimelineEvent({
        layerId: i,
        event: {
          title: "Error during Navigation",
          subtitle: c.fullPath,
          logType: "error",
          time: l.now(),
          data: { error: u },
          groupId: c.meta.__navigationId
        }
      });
    });
    let o = 0;
    t.beforeEach((u, c) => {
      const f = {
        guard: Bo("beforeEach"),
        from: Pi(c, "Current Location during this navigation"),
        to: Pi(u, "Target location")
      };
      Object.defineProperty(u.meta, "__navigationId", { value: o++ }), l.addTimelineEvent({
        layerId: i,
        event: {
          time: l.now(),
          title: "Start of navigation",
          subtitle: u.fullPath,
          data: f,
          groupId: u.meta.__navigationId
        }
      });
    }), t.afterEach((u, c, f) => {
      const v = { guard: Bo("afterEach") };
      f ? (v.failure = { _custom: {
        type: Error,
        readOnly: !0,
        display: f ? f.message : "",
        tooltip: "Navigation Failure",
        value: f
      } }, v.status = Bo("")) : v.status = Bo(""), v.from = Pi(c, "Current Location during this navigation"), v.to = Pi(u, "Target location"), l.addTimelineEvent({
        layerId: i,
        event: {
          title: "End of navigation",
          subtitle: u.fullPath,
          time: l.now(),
          data: v,
          logType: f ? "warning" : "default",
          groupId: u.meta.__navigationId
        }
      });
    });
    const r = "router-inspector:" + a;
    l.addInspector({
      id: r,
      label: "Routes" + (a ? " " + a : ""),
      icon: "book",
      treeFilterPlaceholder: "Search routes"
    });
    function s() {
      if (!d) return;
      const u = d;
      let c = n.getRoutes().filter((f) => !f.parent || !f.parent.record.components);
      c.forEach(ag), u.filter && (c = c.filter((f) => du(f, u.filter.toLowerCase()))), c.forEach((f) => ng(f, t.currentRoute.value)), u.rootNodes = c.map(tg);
    }
    let d;
    l.on.getInspectorTree((u) => {
      d = u, u.app === e && u.inspectorId === r && s();
    }), l.on.getInspectorState((u) => {
      if (u.app === e && u.inspectorId === r) {
        const c = n.getRoutes().find((f) => f.record.__vd_id === u.nodeId);
        c && (u.state = { options: M_(c) });
      }
    }), l.sendInspectorTree(r), l.sendInspectorState(r);
  });
}
function B_(e) {
  return e.optional ? e.repeatable ? "*" : "?" : e.repeatable ? "+" : "";
}
function M_(e) {
  const { record: t } = e, n = [{
    editable: !1,
    key: "path",
    value: t.path
  }];
  return t.name != null && n.push({
    editable: !1,
    key: "name",
    value: t.name
  }), n.push({
    editable: !1,
    key: "regexp",
    value: e.re
  }), e.keys.length && n.push({
    editable: !1,
    key: "keys",
    value: { _custom: {
      type: null,
      readOnly: !0,
      display: e.keys.map((a) => `${a.name}${B_(a)}`).join(" "),
      tooltip: "Param keys",
      value: e.keys
    } }
  }), t.redirect != null && n.push({
    editable: !1,
    key: "redirect",
    value: t.redirect
  }), e.alias.length && n.push({
    editable: !1,
    key: "aliases",
    value: e.alias.map((a) => a.record.path)
  }), Object.keys(e.record.meta).length && n.push({
    editable: !1,
    key: "meta",
    value: e.record.meta
  }), n.push({
    key: "score",
    editable: !1,
    value: { _custom: {
      type: null,
      readOnly: !0,
      display: e.score.map((a) => a.join(", ")).join(" | "),
      tooltip: "Score used to sort routes",
      value: e.score
    } }
  }), n;
}
const Jh = 15485081, Zh = 2450411, Qh = 8702998, R_ = 2282478, eg = 16486972, L_ = 6710886, F_ = 16704226, H_ = 12131356;
function tg(e) {
  const t = [], { record: n } = e;
  n.name != null && t.push({
    label: String(n.name),
    textColor: 0,
    backgroundColor: R_
  }), n.aliasOf && t.push({
    label: "alias",
    textColor: 0,
    backgroundColor: eg
  }), e.__vd_match && t.push({
    label: "matches",
    textColor: 0,
    backgroundColor: Jh
  }), e.__vd_exactActive && t.push({
    label: "exact",
    textColor: 0,
    backgroundColor: Qh
  }), e.__vd_active && t.push({
    label: "active",
    textColor: 0,
    backgroundColor: Zh
  }), n.redirect && t.push({
    label: typeof n.redirect == "string" ? `redirect: ${n.redirect}` : "redirects",
    textColor: 16777215,
    backgroundColor: L_
  });
  let a = n.__vd_id;
  return a == null && (a = String(z_++), n.__vd_id = a), {
    id: a,
    label: n.path,
    tags: t,
    children: e.children.map(tg)
  };
}
let z_ = 0;
const j_ = /^\/(.*)\/([a-z]*)$/;
function ng(e, t) {
  const n = t.matched.length && Ra(t.matched[t.matched.length - 1], e.record);
  e.__vd_exactActive = e.__vd_active = n, n || (e.__vd_active = t.matched.some((a) => Ra(a, e.record))), e.children.forEach((a) => ng(a, t));
}
function ag(e) {
  e.__vd_match = !1, e.children.forEach(ag);
}
function du(e, t) {
  const n = String(e.re).match(j_);
  if (e.__vd_match = !1, !n || n.length < 3) return !1;
  if (new RegExp(n[1].replace(/\$$/, ""), n[2]).test(t))
    return e.children.forEach((i) => du(i, t)), e.record.path !== "/" || t === "/" ? (e.__vd_match = e.re.test(t), !0) : !1;
  const a = e.record.path.toLowerCase(), l = ei(a);
  return !t.startsWith("/") && (l.includes(t) || a.includes(t)) || l.startsWith(t) || a.startsWith(t) || e.record.name && String(e.record.name).includes(t) ? !0 : e.children.some((i) => du(i, t));
}
function W_(e, t) {
  const n = {};
  for (const a in e) t.includes(a) || (n[a] = e[a]);
  return n;
}
var st = {};
let U_ = () => location.protocol + "//" + location.host;
function lg(e, t) {
  const { pathname: n, search: a, hash: l } = t, i = e.indexOf("#");
  if (i > -1) {
    let o = l.includes(e.slice(i)) ? e.slice(i).length : 1, r = l.slice(o);
    return r[0] !== "/" && (r = "/" + r), Vf(r, "");
  }
  return Vf(n, e) + a + l;
}
function G_(e, t, n, a) {
  let l = [], i = [], o = null;
  const r = ({ state: f }) => {
    const v = lg(e, location), m = n.value, h = t.value;
    let g = 0;
    if (f) {
      if (n.value = v, t.value = f, o && o === m) {
        o = null;
        return;
      }
      g = h ? f.position - h.position : 0;
    } else a(v);
    l.forEach((p) => {
      p(n.value, m, {
        delta: g,
        type: ru.pop,
        direction: g ? g > 0 ? Vs.forward : Vs.back : Vs.unknown
      });
    });
  };
  function s() {
    o = n.value;
  }
  function d(f) {
    l.push(f);
    const v = () => {
      const m = l.indexOf(f);
      m > -1 && l.splice(m, 1);
    };
    return i.push(v), v;
  }
  function u() {
    if (document.visibilityState === "hidden") {
      const { history: f } = window;
      if (!f.state) return;
      f.replaceState(Ze({}, f.state, { scroll: Lr() }), "");
    }
  }
  function c() {
    for (const f of i) f();
    i = [], window.removeEventListener("popstate", r), window.removeEventListener("pagehide", u), document.removeEventListener("visibilitychange", u);
  }
  return window.addEventListener("popstate", r), window.addEventListener("pagehide", u), document.addEventListener("visibilitychange", u), {
    pauseListeners: s,
    listen: d,
    destroy: c
  };
}
function Af(e, t, n, a = !1, l = !1) {
  return {
    back: e,
    current: t,
    forward: n,
    replaced: a,
    position: window.history.length,
    scroll: l ? Lr() : null
  };
}
function K_(e) {
  const { history: t, location: n } = window, a = { value: lg(e, n) }, l = { value: t.state };
  l.value || i(a.value, {
    back: null,
    current: a.value,
    forward: null,
    position: t.length - 1,
    replaced: !0,
    scroll: null
  }, !0);
  function i(s, d, u) {
    const c = e.indexOf("#"), f = c > -1 ? (n.host && document.querySelector("base") ? e : e.slice(c)) + s : U_() + e + s;
    try {
      t[u ? "replaceState" : "pushState"](d, "", f), l.value = d;
    } catch (v) {
      st.NODE_ENV !== "production" ? je("Error with push/replace State", v) : console.error(v), n[u ? "replace" : "assign"](f);
    }
  }
  function o(s, d) {
    i(s, Ze({}, t.state, Af(l.value.back, s, l.value.forward, !0), d, { position: l.value.position }), !0), a.value = s;
  }
  function r(s, d) {
    const u = Ze({}, l.value, t.state, {
      forward: s,
      scroll: Lr()
    });
    st.NODE_ENV !== "production" && !t.state && je(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://router.vuejs.org/guide/migration/#Usage-of-history-state`), i(u.current, u, !0), i(s, Ze({}, Af(a.value, s, null), { position: u.position + 1 }, d), !1), a.value = s;
  }
  return {
    location: a,
    state: l,
    push: r,
    replace: o
  };
}
function Y_(e) {
  e = p_(e);
  const t = K_(e), n = G_(e, t.state, t.location, t.replace);
  function a(i, o = !0) {
    o || n.pauseListeners(), history.go(i);
  }
  const l = Ze({
    location: "",
    base: e,
    go: a,
    createHref: w_.bind(null, e)
  }, t, n);
  return Object.defineProperty(l, "location", {
    enumerable: !0,
    get: () => t.location.value
  }), Object.defineProperty(l, "state", {
    enumerable: !0,
    get: () => t.state.value
  }), l;
}
let el = /* @__PURE__ */ function(e) {
  return e[e.Static = 0] = "Static", e[e.Param = 1] = "Param", e[e.Group = 2] = "Group", e;
}({});
var Ot = /* @__PURE__ */ function(e) {
  return e[e.Static = 0] = "Static", e[e.Param = 1] = "Param", e[e.ParamRegExp = 2] = "ParamRegExp", e[e.ParamRegExpEnd = 3] = "ParamRegExpEnd", e[e.EscapeNext = 4] = "EscapeNext", e;
}(Ot || {});
const q_ = {
  type: el.Static,
  value: ""
}, X_ = /[a-zA-Z0-9_]/;
function J_(e) {
  if (!e) return [[]];
  if (e === "/") return [[q_]];
  if (!e.startsWith("/")) throw new Error(st.NODE_ENV !== "production" ? `Route paths should start with a "/": "${e}" should be "/${e}".` : `Invalid path "${e}"`);
  function t(v) {
    throw new Error(`ERR (${n})/"${d}": ${v}`);
  }
  let n = Ot.Static, a = n;
  const l = [];
  let i;
  function o() {
    i && l.push(i), i = [];
  }
  let r = 0, s, d = "", u = "";
  function c() {
    d && (n === Ot.Static ? i.push({
      type: el.Static,
      value: d
    }) : n === Ot.Param || n === Ot.ParamRegExp || n === Ot.ParamRegExpEnd ? (i.length > 1 && (s === "*" || s === "+") && t(`A repeatable param (${d}) must be alone in its segment. eg: '/:ids+.`), i.push({
      type: el.Param,
      value: d,
      regexp: u,
      repeatable: s === "*" || s === "+",
      optional: s === "*" || s === "?"
    })) : t("Invalid state to consume buffer"), d = "");
  }
  function f() {
    d += s;
  }
  for (; r < e.length; ) {
    if (s = e[r++], s === "\\" && n !== Ot.ParamRegExp) {
      a = n, n = Ot.EscapeNext;
      continue;
    }
    switch (n) {
      case Ot.Static:
        s === "/" ? (d && c(), o()) : s === ":" ? (c(), n = Ot.Param) : f();
        break;
      case Ot.EscapeNext:
        f(), n = a;
        break;
      case Ot.Param:
        s === "(" ? n = Ot.ParamRegExp : X_.test(s) ? f() : (c(), n = Ot.Static, s !== "*" && s !== "?" && s !== "+" && r--);
        break;
      case Ot.ParamRegExp:
        s === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + s : n = Ot.ParamRegExpEnd : u += s;
        break;
      case Ot.ParamRegExpEnd:
        c(), n = Ot.Static, s !== "*" && s !== "?" && s !== "+" && r--, u = "";
        break;
      default:
        t("Unknown state");
        break;
    }
  }
  return n === Ot.ParamRegExp && t(`Unfinished custom RegExp for param "${d}"`), c(), o(), l;
}
const Tf = "[^/]+?", Z_ = {
  sensitive: !1,
  strict: !1,
  start: !0,
  end: !0
};
var on = /* @__PURE__ */ function(e) {
  return e[e._multiplier = 10] = "_multiplier", e[e.Root = 90] = "Root", e[e.Segment = 40] = "Segment", e[e.SubSegment = 30] = "SubSegment", e[e.Static = 40] = "Static", e[e.Dynamic = 20] = "Dynamic", e[e.BonusCustomRegExp = 10] = "BonusCustomRegExp", e[e.BonusWildcard = -50] = "BonusWildcard", e[e.BonusRepeatable = -20] = "BonusRepeatable", e[e.BonusOptional = -8] = "BonusOptional", e[e.BonusStrict = 0.7000000000000001] = "BonusStrict", e[e.BonusCaseSensitive = 0.25] = "BonusCaseSensitive", e;
}(on || {});
const Q_ = /[.+*?^${}()[\]/\\]/g;
function ex(e, t) {
  const n = Ze({}, Z_, t), a = [];
  let l = n.start ? "^" : "";
  const i = [];
  for (const d of e) {
    const u = d.length ? [] : [on.Root];
    n.strict && !d.length && (l += "/");
    for (let c = 0; c < d.length; c++) {
      const f = d[c];
      let v = on.Segment + (n.sensitive ? on.BonusCaseSensitive : 0);
      if (f.type === el.Static)
        c || (l += "/"), l += f.value.replace(Q_, "\\$&"), v += on.Static;
      else if (f.type === el.Param) {
        const { value: m, repeatable: h, optional: g, regexp: p } = f;
        i.push({
          name: m,
          repeatable: h,
          optional: g
        });
        const y = p || Tf;
        if (y !== Tf) {
          v += on.BonusCustomRegExp;
          try {
            `${y}`;
          } catch (E) {
            throw new Error(`Invalid custom RegExp for param "${m}" (${y}): ` + E.message);
          }
        }
        let _ = h ? `((?:${y})(?:/(?:${y}))*)` : `(${y})`;
        c || (_ = g && d.length < 2 ? `(?:/${_})` : "/" + _), g && (_ += "?"), l += _, v += on.Dynamic, g && (v += on.BonusOptional), h && (v += on.BonusRepeatable), y === ".*" && (v += on.BonusWildcard);
      }
      u.push(v);
    }
    a.push(u);
  }
  if (n.strict && n.end) {
    const d = a.length - 1;
    a[d][a[d].length - 1] += on.BonusStrict;
  }
  n.strict || (l += "/?"), n.end ? l += "$" : n.strict && !l.endsWith("/") && (l += "(?:/|$)");
  const o = new RegExp(l, n.sensitive ? "" : "i");
  function r(d) {
    const u = d.match(o), c = {};
    if (!u) return null;
    for (let f = 1; f < u.length; f++) {
      const v = u[f] || "", m = i[f - 1];
      c[m.name] = v && m.repeatable ? v.split("/") : v;
    }
    return c;
  }
  function s(d) {
    let u = "", c = !1;
    for (const f of e) {
      (!c || !u.endsWith("/")) && (u += "/"), c = !1;
      for (const v of f) if (v.type === el.Static) u += v.value;
      else if (v.type === el.Param) {
        const { value: m, repeatable: h, optional: g } = v, p = m in d ? d[m] : "";
        if (xn(p) && !h) throw new Error(`Provided param "${m}" is an array but it is not repeatable (* or + modifiers)`);
        const y = xn(p) ? p.join("/") : p;
        if (!y) if (g)
          f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : c = !0);
        else throw new Error(`Missing required param "${m}"`);
        u += y;
      }
    }
    return u || "/";
  }
  return {
    re: o,
    score: a,
    keys: i,
    parse: r,
    stringify: s
  };
}
function tx(e, t) {
  let n = 0;
  for (; n < e.length && n < t.length; ) {
    const a = t[n] - e[n];
    if (a) return a;
    n++;
  }
  return e.length < t.length ? e.length === 1 && e[0] === on.Static + on.Segment ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === on.Static + on.Segment ? 1 : -1 : 0;
}
function ig(e, t) {
  let n = 0;
  const a = e.score, l = t.score;
  for (; n < a.length && n < l.length; ) {
    const i = tx(a[n], l[n]);
    if (i) return i;
    n++;
  }
  if (Math.abs(l.length - a.length) === 1) {
    if (Of(a)) return 1;
    if (Of(l)) return -1;
  }
  return l.length - a.length;
}
function Of(e) {
  const t = e[e.length - 1];
  return e.length > 0 && t[t.length - 1] < 0;
}
const nx = {
  strict: !1,
  end: !0,
  sensitive: !1
};
function ax(e, t, n) {
  const a = ex(J_(e.path), n);
  if (st.NODE_ENV !== "production") {
    const i = /* @__PURE__ */ new Set();
    for (const o of a.keys)
      i.has(o.name) && je(`Found duplicated params with name "${o.name}" for path "${e.path}". Only the last one will be available on "$route.params".`), i.add(o.name);
  }
  const l = Ze(a, {
    record: e,
    parent: t,
    children: [],
    alias: []
  });
  return t && !l.record.aliasOf == !t.record.aliasOf && t.children.push(l), l;
}
function lx(e, t) {
  const n = [], a = /* @__PURE__ */ new Map();
  t = Cf(nx, t);
  function l(c) {
    return a.get(c);
  }
  function i(c, f, v) {
    const m = !v, h = Bf(c);
    st.NODE_ENV !== "production" && sx(h, f), h.aliasOf = v && v.record;
    const g = Cf(t, c), p = [h];
    if ("alias" in c) {
      const E = typeof c.alias == "string" ? [c.alias] : c.alias;
      for (const k of E) p.push(Bf(Ze({}, h, {
        components: v ? v.record.components : h.components,
        path: k,
        aliasOf: v ? v.record : h
      })));
    }
    let y, _;
    for (const E of p) {
      const { path: k } = E;
      if (f && k[0] !== "/") {
        const P = f.record.path, A = P[P.length - 1] === "/" ? "" : "/";
        E.path = f.record.path + (k && A + k);
      }
      if (st.NODE_ENV !== "production" && E.path === "*") throw new Error(`Catch all routes ("*") must now be defined using a param with a custom regexp.
See more at https://router.vuejs.org/guide/migration/#Removed-star-or-catch-all-routes.`);
      if (y = ax(E, f, g), st.NODE_ENV !== "production" && f && k[0] === "/" && cx(y, f), v ? (v.alias.push(y), st.NODE_ENV !== "production" && rx(v, y)) : (_ = _ || y, _ !== y && _.alias.push(y), m && c.name && !Mf(y) && (st.NODE_ENV !== "production" && ux(c, f), o(c.name))), og(y) && s(y), h.children) {
        const P = h.children;
        for (let A = 0; A < P.length; A++) i(P[A], y, v && v.children[A]);
      }
      v = v || y;
    }
    return _ ? () => {
      o(_);
    } : Li;
  }
  function o(c) {
    if (qh(c)) {
      const f = a.get(c);
      f && (a.delete(c), n.splice(n.indexOf(f), 1), f.children.forEach(o), f.alias.forEach(o));
    } else {
      const f = n.indexOf(c);
      f > -1 && (n.splice(f, 1), c.record.name && a.delete(c.record.name), c.children.forEach(o), c.alias.forEach(o));
    }
  }
  function r() {
    return n;
  }
  function s(c) {
    const f = dx(c, n);
    n.splice(f, 0, c), c.record.name && !Mf(c) && a.set(c.record.name, c);
  }
  function d(c, f) {
    let v, m = {}, h, g;
    if ("name" in c && c.name) {
      if (v = a.get(c.name), !v) throw ti(wt.MATCHER_NOT_FOUND, { location: c });
      if (st.NODE_ENV !== "production") {
        const _ = Object.keys(c.params || {}).filter((E) => !v.keys.find((k) => k.name === E));
        _.length && je(`Discarded invalid param(s) "${_.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`);
      }
      g = v.record.name, m = Ze($f(f.params, v.keys.filter((_) => !_.optional).concat(v.parent ? v.parent.keys.filter((_) => _.optional) : []).map((_) => _.name)), c.params && $f(c.params, v.keys.map((_) => _.name))), h = v.stringify(m);
    } else if (c.path != null)
      h = c.path, st.NODE_ENV !== "production" && !h.startsWith("/") && je(`The Matcher cannot resolve relative paths but received "${h}". Unless you directly called \`matcher.resolve("${h}")\`, this is probably a bug in vue-router. Please open an issue at https://github.com/vuejs/router/issues/new/choose.`), v = n.find((_) => _.re.test(h)), v && (m = v.parse(h), g = v.record.name);
    else {
      if (v = f.name ? a.get(f.name) : n.find((_) => _.re.test(f.path)), !v) throw ti(wt.MATCHER_NOT_FOUND, {
        location: c,
        currentLocation: f
      });
      g = v.record.name, m = Ze({}, f.params, c.params), h = v.stringify(m);
    }
    const p = [];
    let y = v;
    for (; y; )
      p.unshift(y.record), y = y.parent;
    return {
      name: g,
      path: h,
      params: m,
      matched: p,
      meta: ox(p)
    };
  }
  e.forEach((c) => i(c));
  function u() {
    n.length = 0, a.clear();
  }
  return {
    addRoute: i,
    resolve: d,
    removeRoute: o,
    clearRoutes: u,
    getRoutes: r,
    getRecordMatcher: l
  };
}
function $f(e, t) {
  const n = {};
  for (const a of t) a in e && (n[a] = e[a]);
  return n;
}
function Bf(e) {
  const t = {
    path: e.path,
    redirect: e.redirect,
    name: e.name,
    meta: e.meta || {},
    aliasOf: e.aliasOf,
    beforeEnter: e.beforeEnter,
    props: ix(e),
    children: e.children || [],
    instances: {},
    leaveGuards: /* @__PURE__ */ new Set(),
    updateGuards: /* @__PURE__ */ new Set(),
    enterCallbacks: {},
    components: "components" in e ? e.components || null : e.component && { default: e.component }
  };
  return Object.defineProperty(t, "mods", { value: {} }), t;
}
function ix(e) {
  const t = {}, n = e.props || !1;
  if ("component" in e) t.default = n;
  else for (const a in e.components) t[a] = typeof n == "object" ? n[a] : n;
  return t;
}
function Mf(e) {
  for (; e; ) {
    if (e.record.aliasOf) return !0;
    e = e.parent;
  }
  return !1;
}
function ox(e) {
  return e.reduce((t, n) => Ze(t, n.meta), {});
}
function fu(e, t) {
  return e.name === t.name && e.optional === t.optional && e.repeatable === t.repeatable;
}
function rx(e, t) {
  for (const n of e.keys) if (!n.optional && !t.keys.find(fu.bind(null, n))) return je(`Alias "${t.record.path}" and the original record: "${e.record.path}" must have the exact same param named "${n.name}"`);
  for (const n of t.keys) if (!n.optional && !e.keys.find(fu.bind(null, n))) return je(`Alias "${t.record.path}" and the original record: "${e.record.path}" must have the exact same param named "${n.name}"`);
}
function sx(e, t) {
  t && t.record.name && !e.name && !e.path && je(`The route named "${String(t.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`);
}
function ux(e, t) {
  for (let n = t; n; n = n.parent) if (n.record.name === e.name) throw new Error(`A route named "${String(e.name)}" has been added as a ${t === n ? "child" : "descendant"} of a route with the same name. Route names must be unique and a nested route cannot use the same name as an ancestor.`);
}
function cx(e, t) {
  for (const n of t.keys) if (!e.keys.find(fu.bind(null, n))) return je(`Absolute path "${e.record.path}" must have the exact same param named "${n.name}" as its parent "${t.record.path}".`);
}
function dx(e, t) {
  let n = 0, a = t.length;
  for (; n !== a; ) {
    const i = n + a >> 1;
    ig(e, t[i]) < 0 ? a = i : n = i + 1;
  }
  const l = fx(e);
  return l && (a = t.lastIndexOf(l, a - 1), st.NODE_ENV !== "production" && a < 0 && je(`Finding ancestor route "${l.record.path}" failed for "${e.record.path}"`)), a;
}
function fx(e) {
  let t = e;
  for (; t = t.parent; ) if (og(t) && ig(e, t) === 0) return t;
}
function og({ record: e }) {
  return !!(e.name || e.components && Object.keys(e.components).length || e.redirect);
}
function Rf(e) {
  const t = Me(kc), n = Me(Xh);
  let a = !1, l = null;
  const i = x(() => {
    const u = bt(e.to);
    return st.NODE_ENV !== "production" && (!a || u !== l) && (mr(u) || (a ? je(`Invalid value for prop "to" in useLink()
- to:`, u, `
- previous to:`, l, `
- props:`, e) : je(`Invalid value for prop "to" in useLink()
- to:`, u, `
- props:`, e)), l = u, a = !0), t.resolve(u);
  }), o = x(() => {
    const { matched: u } = i.value, { length: c } = u, f = u[c - 1], v = n.matched;
    if (!f || !v.length) return -1;
    const m = v.findIndex(Ra.bind(null, f));
    if (m > -1) return m;
    const h = Lf(u[c - 2]);
    return c > 1 && Lf(f) === h && v[v.length - 1].path !== h ? v.findIndex(Ra.bind(null, u[c - 2])) : m;
  }), r = x(() => o.value > -1 && yx(n.params, i.value.params)), s = x(() => o.value > -1 && o.value === n.matched.length - 1 && Yh(n.params, i.value.params));
  function d(u = {}) {
    if (gx(u)) {
      const c = t[bt(e.replace) ? "replace" : "push"](bt(e.to)).catch(Li);
      return e.viewTransition && typeof document < "u" && "startViewTransition" in document && document.startViewTransition(() => c), c;
    }
    return Promise.resolve();
  }
  if (st.NODE_ENV !== "production" && ha) {
    const u = Ha();
    if (u) {
      const c = {
        route: i.value,
        isActive: r.value,
        isExactActive: s.value,
        error: null
      };
      u.__vrl_devtools = u.__vrl_devtools || [], u.__vrl_devtools.push(c), ut(() => {
        c.route = i.value, c.isActive = r.value, c.isExactActive = s.value, c.error = mr(bt(e.to)) ? null : 'Invalid "to" value';
      }, { flush: "post" });
    }
  }
  return {
    route: i,
    href: x(() => i.value.href),
    isActive: r,
    isExactActive: s,
    navigate: d
  };
}
function vx(e) {
  return e.length === 1 ? e[0] : e;
}
const mx = /* @__PURE__ */ fc({
  name: "RouterLink",
  compatConfig: { MODE: 3 },
  props: {
    to: {
      type: [String, Object],
      required: !0
    },
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {
      type: String,
      default: "page"
    },
    viewTransition: Boolean
  },
  useLink: Rf,
  setup(e, { slots: t }) {
    const n = It(Rf(e)), { options: a } = Me(kc), l = x(() => ({
      [Ff(e.activeClass, a.linkActiveClass, "router-link-active")]: n.isActive,
      [Ff(e.exactActiveClass, a.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
    }));
    return () => {
      const i = t.default && vx(t.default(n));
      return e.custom ? i : jn("a", {
        "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
        href: n.href,
        onClick: n.navigate,
        class: l.value
      }, i);
    };
  }
}), hx = mx;
function gx(e) {
  if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const t = e.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(t)) return;
    }
    return e.preventDefault && e.preventDefault(), !0;
  }
}
function yx(e, t) {
  for (const n in t) {
    const a = t[n], l = e[n];
    if (typeof a == "string") {
      if (a !== l) return !1;
    } else if (!xn(l) || l.length !== a.length || a.some((i, o) => i !== l[o])) return !1;
  }
  return !0;
}
function Lf(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : "";
}
const Ff = (e, t, n) => e ?? t ?? n, bx = /* @__PURE__ */ fc({
  name: "RouterView",
  inheritAttrs: !1,
  props: {
    name: {
      type: String,
      default: "default"
    },
    route: Object
  },
  compatConfig: { MODE: 3 },
  setup(e, { attrs: t, slots: n }) {
    st.NODE_ENV !== "production" && Sx();
    const a = Me(cu), l = x(() => e.route || a.value), i = Me(Df, 0), o = x(() => {
      let d = bt(i);
      const { matched: u } = l.value;
      let c;
      for (; (c = u[d]) && !c.components; ) d++;
      return d;
    }), r = x(() => l.value.matched[o.value]);
    at(Df, x(() => o.value + 1)), at(D_, r), at(cu, l);
    const s = Z();
    return me(() => [
      s.value,
      r.value,
      e.name
    ], ([d, u, c], [f, v, m]) => {
      u && (u.instances[c] = d, v && v !== u && d && d === f && (u.leaveGuards.size || (u.leaveGuards = v.leaveGuards), u.updateGuards.size || (u.updateGuards = v.updateGuards))), d && u && (!v || !Ra(u, v) || !f) && (u.enterCallbacks[c] || []).forEach((h) => h(d));
    }, { flush: "post" }), () => {
      const d = l.value, u = e.name, c = r.value, f = c && c.components[u];
      if (!f) return Hf(n.default, {
        Component: f,
        route: d
      });
      const v = c.props[u], m = v ? v === !0 ? d.params : typeof v == "function" ? v(d) : v : null, g = jn(f, Ze({}, m, t, {
        onVnodeUnmounted: (p) => {
          p.component.isUnmounted && (c.instances[u] = null);
        },
        ref: s
      }));
      if (st.NODE_ENV !== "production" && ha && g.ref) {
        const p = {
          depth: o.value,
          name: c.name,
          path: c.path,
          meta: c.meta
        };
        (xn(g.ref) ? g.ref.map((y) => y.i) : [g.ref.i]).forEach((y) => {
          y.__vrv_devtools = p;
        });
      }
      return Hf(n.default, {
        Component: g,
        route: d
      }) || g;
    };
  }
});
function Hf(e, t) {
  if (!e) return null;
  const n = e(t);
  return n.length === 1 ? n[0] : n;
}
const px = bx;
function Sx() {
  const e = Ha(), t = e.parent && e.parent.type.name, n = e.parent && e.parent.subTree && e.parent.subTree.type;
  if (t && (t === "KeepAlive" || t.includes("Transition")) && typeof n == "object" && n.name === "RouterView") {
    const a = t === "KeepAlive" ? "keep-alive" : "transition";
    je(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${a}>
    <component :is="Component" />
  </${a}>
</router-view>`);
  }
}
function wx(e) {
  const t = lx(e.routes, e), n = e.parseQuery || I_, a = e.stringifyQuery || Nf, l = e.history;
  if (st.NODE_ENV !== "production" && !l) throw new Error('Provide the "history" option when calling "createRouter()": https://router.vuejs.org/api/interfaces/RouterOptions.html#history');
  const i = Ei(), o = Ei(), r = Ei(), s = fe(Na);
  let d = Na;
  ha && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
  const u = ks.bind(null, (B) => "" + B), c = ks.bind(null, v_), f = ks.bind(null, ei);
  function v(B, G) {
    let ie, de;
    return qh(B) ? (ie = t.getRecordMatcher(B), st.NODE_ENV !== "production" && !ie && je(`Parent route "${String(B)}" not found when adding child route`, G), de = G) : de = B, t.addRoute(de, ie);
  }
  function m(B) {
    const G = t.getRecordMatcher(B);
    G ? t.removeRoute(G) : st.NODE_ENV !== "production" && je(`Cannot remove non-existent route "${String(B)}"`);
  }
  function h() {
    return t.getRoutes().map((B) => B.record);
  }
  function g(B) {
    return !!t.getRecordMatcher(B);
  }
  function p(B, G) {
    if (G = Ze({}, G || s.value), typeof B == "string") {
      const O = Cs(n, B, G.path), $ = t.resolve({ path: O.path }, G), K = l.createHref(O.fullPath);
      return st.NODE_ENV !== "production" && (K.startsWith("//") ? je(`Location "${B}" resolved to "${K}". A resolved location cannot start with multiple slashes.`) : $.matched.length || je(`No match found for location with path "${B}"`)), Ze(O, $, {
        params: f($.params),
        hash: ei(O.hash),
        redirectedFrom: void 0,
        href: K
      });
    }
    if (st.NODE_ENV !== "production" && !mr(B))
      return je(`router.resolve() was passed an invalid location. This will fail in production.
- Location:`, B), p({});
    let ie;
    if (B.path != null)
      st.NODE_ENV !== "production" && "params" in B && !("name" in B) && Object.keys(B.params).length && je(`Path "${B.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`), ie = Ze({}, B, { path: Cs(n, B.path, G.path).path });
    else {
      const O = Ze({}, B.params);
      for (const $ in O) O[$] == null && delete O[$];
      ie = Ze({}, B, { params: c(O) }), G.params = c(G.params);
    }
    const de = t.resolve(ie, G), Se = B.hash || "";
    st.NODE_ENV !== "production" && Se && !Se.startsWith("#") && je(`A \`hash\` should always start with the character "#". Replace "${Se}" with "#${Se}".`), de.params = u(f(de.params));
    const Ce = g_(a, Ze({}, B, {
      hash: c_(Se),
      path: de.path
    })), C = l.createHref(Ce);
    return st.NODE_ENV !== "production" && (C.startsWith("//") ? je(`Location "${B}" resolved to "${C}". A resolved location cannot start with multiple slashes.`) : de.matched.length || je(`No match found for location with path "${B.path != null ? B.path : B}"`)), Ze({
      fullPath: Ce,
      hash: Se,
      query: a === Nf ? N_(B.query) : B.query || {}
    }, de, {
      redirectedFrom: void 0,
      href: C
    });
  }
  function y(B) {
    return typeof B == "string" ? Cs(n, B, s.value.path) : Ze({}, B);
  }
  function _(B, G) {
    if (d !== B) return ti(wt.NAVIGATION_CANCELLED, {
      from: G,
      to: B
    });
  }
  function E(B) {
    return A(B);
  }
  function k(B) {
    return E(Ze(y(B), { replace: !0 }));
  }
  function P(B, G) {
    const ie = B.matched[B.matched.length - 1];
    if (ie && ie.redirect) {
      const { redirect: de } = ie;
      let Se = typeof de == "function" ? de(B, G) : de;
      if (typeof Se == "string" && (Se = Se.includes("?") || Se.includes("#") ? Se = y(Se) : { path: Se }, Se.params = {}), st.NODE_ENV !== "production" && Se.path == null && !("name" in Se))
        throw je(`Invalid redirect found:
${JSON.stringify(Se, null, 2)}
 when navigating to "${B.fullPath}". A redirect must contain a name or path. This will break in production.`), new Error("Invalid redirect");
      return Ze({
        query: B.query,
        hash: B.hash,
        params: Se.path != null ? {} : B.params
      }, Se);
    }
  }
  function A(B, G) {
    const ie = d = p(B), de = s.value, Se = B.state, Ce = B.force, C = B.replace === !0, O = P(ie, de);
    if (O) return A(Ze(y(O), {
      state: typeof O == "object" ? Ze({}, Se, O.state) : Se,
      force: Ce,
      replace: C
    }), G || ie);
    const $ = ie;
    $.redirectedFrom = G;
    let K;
    return !Ce && Ef(a, de, ie) && (K = ti(wt.NAVIGATION_DUPLICATED, {
      to: $,
      from: de
    }), j(de, de, !0, !1)), (K ? Promise.resolve(K) : V($, de)).catch((X) => ca(X) ? ca(X, wt.NAVIGATION_GUARD_REDIRECT) ? X : H(X) : Y(X, $, de)).then((X) => {
      if (X) {
        if (ca(X, wt.NAVIGATION_GUARD_REDIRECT))
          return st.NODE_ENV !== "production" && Ef(a, p(X.to), $) && G && (G._count = G._count ? G._count + 1 : 1) > 30 ? (je(`Detected a possibly infinite redirection in a navigation guard when going from "${de.fullPath}" to "${$.fullPath}". Aborting to avoid a Stack Overflow.
 Are you always returning a new location within a navigation guard? That would lead to this error. Only return when redirecting or aborting, that should fix this. This might break in production if not fixed.`), Promise.reject(/* @__PURE__ */ new Error("Infinite redirect in navigation guard"))) : A(Ze({ replace: C }, y(X.to), {
            state: typeof X.to == "object" ? Ze({}, Se, X.to.state) : Se,
            force: Ce
          }), G || $);
      } else X = w($, de, !0, C, Se);
      return I($, de, X), X;
    });
  }
  function D(B, G) {
    const ie = _(B, G);
    return ie ? Promise.reject(ie) : Promise.resolve();
  }
  function N(B) {
    const G = oe.values().next().value;
    return G && typeof G.runWithContext == "function" ? G.runWithContext(B) : B();
  }
  function V(B, G) {
    let ie;
    const [de, Se, Ce] = T_(B, G);
    ie = Es(de.reverse(), "beforeRouteLeave", B, G);
    for (const O of de) O.leaveGuards.forEach(($) => {
      ie.push(Oa($, B, G));
    });
    const C = D.bind(null, B, G);
    return ie.push(C), _e(ie).then(() => {
      ie = [];
      for (const O of i.list()) ie.push(Oa(O, B, G));
      return ie.push(C), _e(ie);
    }).then(() => {
      ie = Es(Se, "beforeRouteUpdate", B, G);
      for (const O of Se) O.updateGuards.forEach(($) => {
        ie.push(Oa($, B, G));
      });
      return ie.push(C), _e(ie);
    }).then(() => {
      ie = [];
      for (const O of Ce) if (O.beforeEnter) if (xn(O.beforeEnter)) for (const $ of O.beforeEnter) ie.push(Oa($, B, G));
      else ie.push(Oa(O.beforeEnter, B, G));
      return ie.push(C), _e(ie);
    }).then(() => (B.matched.forEach((O) => O.enterCallbacks = {}), ie = Es(Ce, "beforeRouteEnter", B, G, N), ie.push(C), _e(ie))).then(() => {
      ie = [];
      for (const O of o.list()) ie.push(Oa(O, B, G));
      return ie.push(C), _e(ie);
    }).catch((O) => ca(O, wt.NAVIGATION_CANCELLED) ? O : Promise.reject(O));
  }
  function I(B, G, ie) {
    r.list().forEach((de) => N(() => de(B, G, ie)));
  }
  function w(B, G, ie, de, Se) {
    const Ce = _(B, G);
    if (Ce) return Ce;
    const C = G === Na, O = ha ? history.state : {};
    ie && (de || C ? l.replace(B.fullPath, Ze({ scroll: C && O && O.scroll }, Se)) : l.push(B.fullPath, Se)), s.value = B, j(B, G, ie, C), H();
  }
  let T;
  function M() {
    T || (T = l.listen((B, G, ie) => {
      if (!ve.listening) return;
      const de = p(B), Se = P(de, ve.currentRoute.value);
      if (Se) {
        A(Ze(Se, {
          replace: !0,
          force: !0
        }), de).catch(Li);
        return;
      }
      d = de;
      const Ce = s.value;
      ha && k_(If(Ce.fullPath, ie.delta), Lr()), V(de, Ce).catch((C) => ca(C, wt.NAVIGATION_ABORTED | wt.NAVIGATION_CANCELLED) ? C : ca(C, wt.NAVIGATION_GUARD_REDIRECT) ? (A(Ze(y(C.to), { force: !0 }), de).then((O) => {
        ca(O, wt.NAVIGATION_ABORTED | wt.NAVIGATION_DUPLICATED) && !ie.delta && ie.type === ru.pop && l.go(-1, !1);
      }).catch(Li), Promise.reject()) : (ie.delta && l.go(-ie.delta, !1), Y(C, de, Ce))).then((C) => {
        C = C || w(de, Ce, !1), C && (ie.delta && !ca(C, wt.NAVIGATION_CANCELLED) ? l.go(-ie.delta, !1) : ie.type === ru.pop && ca(C, wt.NAVIGATION_ABORTED | wt.NAVIGATION_DUPLICATED) && l.go(-1, !1)), I(de, Ce, C);
      }).catch(Li);
    }));
  }
  let W = Ei(), J = Ei(), ee;
  function Y(B, G, ie) {
    H(B);
    const de = J.list();
    return de.length ? de.forEach((Se) => Se(B, G, ie)) : (st.NODE_ENV !== "production" && je("uncaught error during route navigation:"), console.error(B)), Promise.reject(B);
  }
  function L() {
    return ee && s.value !== Na ? Promise.resolve() : new Promise((B, G) => {
      W.add([B, G]);
    });
  }
  function H(B) {
    return ee || (ee = !B, M(), W.list().forEach(([G, ie]) => B ? ie(B) : G()), W.reset()), B;
  }
  function j(B, G, ie, de) {
    const { scrollBehavior: Se } = e;
    if (!ha || !Se) return Promise.resolve();
    const Ce = !ie && C_(If(B.fullPath, 0)) || (de || !ie) && history.state && history.state.scroll || null;
    return He().then(() => Se(B, G, Ce)).then((C) => C && x_(C)).catch((C) => Y(C, B, G));
  }
  const U = (B) => l.go(B);
  let F;
  const oe = /* @__PURE__ */ new Set(), ve = {
    currentRoute: s,
    listening: !0,
    addRoute: v,
    removeRoute: m,
    clearRoutes: t.clearRoutes,
    hasRoute: g,
    getRoutes: h,
    resolve: p,
    options: e,
    push: E,
    replace: k,
    go: U,
    back: () => U(-1),
    forward: () => U(1),
    beforeEach: i.add,
    beforeResolve: o.add,
    afterEach: r.add,
    onError: J.add,
    isReady: L,
    install(B) {
      B.component("RouterLink", hx), B.component("RouterView", px), B.config.globalProperties.$router = ve, Object.defineProperty(B.config.globalProperties, "$route", {
        enumerable: !0,
        get: () => bt(s)
      }), ha && !F && s.value === Na && (F = !0, E(l.location).catch((de) => {
        st.NODE_ENV !== "production" && je("Unexpected error when starting the router:", de);
      }));
      const G = {};
      for (const de in Na) Object.defineProperty(G, de, {
        get: () => s.value[de],
        enumerable: !0
      });
      B.provide(kc, ve), B.provide(Xh, Vm(G)), B.provide(cu, s);
      const ie = B.unmount;
      oe.add(B), B.unmount = function() {
        oe.delete(B), oe.size < 1 && (d = Na, T && T(), T = null, s.value = Na, F = !1, ee = !1), ie();
      }, st.NODE_ENV !== "production" && ha && $_(B, ve, t);
    }
  };
  function _e(B) {
    return B.reduce((G, ie) => G.then(() => N(ie)), Promise.resolve());
  }
  return ve;
}
function Gt(e, t) {
  let n;
  function a() {
    n = Jl(), n.run(() => t.length ? t(() => {
      n == null || n.stop(), a();
    }) : t());
  }
  me(e, (l) => {
    l && !n ? a() : l || (n == null || n.stop(), n = void 0);
  }, {
    immediate: !0
  }), Dt(() => {
    n == null || n.stop();
  });
}
const qe = typeof window < "u", Cc = qe && "IntersectionObserver" in window, _x = qe && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0), zf = qe && "EyeDropper" in window, Vc = qe && "matchMedia" in window && typeof window.matchMedia == "function", aa = () => Vc && window.matchMedia("(prefers-reduced-motion: reduce)").matches;
function jf(e, t, n) {
  xx(e, t), t.set(e, n);
}
function xx(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function Wf(e, t, n) {
  return e.set(rg(e, t), n), n;
}
function da(e, t) {
  return e.get(rg(e, t));
}
function rg(e, t, n) {
  if (typeof e == "function" ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function sg(e, t, n) {
  const a = t.length - 1;
  if (a < 0) return e === void 0 ? n : e;
  for (let l = 0; l < a; l++) {
    if (e == null)
      return n;
    e = e[t[l]];
  }
  return e == null || e[t[a]] === void 0 ? n : e[t[a]];
}
function Mt(e, t) {
  if (e === t) return !0;
  if (e instanceof Date && t instanceof Date && e.getTime() !== t.getTime() || e !== Object(e) || t !== Object(t))
    return !1;
  const n = Object.keys(e);
  return n.length !== Object.keys(t).length ? !1 : n.every((a) => Mt(e[a], t[a]));
}
function gl(e, t, n) {
  return e == null || !t || typeof t != "string" ? n : e[t] !== void 0 ? e[t] : (t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, ""), sg(e, t.split("."), n));
}
function xt(e, t, n) {
  if (t === !0) return e === void 0 ? n : e;
  if (t == null || typeof t == "boolean") return n;
  if (e !== Object(e)) {
    if (typeof t != "function") return n;
    const l = t(e, n);
    return typeof l > "u" ? n : l;
  }
  if (typeof t == "string") return gl(e, t, n);
  if (Array.isArray(t)) return sg(e, t, n);
  if (typeof t != "function") return n;
  const a = t(e, n);
  return typeof a > "u" ? n : a;
}
function bn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length: e
  }, (n, a) => t + a);
}
function pe(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (e == null || e === "")
    return;
  const n = Number(e);
  return isNaN(n) ? String(e) : isFinite(n) ? `${n}${t}` : void 0;
}
function Ki(e) {
  return e !== null && typeof e == "object" && !Array.isArray(e);
}
function Uf(e) {
  let t;
  return e !== null && typeof e == "object" && ((t = Object.getPrototypeOf(e)) === Object.prototype || t === null);
}
function Ec(e) {
  if (e && "$el" in e) {
    const t = e.$el;
    return (t == null ? void 0 : t.nodeType) === Node.TEXT_NODE ? t.nextElementSibling : t;
  }
  return e;
}
const vu = Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function ug(e) {
  return Object.keys(e);
}
function tl(e, t) {
  return t.every((n) => e.hasOwnProperty(n));
}
function mn(e, t) {
  const n = {};
  for (const a of t)
    Object.prototype.hasOwnProperty.call(e, a) && (n[a] = e[a]);
  return n;
}
function mu(e, t, n) {
  const a = /* @__PURE__ */ Object.create(null), l = /* @__PURE__ */ Object.create(null);
  for (const i in e)
    t.some((o) => o instanceof RegExp ? o.test(i) : o === i) ? a[i] = e[i] : l[i] = e[i];
  return [a, l];
}
function tt(e, t) {
  const n = {
    ...e
  };
  return t.forEach((a) => delete n[a]), n;
}
const cg = /^on[^a-z]/, Pc = (e) => cg.test(e), kx = ["onAfterscriptexecute", "onAnimationcancel", "onAnimationend", "onAnimationiteration", "onAnimationstart", "onAuxclick", "onBeforeinput", "onBeforescriptexecute", "onChange", "onClick", "onCompositionend", "onCompositionstart", "onCompositionupdate", "onContextmenu", "onCopy", "onCut", "onDblclick", "onFocusin", "onFocusout", "onFullscreenchange", "onFullscreenerror", "onGesturechange", "onGestureend", "onGesturestart", "onGotpointercapture", "onInput", "onKeydown", "onKeypress", "onKeyup", "onLostpointercapture", "onMousedown", "onMousemove", "onMouseout", "onMouseover", "onMouseup", "onMousewheel", "onPaste", "onPointercancel", "onPointerdown", "onPointerenter", "onPointerleave", "onPointermove", "onPointerout", "onPointerover", "onPointerup", "onReset", "onSelect", "onSubmit", "onTouchcancel", "onTouchend", "onTouchmove", "onTouchstart", "onTransitioncancel", "onTransitionend", "onTransitionrun", "onTransitionstart", "onWheel"], Cx = ["ArrowUp", "ArrowDown", "ArrowRight", "ArrowLeft", "Enter", "Escape", "Tab", " "];
function Vx(e) {
  return e.isComposing && Cx.includes(e.key);
}
function za(e) {
  const [t, n] = mu(e, [cg]), a = tt(t, kx), [l, i] = mu(n, ["class", "style", "id", /^data-/]);
  return Object.assign(l, t), Object.assign(i, a), [l, i];
}
function ht(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function dg(e, t) {
  let n = 0;
  const a = function() {
    for (var l = arguments.length, i = new Array(l), o = 0; o < l; o++)
      i[o] = arguments[o];
    clearTimeout(n), n = setTimeout(() => e(...i), bt(t));
  };
  return a.clear = () => {
    clearTimeout(n);
  }, a.immediate = e, a;
}
function ot(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(t, Math.min(n, e));
}
function Gf(e) {
  const t = e.toString().trim();
  return t.includes(".") ? t.length - t.indexOf(".") - 1 : 0;
}
function Kf(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0";
  return e + n.repeat(Math.max(0, t - e.length));
}
function Yf(e, t) {
  return (arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0").repeat(Math.max(0, t - e.length)) + e;
}
function Ex(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const n = [];
  let a = 0;
  for (; a < e.length; )
    n.push(e.substr(a, t)), a += t;
  return n;
}
function qf(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
  if (e < t)
    return `${e} B`;
  const n = t === 1024 ? ["Ki", "Mi", "Gi"] : ["k", "M", "G"];
  let a = -1;
  for (; Math.abs(e) >= t && a < n.length - 1; )
    e /= t, ++a;
  return `${e.toFixed(1)} ${n[a]}B`;
}
function Jt() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  const a = {};
  for (const l in e)
    a[l] = e[l];
  for (const l in t) {
    const i = e[l], o = t[l];
    if (Uf(i) && Uf(o)) {
      a[l] = Jt(i, o, n);
      continue;
    }
    if (n && Array.isArray(i) && Array.isArray(o)) {
      a[l] = n(i, o);
      continue;
    }
    a[l] = o;
  }
  return a;
}
function fg(e) {
  return e.map((t) => t.type === ye ? fg(t.children) : t).flat();
}
function ul() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (ul.cache.has(e)) return ul.cache.get(e);
  const t = e.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  return ul.cache.set(e, t), t;
}
ul.cache = /* @__PURE__ */ new Map();
function Ul(e, t) {
  if (!t || typeof t != "object") return [];
  if (Array.isArray(t))
    return t.map((n) => Ul(e, n)).flat(1);
  if (t.suspense)
    return Ul(e, t.ssContent);
  if (Array.isArray(t.children))
    return t.children.map((n) => Ul(e, n)).flat(1);
  if (t.component) {
    if (Object.getOwnPropertySymbols(t.component.provides).includes(e))
      return [t.component];
    if (t.component.subTree)
      return Ul(e, t.component.subTree).flat(1);
  }
  return [];
}
var Rl = /* @__PURE__ */ new WeakMap(), qa = /* @__PURE__ */ new WeakMap();
class vg {
  constructor(t) {
    jf(this, Rl, []), jf(this, qa, 0), this.size = t;
  }
  get isFull() {
    return da(Rl, this).length === this.size;
  }
  push(t) {
    da(Rl, this)[da(qa, this)] = t, Wf(qa, this, (da(qa, this) + 1) % this.size);
  }
  values() {
    return da(Rl, this).slice(da(qa, this)).concat(da(Rl, this).slice(0, da(qa, this)));
  }
  clear() {
    da(Rl, this).length = 0, Wf(qa, this, 0);
  }
}
function Px(e) {
  return "touches" in e ? {
    clientX: e.touches[0].clientX,
    clientY: e.touches[0].clientY
  } : {
    clientX: e.clientX,
    clientY: e.clientY
  };
}
function Ic(e) {
  const t = It({});
  ut(() => {
    const a = e();
    for (const l in a)
      t[l] = a[l];
  }, {
    flush: "sync"
  });
  const n = {};
  for (const a in t)
    n[a] = R(() => t[a]);
  return n;
}
function hr(e, t) {
  return e.includes(t);
}
function mg(e) {
  return e[2].toLowerCase() + e.slice(3);
}
const zt = () => [Function, Array];
function Xf(e, t) {
  return t = "on" + wn(t), !!(e[t] || e[`${t}Once`] || e[`${t}Capture`] || e[`${t}OnceCapture`] || e[`${t}CaptureOnce`]);
}
function bo(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    n[a - 1] = arguments[a];
  if (Array.isArray(e))
    for (const l of e)
      l(...n);
  else typeof e == "function" && e(...n);
}
function Yi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = ["button", "[href]", 'input:not([type="hidden"])', "select", "textarea", "[tabindex]"].map((a) => `${a}${t ? ':not([tabindex="-1"])' : ""}:not([disabled])`).join(", ");
  return [...e.querySelectorAll(n)];
}
function hg(e, t, n) {
  let a, l = e.indexOf(document.activeElement);
  const i = t === "next" ? 1 : -1;
  do
    l += i, a = e[l];
  while ((!a || a.offsetParent == null || !((n == null ? void 0 : n(a)) ?? !0)) && l < e.length && l >= 0);
  return a;
}
function cl(e, t) {
  var a, l, i, o;
  const n = Yi(e);
  if (t == null)
    (e === document.activeElement || !e.contains(document.activeElement)) && ((a = n[0]) == null || a.focus());
  else if (t === "first")
    (l = n[0]) == null || l.focus();
  else if (t === "last")
    (i = n.at(-1)) == null || i.focus();
  else if (typeof t == "number")
    (o = n[t]) == null || o.focus();
  else {
    const r = hg(n, t);
    r ? r.focus() : cl(e, t === "next" ? "first" : "last");
  }
}
function Mo(e) {
  return e == null || typeof e == "string" && e.trim() === "";
}
function gg() {
}
function ni(e, t) {
  if (!(qe && typeof CSS < "u" && typeof CSS.supports < "u" && CSS.supports(`selector(${t})`))) return null;
  try {
    return !!e && e.matches(t);
  } catch {
    return null;
  }
}
function Fr(e) {
  return e.some((t) => Ba(t) ? t.type === _t ? !1 : t.type !== ye || Fr(t.children) : !0) ? e : null;
}
function Ro(e, t, n) {
  return (e == null ? void 0 : e(t)) ?? (n == null ? void 0 : n(t));
}
function Ix(e, t) {
  if (!qe || e === 0)
    return t(), () => {
    };
  const n = window.setTimeout(t, e);
  return () => window.clearTimeout(n);
}
function Nx(e, t) {
  const n = e.clientX, a = e.clientY, l = t.getBoundingClientRect(), i = l.left, o = l.top, r = l.right, s = l.bottom;
  return n >= i && n <= r && a >= o && a <= s;
}
function gr() {
  const e = fe(), t = (n) => {
    e.value = n;
  };
  return Object.defineProperty(t, "value", {
    enumerable: !0,
    get: () => e.value,
    set: (n) => e.value = n
  }), Object.defineProperty(t, "el", {
    enumerable: !0,
    get: () => Ec(e.value)
  }), t;
}
function ai(e) {
  const t = e.key.length === 1, n = !e.ctrlKey && !e.metaKey && !e.altKey;
  return t && n;
}
function hu(e) {
  return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "bigint";
}
function yr(e) {
  return "\\^$*+?.()|{}[]".includes(e) ? `\\${e}` : e;
}
function Dx(e, t, n) {
  const a = new RegExp(`[\\d\\-${yr(n)}]`), l = e.split("").filter((o) => a.test(o)).filter((o, r, s) => r === 0 && /[-]/.test(o) || // sign allowed at the start
  o === n && r === s.indexOf(o) || // decimal separator allowed only once
  /\d/.test(o)).join("");
  if (t === 0)
    return l.split(n)[0];
  const i = new RegExp(`${yr(n)}\\d`);
  if (t !== null && i.test(l)) {
    const o = l.split(n);
    return [o[0], o[1].substring(0, t)].join(n);
  }
  return l;
}
function Ax(e) {
  const t = {};
  for (const n in e)
    t[Ht(n)] = e[n];
  return t;
}
function Tx(e) {
  const t = ["checked", "disabled"];
  return Object.fromEntries(Object.entries(e).filter((n) => {
    let [a, l] = n;
    return t.includes(a) ? !!l : l !== void 0;
  }));
}
const yg = ["top", "bottom"], Ox = ["start", "end", "left", "right"];
function gu(e, t) {
  let [n, a] = e.split(" ");
  return a || (a = hr(yg, n) ? "start" : hr(Ox, n) ? "top" : "center"), {
    side: yu(n, t),
    align: yu(a, t)
  };
}
function yu(e, t) {
  return e === "start" ? t ? "right" : "left" : e === "end" ? t ? "left" : "right" : e;
}
function Ps(e) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.side],
    align: e.align
  };
}
function Is(e) {
  return {
    side: e.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[e.align]
  };
}
function Jf(e) {
  return {
    side: e.align,
    align: e.side
  };
}
function Zf(e) {
  return hr(yg, e.side) ? "y" : "x";
}
class ta {
  constructor(t) {
    let {
      x: n,
      y: a,
      width: l,
      height: i
    } = t;
    this.x = n, this.y = a, this.width = l, this.height = i;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function Qf(e, t) {
  return {
    x: {
      before: Math.max(0, t.left - e.left),
      after: Math.max(0, e.right - t.right)
    },
    y: {
      before: Math.max(0, t.top - e.top),
      after: Math.max(0, e.bottom - t.bottom)
    }
  };
}
function bg(e) {
  return Array.isArray(e) ? new ta({
    x: e[0],
    y: e[1],
    width: 0,
    height: 0
  }) : e.getBoundingClientRect();
}
function $x(e) {
  if (e === document.documentElement)
    return visualViewport ? new ta({
      x: visualViewport.scale > 1 ? 0 : visualViewport.offsetLeft,
      y: visualViewport.scale > 1 ? 0 : visualViewport.offsetTop,
      width: visualViewport.width * visualViewport.scale,
      height: visualViewport.height * visualViewport.scale
    }) : new ta({
      x: 0,
      y: 0,
      width: document.documentElement.clientWidth,
      height: document.documentElement.clientHeight
    });
  {
    const t = e.getBoundingClientRect();
    return new ta({
      x: t.x,
      y: t.y,
      width: e.clientWidth,
      height: e.clientHeight
    });
  }
}
function Nc(e) {
  const t = e.getBoundingClientRect(), n = getComputedStyle(e), a = n.transform;
  if (a) {
    let l, i, o, r, s;
    if (a.startsWith("matrix3d("))
      l = a.slice(9, -1).split(/, /), i = Number(l[0]), o = Number(l[5]), r = Number(l[12]), s = Number(l[13]);
    else if (a.startsWith("matrix("))
      l = a.slice(7, -1).split(/, /), i = Number(l[0]), o = Number(l[3]), r = Number(l[4]), s = Number(l[5]);
    else
      return new ta(t);
    const d = n.transformOrigin, u = t.x - r - (1 - i) * parseFloat(d), c = t.y - s - (1 - o) * parseFloat(d.slice(d.indexOf(" ") + 1)), f = i ? t.width / i : e.offsetWidth + 1, v = o ? t.height / o : e.offsetHeight + 1;
    return new ta({
      x: u,
      y: c,
      width: f,
      height: v
    });
  } else
    return new ta(t);
}
function ga(e, t, n) {
  if (typeof e.animate > "u") return {
    finished: Promise.resolve()
  };
  let a;
  try {
    a = e.animate(t, n);
  } catch {
    return {
      finished: Promise.resolve()
    };
  }
  return typeof a.finished > "u" && (a.finished = new Promise((l) => {
    a.onfinish = () => {
      l(a);
    };
  })), a;
}
const Xo = /* @__PURE__ */ new WeakMap();
function Bx(e, t) {
  Object.keys(t).forEach((n) => {
    if (Pc(n)) {
      const a = mg(n), l = Xo.get(e);
      if (t[n] == null)
        l == null || l.forEach((i) => {
          const [o, r] = i;
          o === a && (e.removeEventListener(a, r), l.delete(i));
        });
      else if (!l || ![...l].some((i) => i[0] === a && i[1] === t[n])) {
        e.addEventListener(a, t[n]);
        const i = l || /* @__PURE__ */ new Set();
        i.add([a, t[n]]), Xo.has(e) || Xo.set(e, i);
      }
    } else
      t[n] == null ? e.removeAttribute(n) : e.setAttribute(n, t[n]);
  });
}
function Mx(e, t) {
  Object.keys(t).forEach((n) => {
    if (Pc(n)) {
      const a = mg(n), l = Xo.get(e);
      l == null || l.forEach((i) => {
        const [o, r] = i;
        o === a && (e.removeEventListener(a, r), l.delete(i));
      });
    } else
      e.removeAttribute(n);
  });
}
const Ll = 2.4, ev = 0.2126729, tv = 0.7151522, nv = 0.072175, Rx = 0.55, Lx = 0.58, Fx = 0.57, Hx = 0.62, Lo = 0.03, av = 1.45, zx = 5e-4, jx = 1.25, Wx = 1.25, lv = 0.078, iv = 12.82051282051282, Fo = 0.06, ov = 1e-3;
function rv(e, t) {
  const n = (e.r / 255) ** Ll, a = (e.g / 255) ** Ll, l = (e.b / 255) ** Ll, i = (t.r / 255) ** Ll, o = (t.g / 255) ** Ll, r = (t.b / 255) ** Ll;
  let s = n * ev + a * tv + l * nv, d = i * ev + o * tv + r * nv;
  if (s <= Lo && (s += (Lo - s) ** av), d <= Lo && (d += (Lo - d) ** av), Math.abs(d - s) < zx) return 0;
  let u;
  if (d > s) {
    const c = (d ** Rx - s ** Lx) * jx;
    u = c < ov ? 0 : c < lv ? c - c * iv * Fo : c - Fo;
  } else {
    const c = (d ** Hx - s ** Fx) * Wx;
    u = c > -ov ? 0 : c > -lv ? c - c * iv * Fo : c + Fo;
  }
  return u * 100;
}
function vn(e) {
  fn(`Vuetify: ${e}`);
}
function li(e) {
  fn(`Vuetify error: ${e}`);
}
function pg(e, t) {
  t = Array.isArray(t) ? t.slice(0, -1).map((n) => `'${n}'`).join(", ") + ` or '${t.at(-1)}'` : `'${t}'`, fn(`[Vuetify UPGRADE] '${e}' is deprecated, use ${t} instead.`);
}
const br = 0.20689655172413793, Ux = (e) => e > br ** 3 ? Math.cbrt(e) : e / (3 * br ** 2) + 4 / 29, Gx = (e) => e > br ? e ** 3 : 3 * br ** 2 * (e - 4 / 29);
function Sg(e) {
  const t = Ux, n = t(e[1]);
  return [116 * n - 16, 500 * (t(e[0] / 0.95047) - n), 200 * (n - t(e[2] / 1.08883))];
}
function wg(e) {
  const t = Gx, n = (e[0] + 16) / 116;
  return [t(n + e[1] / 500) * 0.95047, t(n), t(n - e[2] / 200) * 1.08883];
}
const Kx = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]], Yx = (e) => e <= 31308e-7 ? e * 12.92 : 1.055 * e ** (1 / 2.4) - 0.055, qx = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]], Xx = (e) => e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
function _g(e) {
  const t = Array(3), n = Yx, a = Kx;
  for (let l = 0; l < 3; ++l)
    t[l] = Math.round(ot(n(a[l][0] * e[0] + a[l][1] * e[1] + a[l][2] * e[2])) * 255);
  return {
    r: t[0],
    g: t[1],
    b: t[2]
  };
}
function Dc(e) {
  let {
    r: t,
    g: n,
    b: a
  } = e;
  const l = [0, 0, 0], i = Xx, o = qx;
  t = i(t / 255), n = i(n / 255), a = i(a / 255);
  for (let r = 0; r < 3; ++r)
    l[r] = o[r][0] * t + o[r][1] * n + o[r][2] * a;
  return l;
}
function bu(e) {
  return !!e && /^(#|var\(--|(rgb|hsl)a?\()/.test(e);
}
function Jx(e) {
  return bu(e) && !/^((rgb|hsl)a?\()?var\(--/.test(e);
}
const sv = /^(?<fn>(?:rgb|hsl)a?)\((?<values>.+)\)/, Zx = {
  rgb: (e, t, n, a) => ({
    r: e,
    g: t,
    b: n,
    a
  }),
  rgba: (e, t, n, a) => ({
    r: e,
    g: t,
    b: n,
    a
  }),
  hsl: (e, t, n, a) => uv({
    h: e,
    s: t,
    l: n,
    a
  }),
  hsla: (e, t, n, a) => uv({
    h: e,
    s: t,
    l: n,
    a
  }),
  hsv: (e, t, n, a) => la({
    h: e,
    s: t,
    v: n,
    a
  }),
  hsva: (e, t, n, a) => la({
    h: e,
    s: t,
    v: n,
    a
  })
};
function pn(e) {
  if (typeof e == "number")
    return (isNaN(e) || e < 0 || e > 16777215) && vn(`'${e}' is not a valid hex color`), {
      r: (e & 16711680) >> 16,
      g: (e & 65280) >> 8,
      b: e & 255
    };
  if (typeof e == "string" && sv.test(e)) {
    const {
      groups: t
    } = e.match(sv), {
      fn: n,
      values: a
    } = t, l = a.split(/,\s*|\s*\/\s*|\s+/).map((i, o) => i.endsWith("%") || // unitless slv are %
    o > 0 && o < 3 && ["hsl", "hsla", "hsv", "hsva"].includes(n) ? parseFloat(i) / 100 : parseFloat(i));
    return Zx[n](...l);
  } else if (typeof e == "string") {
    let t = e.startsWith("#") ? e.slice(1) : e;
    [3, 4].includes(t.length) ? t = t.split("").map((a) => a + a).join("") : [6, 8].includes(t.length) || vn(`'${e}' is not a valid hex(a) color`);
    const n = parseInt(t, 16);
    return (isNaN(n) || n < 0 || n > 4294967295) && vn(`'${e}' is not a valid hex(a) color`), Vg(t);
  } else if (typeof e == "object") {
    if (tl(e, ["r", "g", "b"]))
      return e;
    if (tl(e, ["h", "s", "l"]))
      return la(Ac(e));
    if (tl(e, ["h", "s", "v"]))
      return la(e);
  }
  throw new TypeError(`Invalid color: ${e == null ? e : String(e) || e.constructor.name}
Expected #hex, #hexa, rgb(), rgba(), hsl(), hsla(), object or number`);
}
function la(e) {
  const {
    h: t,
    s: n,
    v: a,
    a: l
  } = e, i = (r) => {
    const s = (r + t / 60) % 6;
    return a - a * n * Math.max(Math.min(s, 4 - s, 1), 0);
  }, o = [i(5), i(3), i(1)].map((r) => Math.round(r * 255));
  return {
    r: o[0],
    g: o[1],
    b: o[2],
    a: l
  };
}
function uv(e) {
  return la(Ac(e));
}
function po(e) {
  if (!e) return {
    h: 0,
    s: 1,
    v: 1,
    a: 1
  };
  const t = e.r / 255, n = e.g / 255, a = e.b / 255, l = Math.max(t, n, a), i = Math.min(t, n, a);
  let o = 0;
  l !== i && (l === t ? o = 60 * (0 + (n - a) / (l - i)) : l === n ? o = 60 * (2 + (a - t) / (l - i)) : l === a && (o = 60 * (4 + (t - n) / (l - i)))), o < 0 && (o = o + 360);
  const r = l === 0 ? 0 : (l - i) / l, s = [o, r, l];
  return {
    h: s[0],
    s: s[1],
    v: s[2],
    a: e.a
  };
}
function pu(e) {
  const {
    h: t,
    s: n,
    v: a,
    a: l
  } = e, i = a - a * n / 2, o = i === 1 || i === 0 ? 0 : (a - i) / Math.min(i, 1 - i);
  return {
    h: t,
    s: o,
    l: i,
    a: l
  };
}
function Ac(e) {
  const {
    h: t,
    s: n,
    l: a,
    a: l
  } = e, i = a + n * Math.min(a, 1 - a), o = i === 0 ? 0 : 2 - 2 * a / i;
  return {
    h: t,
    s: o,
    v: i,
    a: l
  };
}
function xg(e) {
  let {
    r: t,
    g: n,
    b: a,
    a: l
  } = e;
  return l === void 0 ? `rgb(${t}, ${n}, ${a})` : `rgba(${t}, ${n}, ${a}, ${l})`;
}
function kg(e) {
  return xg(la(e));
}
function Ho(e) {
  const t = Math.round(e).toString(16);
  return ("00".substr(0, 2 - t.length) + t).toUpperCase();
}
function Cg(e) {
  let {
    r: t,
    g: n,
    b: a,
    a: l
  } = e;
  return `#${[Ho(t), Ho(n), Ho(a), l !== void 0 ? Ho(Math.round(l * 255)) : ""].join("")}`;
}
function Vg(e) {
  e = ek(e);
  let [t, n, a, l] = Ex(e, 2).map((i) => parseInt(i, 16));
  return l = l === void 0 ? l : l / 255, {
    r: t,
    g: n,
    b: a,
    a: l
  };
}
function Qx(e) {
  const t = Vg(e);
  return po(t);
}
function Eg(e) {
  return Cg(la(e));
}
function ek(e) {
  return e.startsWith("#") && (e = e.slice(1)), e = e.replace(/([^0-9a-f])/gi, "F"), (e.length === 3 || e.length === 4) && (e = e.split("").map((t) => t + t).join("")), e.length !== 6 && (e = Kf(Kf(e, 6), 8, "F")), e;
}
function tk(e, t) {
  const n = Sg(Dc(e));
  return n[0] = n[0] + t * 10, _g(wg(n));
}
function nk(e, t) {
  const n = Sg(Dc(e));
  return n[0] = n[0] - t * 10, _g(wg(n));
}
function Su(e) {
  const t = pn(e);
  return Dc(t)[1];
}
function ak(e, t) {
  const n = Su(e), a = Su(t), l = Math.max(n, a), i = Math.min(n, a);
  return (l + 0.05) / (i + 0.05);
}
function Pg(e) {
  const t = Math.abs(rv(pn(0), pn(e)));
  return Math.abs(rv(pn(16777215), pn(e))) > Math.min(t, 50) ? "#fff" : "#000";
}
function z(e, t) {
  return (n) => Object.keys(e).reduce((a, l) => {
    const o = typeof e[l] == "object" && e[l] != null && !Array.isArray(e[l]) ? e[l] : {
      type: e[l]
    };
    return n && l in n ? a[l] = {
      ...o,
      default: n[l]
    } : a[l] = o, t && !a[l].source && (a[l].source = t), a;
  }, {});
}
const ke = z({
  class: [String, Array, Object],
  style: {
    type: [String, Array, Object],
    default: null
  }
}, "component");
function St(e, t) {
  const n = Ha();
  if (!n)
    throw new Error(`[Vuetify] ${e} must be called from inside a setup function`);
  return n;
}
function ra() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const t = St(e).type;
  return ul((t == null ? void 0 : t.aliasName) || (t == null ? void 0 : t.name));
}
function lk(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : St("injectSelf");
  const {
    provides: n
  } = t;
  if (n && e in n)
    return n[e];
}
const ii = Symbol.for("vuetify:defaults");
function ik(e) {
  return Z(e);
}
function Tc() {
  const e = Me(ii);
  if (!e) throw new Error("[Vuetify] Could not find defaults instance");
  return e;
}
function gt(e, t) {
  const n = Tc(), a = Z(e), l = x(() => {
    if (bt(t == null ? void 0 : t.disabled)) return n.value;
    const o = bt(t == null ? void 0 : t.scoped), r = bt(t == null ? void 0 : t.reset), s = bt(t == null ? void 0 : t.root);
    if (a.value == null && !(o || r || s)) return n.value;
    let d = Jt(a.value, {
      prev: n.value
    });
    if (o) return d;
    if (r || s) {
      const u = Number(r || 1 / 0);
      for (let c = 0; c <= u && !(!d || !("prev" in d)); c++)
        d = d.prev;
      return d && typeof s == "string" && s in d && (d = Jt(Jt(d, {
        prev: d
      }), d[s])), d;
    }
    return d.prev ? Jt(d.prev, d) : d;
  });
  return at(ii, l), l;
}
function ok(e, t) {
  return e.props && (typeof e.props[t] < "u" || typeof e.props[ul(t)] < "u");
}
function rk() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Tc();
  const a = St("useDefaults");
  if (t = t ?? a.type.name ?? a.type.__name, !t)
    throw new Error("[Vuetify] Could not determine component name");
  const l = x(() => {
    var s;
    return (s = n.value) == null ? void 0 : s[e._as ?? t];
  }), i = new Proxy(e, {
    get(s, d) {
      var v, m, h, g;
      const u = Reflect.get(s, d);
      if (d === "class" || d === "style")
        return [(v = l.value) == null ? void 0 : v[d], u].filter((p) => p != null);
      if (ok(a.vnode, d)) return u;
      const c = (m = l.value) == null ? void 0 : m[d];
      if (c !== void 0) return c;
      const f = (g = (h = n.value) == null ? void 0 : h.global) == null ? void 0 : g[d];
      return f !== void 0 ? f : u;
    }
  }), o = fe();
  ut(() => {
    if (l.value) {
      const s = Object.entries(l.value).filter((d) => {
        let [u] = d;
        return u.startsWith(u[0].toUpperCase());
      });
      o.value = s.length ? Object.fromEntries(s) : void 0;
    } else
      o.value = void 0;
  });
  function r() {
    const s = lk(ii, a);
    at(ii, x(() => o.value ? Jt((s == null ? void 0 : s.value) ?? {}, o.value) : s == null ? void 0 : s.value));
  }
  return {
    props: i,
    provideSubDefaults: r
  };
}
function Cn(e) {
  if (e._setup = e._setup ?? e.setup, !e.name)
    return vn("The component is missing an explicit name, unable to generate default prop value"), e;
  if (e._setup) {
    e.props = z(e.props ?? {}, e.name)();
    const t = Object.keys(e.props).filter((n) => n !== "class" && n !== "style");
    e.filterProps = function(a) {
      return mn(a, t);
    }, e.props._as = String, e.setup = function(a, l) {
      const i = Tc();
      if (!i.value) return e._setup(a, l);
      const {
        props: o,
        provideSubDefaults: r
      } = rk(a, a._as ?? e.name, i), s = e._setup(o, l);
      return r(), s;
    };
  }
  return e;
}
function ne() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  return (t) => (e ? Cn : fc)(t);
}
function sk(e, t) {
  return t.props = e, t;
}
function Ca(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div", n = arguments.length > 2 ? arguments[2] : void 0;
  return ne()({
    name: n ?? wn(Ht(e.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: t
      },
      ...ke()
    },
    setup(a, l) {
      let {
        slots: i
      } = l;
      return () => {
        var o;
        return jn(a.tag, {
          class: [e, a.class],
          style: a.style
        }, (o = i.default) == null ? void 0 : o.call(i));
      };
    }
  });
}
function Ig(e) {
  if (typeof e.getRootNode != "function") {
    for (; e.parentNode; ) e = e.parentNode;
    return e !== document ? null : document;
  }
  const t = e.getRootNode();
  return t !== document && t.getRootNode({
    composed: !0
  }) !== document ? null : t;
}
const qi = "cubic-bezier(0.4, 0, 0.2, 1)", cv = "cubic-bezier(0.0, 0, 0.2, 1)", dv = "cubic-bezier(0.4, 0, 1, 1)", uk = {
  linear: (e) => e,
  easeInQuad: (e) => e ** 2,
  easeOutQuad: (e) => e * (2 - e),
  easeInOutQuad: (e) => e < 0.5 ? 2 * e ** 2 : -1 + (4 - 2 * e) * e,
  easeInCubic: (e) => e ** 3,
  easeOutCubic: (e) => --e ** 3 + 1,
  easeInOutCubic: (e) => e < 0.5 ? 4 * e ** 3 : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1,
  easeInQuart: (e) => e ** 4,
  easeOutQuart: (e) => 1 - --e ** 4,
  easeInOutQuart: (e) => e < 0.5 ? 8 * e ** 4 : 1 - 8 * --e ** 4,
  easeInQuint: (e) => e ** 5,
  easeOutQuint: (e) => 1 + --e ** 5,
  easeInOutQuint: (e) => e < 0.5 ? 16 * e ** 5 : 1 + 16 * --e ** 5,
  instant: (e) => 1
};
function fv(e, t, n) {
  return Object.keys(e).filter((a) => Pc(a) && a.endsWith(t)).reduce((a, l) => (a[l.slice(0, -t.length)] = (i) => bo(e[l], i, n(i)), a), {});
}
function Oc(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  for (; e; ) {
    if (t ? ck(e) : $c(e)) return e;
    e = e.parentElement;
  }
  return document.scrollingElement;
}
function pr(e, t) {
  const n = [];
  if (t && e && !t.contains(e)) return n;
  for (; e && ($c(e) && n.push(e), e !== t); )
    e = e.parentElement;
  return n;
}
function $c(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
  const t = window.getComputedStyle(e), n = t.overflowY === "scroll" || t.overflowY === "auto" && e.scrollHeight > e.clientHeight, a = t.overflowX === "scroll" || t.overflowX === "auto" && e.scrollWidth > e.clientWidth;
  return n || a;
}
function ck(e) {
  if (!e || e.nodeType !== Node.ELEMENT_NODE) return !1;
  const t = window.getComputedStyle(e);
  return ["scroll", "auto"].includes(t.overflowY);
}
function dk(e) {
  let {
    depth: t,
    isLast: n,
    isLastGroup: a,
    leafLinks: l,
    separateRoots: i,
    parentIndentLines: o,
    variant: r
  } = e;
  if (!o || !t)
    return {
      leaf: void 0,
      node: void 0,
      children: o
    };
  if (r === "simple")
    return {
      leaf: [...o, "line"],
      node: [...o, "line"],
      children: [...o, "line"]
    };
  const s = n && (!a || i || t > 1);
  return {
    leaf: [...o, s ? "last-leaf" : "leaf", ...l ? ["leaf-link"] : []],
    node: [...o, s ? "last-leaf" : "leaf"],
    children: [...o, s ? "none" : "line"]
  };
}
function fk(e) {
  for (; e; ) {
    if (window.getComputedStyle(e).position === "fixed")
      return !0;
    e = e.offsetParent;
  }
  return !1;
}
function re(e) {
  const t = St("useRender");
  t.render = e;
}
function Ee(e, t, n) {
  let a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (c) => c, l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (c) => c;
  const i = St("useProxiedModel"), o = Z(e[t] !== void 0 ? e[t] : n), r = ul(t), d = x(r !== t ? () => {
    var c, f, v, m;
    return e[t], !!(((c = i.vnode.props) != null && c.hasOwnProperty(t) || (f = i.vnode.props) != null && f.hasOwnProperty(r)) && ((v = i.vnode.props) != null && v.hasOwnProperty(`onUpdate:${t}`) || (m = i.vnode.props) != null && m.hasOwnProperty(`onUpdate:${r}`)));
  } : () => {
    var c, f;
    return e[t], !!((c = i.vnode.props) != null && c.hasOwnProperty(t) && ((f = i.vnode.props) != null && f.hasOwnProperty(`onUpdate:${t}`)));
  });
  Gt(() => !d.value, () => {
    me(() => e[t], (c) => {
      o.value = c;
    });
  });
  const u = x({
    get() {
      const c = e[t];
      return a(d.value ? c : o.value);
    },
    set(c) {
      const f = l(c), v = Pe(d.value ? e[t] : o.value);
      v === f || a(v) === c || (o.value = f, i == null || i.emit(`update:${t}`, f));
    }
  });
  return Object.defineProperty(u, "externalValue", {
    get: () => d.value ? e[t] : o.value
  }), u;
}
const vk = {
  badge: "Badge",
  open: "Open",
  close: "Close",
  dismiss: "Dismiss",
  confirmEdit: {
    ok: "OK",
    cancel: "Cancel"
  },
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  dateRangeInput: {
    divider: "to"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    range: {
      title: "Select dates",
      header: "Enter dates"
    },
    title: "Select date",
    header: "Enter date",
    input: {
      placeholder: "Enter date"
    },
    ariaLabel: {
      previousMonth: "Previous month",
      nextMonth: "Next month",
      selectYear: "Select year",
      selectDate: "{0}",
      // Full date format
      currentDate: "Today, {0}"
    }
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more",
    today: "Today"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action",
    otp: "Please enter OTP character {0}"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  fileUpload: {
    title: "Drag and drop files here",
    divider: "or",
    browse: "Browse Files"
  },
  timePicker: {
    am: "AM",
    pm: "PM",
    title: "Select Time"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  stepper: {
    next: "Next",
    prev: "Previous"
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  },
  loading: "Loading...",
  infiniteScroll: {
    loadMore: "Load more",
    empty: "No more"
  },
  rules: {
    required: "This field is required",
    email: "Please enter a valid email",
    number: "This field can only contain numbers",
    integer: "This field can only contain integer values",
    capital: "This field can only contain uppercase letters",
    maxLength: "You must enter a maximum of {0} characters",
    minLength: "You must enter a minimum of {0} characters",
    strictLength: "The length of the entered field is invalid",
    exclude: "The {0} character is not allowed",
    notEmpty: "Please choose at least one value",
    pattern: "Invalid format"
  },
  hotkey: {
    then: "then",
    ctrl: "Ctrl",
    command: "Command",
    space: "Space",
    shift: "Shift",
    alt: "Alt",
    enter: "Enter",
    escape: "Escape",
    upArrow: "Up Arrow",
    downArrow: "Down Arrow",
    leftArrow: "Left Arrow",
    rightArrow: "Right Arrow",
    backspace: "Backspace",
    option: "Option",
    plus: "plus",
    shortcut: "Keyboard shortcut: {0}"
  },
  video: {
    play: "Play",
    pause: "Pause",
    seek: "Seek",
    volume: "Volume",
    showVolume: "Show volume control",
    mute: "Mute",
    unmute: "Unmute",
    enterFullscreen: "Full screen",
    exitFullscreen: "Exit full screen"
  },
  colorPicker: {
    ariaLabel: {
      eyedropper: "Select color with eyedropper",
      hueSlider: "Hue",
      alphaSlider: "Alpha",
      redInput: "Red value",
      greenInput: "Green value",
      blueInput: "Blue value",
      alphaInput: "Alpha value",
      hueInput: "Hue value",
      saturationInput: "Saturation value",
      lightnessInput: "Lightness value",
      hexInput: "HEX value",
      hexaInput: "HEX with alpha value",
      changeFormat: "Change color format"
    }
  }
}, vv = "$vuetify.", mv = (e, t) => e.replace(/\{(\d+)\}/g, (n, a) => String(t[Number(a)])), Ng = (e, t, n) => function(a) {
  for (var l = arguments.length, i = new Array(l > 1 ? l - 1 : 0), o = 1; o < l; o++)
    i[o - 1] = arguments[o];
  if (!a.startsWith(vv))
    return mv(a, i);
  const r = a.replace(vv, ""), s = e.value && n.value[e.value], d = t.value && n.value[t.value];
  let u = gl(s, r, null);
  return u || (vn(`Translation key "${a}" not found in "${e.value}", trying fallback locale`), u = gl(d, r, null)), u || (li(`Translation key "${a}" not found in fallback`), u = a), typeof u != "string" && (li(`Translation key "${a}" has a non-string value`), u = a), mv(u, i);
};
function Bc(e, t) {
  return (n, a) => new Intl.NumberFormat([e.value, t.value], a).format(n);
}
function Dg(e, t) {
  return Bc(e, t)(0.1).includes(",") ? "," : ".";
}
function Ns(e, t, n) {
  const a = Ee(e, t, e[t] ?? n.value);
  return a.value = e[t] ?? n.value, me(n, (l) => {
    e[t] == null && (a.value = n.value);
  }), a;
}
function Ag(e) {
  return (t) => {
    const n = Ns(t, "locale", e.current), a = Ns(t, "fallback", e.fallback), l = Ns(t, "messages", e.messages);
    return {
      name: "vuetify",
      current: n,
      fallback: a,
      messages: l,
      decimalSeparator: R(() => Dg(n, a)),
      t: Ng(n, a, l),
      n: Bc(n, a),
      provide: Ag({
        current: n,
        fallback: a,
        messages: l
      })
    };
  };
}
function mk(e) {
  const t = fe((e == null ? void 0 : e.locale) ?? "en"), n = fe((e == null ? void 0 : e.fallback) ?? "en"), a = Z({
    en: vk,
    ...e == null ? void 0 : e.messages
  });
  return {
    name: "vuetify",
    current: t,
    fallback: n,
    messages: a,
    decimalSeparator: R(() => (e == null ? void 0 : e.decimalSeparator) ?? Dg(t, n)),
    t: Ng(t, n, a),
    n: Bc(t, n),
    provide: Ag({
      current: t,
      fallback: n,
      messages: a
    })
  };
}
const oi = Symbol.for("vuetify:locale");
function hk(e) {
  return e.name != null;
}
function gk(e) {
  const t = e != null && e.adapter && hk(e == null ? void 0 : e.adapter) ? e == null ? void 0 : e.adapter : mk(e), n = pk(t, e);
  return {
    ...t,
    ...n
  };
}
function nt() {
  const e = Me(oi);
  if (!e) throw new Error("[Vuetify] Could not find injected locale instance");
  return e;
}
function yk(e) {
  const t = Me(oi);
  if (!t) throw new Error("[Vuetify] Could not find injected locale instance");
  const n = t.provide(e), a = Sk(n, t.rtl, e), l = {
    ...n,
    ...a
  };
  return at(oi, l), l;
}
function bk() {
  return {
    af: !1,
    ar: !0,
    bg: !1,
    ca: !1,
    ckb: !1,
    cs: !1,
    de: !1,
    el: !1,
    en: !1,
    es: !1,
    et: !1,
    fa: !0,
    fi: !1,
    fr: !1,
    hr: !1,
    hu: !1,
    he: !0,
    id: !1,
    it: !1,
    ja: !1,
    km: !1,
    ko: !1,
    lv: !1,
    lt: !1,
    nl: !1,
    no: !1,
    pl: !1,
    pt: !1,
    ro: !1,
    ru: !1,
    sk: !1,
    sl: !1,
    srCyrl: !1,
    srLatn: !1,
    sv: !1,
    th: !1,
    tr: !1,
    az: !1,
    uk: !1,
    vi: !1,
    zhHans: !1,
    zhHant: !1
  };
}
function pk(e, t) {
  const n = Z((t == null ? void 0 : t.rtl) ?? bk()), a = x(() => n.value[e.current.value] ?? !1);
  return {
    isRtl: a,
    rtl: n,
    rtlClasses: R(() => `v-locale--is-${a.value ? "rtl" : "ltr"}`)
  };
}
function Sk(e, t, n) {
  const a = x(() => n.rtl ?? t.value[e.current.value] ?? !1);
  return {
    isRtl: a,
    rtl: t,
    rtlClasses: R(() => `v-locale--is-${a.value ? "rtl" : "ltr"}`)
  };
}
function Et() {
  const e = Me(oi);
  if (!e) throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: e.isRtl,
    rtlClasses: e.rtlClasses
  };
}
function So(e) {
  const t = e.slice(-2).toUpperCase();
  switch (!0) {
    case e === "GB-alt-variant":
      return {
        firstDay: 0,
        firstWeekSize: 4
      };
    case e === "001":
      return {
        firstDay: 1,
        firstWeekSize: 1
      };
    case `AG AS BD BR BS BT BW BZ CA CO DM DO ET GT GU HK HN ID IL IN JM JP KE
    KH KR LA MH MM MO MT MX MZ NI NP PA PE PH PK PR PY SA SG SV TH TT TW UM US
    VE VI WS YE ZA ZW`.includes(t):
      return {
        firstDay: 0,
        firstWeekSize: 1
      };
    case `AI AL AM AR AU AZ BA BM BN BY CL CM CN CR CY EC GE HR KG KZ LB LK LV
    MD ME MK MN MY NZ RO RS SI TJ TM TR UA UY UZ VN XK`.includes(t):
      return {
        firstDay: 1,
        firstWeekSize: 1
      };
    case `AD AN AT AX BE BG CH CZ DE DK EE ES FI FJ FO FR GB GF GP GR HU IE IS
    IT LI LT LU MC MQ NL NO PL RE RU SE SK SM VA`.includes(t):
      return {
        firstDay: 1,
        firstWeekSize: 4
      };
    case "AE AF BH DJ DZ EG IQ IR JO KW LY OM QA SD SY".includes(t):
      return {
        firstDay: 6,
        firstWeekSize: 1
      };
    case t === "MV":
      return {
        firstDay: 5,
        firstWeekSize: 1
      };
    case t === "PT":
      return {
        firstDay: 0,
        firstWeekSize: 4
      };
    default:
      return null;
  }
}
function wk(e, t, n) {
  var u;
  const a = [];
  let l = [];
  const i = Tg(e), o = Og(e), r = n ?? ((u = So(t)) == null ? void 0 : u.firstDay) ?? 0, s = (i.getDay() - r + 7) % 7, d = (o.getDay() - r + 7) % 7;
  for (let c = 0; c < s; c++) {
    const f = new Date(i);
    f.setDate(f.getDate() - (s - c)), l.push(f);
  }
  for (let c = 1; c <= o.getDate(); c++) {
    const f = new Date(e.getFullYear(), e.getMonth(), c);
    l.push(f), l.length === 7 && (a.push(l), l = []);
  }
  for (let c = 1; c < 7 - d; c++) {
    const f = new Date(o);
    f.setDate(f.getDate() + c), l.push(f);
  }
  return l.length > 0 && a.push(l), a;
}
function Sr(e, t, n) {
  var i;
  let a = (n ?? ((i = So(t)) == null ? void 0 : i.firstDay) ?? 0) % 7;
  [0, 1, 2, 3, 4, 5, 6].includes(a) || (vn("Invalid firstDayOfWeek, expected discrete number in range [0-6]"), a = 0);
  const l = new Date(e);
  for (; l.getDay() !== a; )
    l.setDate(l.getDate() - 1);
  return l;
}
function _k(e, t) {
  var l;
  const n = new Date(e), a = ((((l = So(t)) == null ? void 0 : l.firstDay) ?? 0) + 6) % 7;
  for (; n.getDay() !== a; )
    n.setDate(n.getDate() + 1);
  return n;
}
function Tg(e) {
  return new Date(e.getFullYear(), e.getMonth(), 1);
}
function Og(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 0);
}
function xk(e) {
  const t = e.split("-").map(Number);
  return new Date(t[0], t[1] - 1, t[2]);
}
const kk = /^([12]\d{3}-([1-9]|0[1-9]|1[0-2])-([1-9]|0[1-9]|[12]\d|3[01]))$/;
function $g(e) {
  if (e == null) return /* @__PURE__ */ new Date();
  if (e instanceof Date) return e;
  if (typeof e == "string") {
    let t;
    if (kk.test(e))
      return xk(e);
    if (t = Date.parse(e), !isNaN(t)) return new Date(t);
  }
  return null;
}
const hv = new Date(2e3, 0, 2);
function Ck(e, t, n) {
  var l;
  const a = t ?? ((l = So(e)) == null ? void 0 : l.firstDay) ?? 0;
  return bn(7).map((i) => {
    const o = new Date(hv);
    return o.setDate(hv.getDate() + a + i), new Intl.DateTimeFormat(e, {
      weekday: n ?? "narrow"
    }).format(o);
  });
}
function Vk(e, t, n, a) {
  const l = $g(e) ?? /* @__PURE__ */ new Date(), i = a == null ? void 0 : a[t];
  if (typeof i == "function")
    return i(l, t, n);
  let o = {};
  switch (t) {
    case "fullDate":
      o = {
        year: "numeric",
        month: "short",
        day: "numeric"
      };
      break;
    case "fullDateWithWeekday":
      o = {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      };
      break;
    case "normalDate":
      const r = l.getDate(), s = new Intl.DateTimeFormat(n, {
        month: "long"
      }).format(l);
      return `${r} ${s}`;
    case "normalDateWithWeekday":
      o = {
        weekday: "short",
        day: "numeric",
        month: "short"
      };
      break;
    case "shortDate":
      o = {
        month: "short",
        day: "numeric"
      };
      break;
    case "year":
      o = {
        year: "numeric"
      };
      break;
    case "month":
      o = {
        month: "long"
      };
      break;
    case "monthShort":
      o = {
        month: "short"
      };
      break;
    case "monthAndYear":
      o = {
        month: "long",
        year: "numeric"
      };
      break;
    case "monthAndDate":
      o = {
        month: "long",
        day: "numeric"
      };
      break;
    case "weekday":
      o = {
        weekday: "long"
      };
      break;
    case "weekdayShort":
      o = {
        weekday: "short"
      };
      break;
    case "dayOfMonth":
      return new Intl.NumberFormat(n).format(l.getDate());
    case "hours12h":
      o = {
        hour: "numeric",
        hour12: !0
      };
      break;
    case "hours24h":
      o = {
        hour: "numeric",
        hour12: !1
      };
      break;
    case "minutes":
      o = {
        minute: "numeric"
      };
      break;
    case "seconds":
      o = {
        second: "numeric"
      };
      break;
    case "fullTime":
      o = {
        hour: "numeric",
        minute: "numeric"
      };
      break;
    case "fullTime12h":
      o = {
        hour: "numeric",
        minute: "numeric",
        hour12: !0
      };
      break;
    case "fullTime24h":
      o = {
        hour: "numeric",
        minute: "numeric",
        hour12: !1
      };
      break;
    case "fullDateTime":
      o = {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "numeric"
      };
      break;
    case "fullDateTime12h":
      o = {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        hour12: !0
      };
      break;
    case "fullDateTime24h":
      o = {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        hour12: !1
      };
      break;
    case "keyboardDate":
      o = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit"
      };
      break;
    case "keyboardDateTime":
      return o = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric"
      }, new Intl.DateTimeFormat(n, o).format(l).replace(/, /g, " ");
    case "keyboardDateTime12h":
      return o = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        hour12: !0
      }, new Intl.DateTimeFormat(n, o).format(l).replace(/, /g, " ");
    case "keyboardDateTime24h":
      return o = {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "numeric",
        minute: "numeric",
        hour12: !1
      }, new Intl.DateTimeFormat(n, o).format(l).replace(/, /g, " ");
    default:
      o = i ?? {
        timeZone: "UTC",
        timeZoneName: "short"
      };
  }
  return new Intl.DateTimeFormat(n, o).format(l);
}
function Ek(e, t) {
  const n = e.toJsDate(t), a = n.getFullYear(), l = Yf(String(n.getMonth() + 1), 2, "0"), i = Yf(String(n.getDate()), 2, "0");
  return `${a}-${l}-${i}`;
}
function Pk(e) {
  const [t, n, a] = e.split("-").map(Number);
  return new Date(t, n - 1, a);
}
function Ik(e, t) {
  const n = new Date(e);
  return n.setMinutes(n.getMinutes() + t), n;
}
function Nk(e, t) {
  const n = new Date(e);
  return n.setHours(n.getHours() + t), n;
}
function dl(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t), n;
}
function Dk(e, t) {
  const n = new Date(e);
  return n.setDate(n.getDate() + t * 7), n;
}
function Ak(e, t) {
  const n = new Date(e);
  return n.setDate(1), n.setMonth(n.getMonth() + t), n;
}
function Xi(e) {
  return e.getFullYear();
}
function Tk(e) {
  return e.getMonth();
}
function Ok(e, t, n, a) {
  const l = So(t), i = n ?? (l == null ? void 0 : l.firstDay) ?? 0, o = (l == null ? void 0 : l.firstWeekSize) ?? 1;
  return a !== void 0 ? $k(e, t, i, a) : Bk(e, t, i, o);
}
function $k(e, t, n, a) {
  const l = (7 + a - n) % 7, i = Sr(e, t, n), o = dl(i, 6);
  function r(f) {
    return (7 + new Date(f, 0, 1).getDay() - n) % 7;
  }
  let s = Xi(e);
  s < Xi(o) && r(s + 1) <= l && s++;
  const d = new Date(s, 0, 1), u = r(s), c = u <= l ? dl(d, -u) : dl(d, 7 - u);
  return 1 + _r(Mc(e), Ji(c), "weeks");
}
function Bk(e, t, n, a) {
  const l = dl(Sr(e, t, n), 6);
  function i(u) {
    const c = new Date(u, 0, 1);
    return 7 - _r(c, Sr(c, t, n), "days");
  }
  let o = Xi(e);
  o < Xi(l) && i(o + 1) >= a && o++;
  const r = new Date(o, 0, 1), s = i(o), d = s >= a ? dl(r, s - 7) : dl(r, s);
  return 1 + _r(Mc(e), Ji(d), "weeks");
}
function Mk(e) {
  return e.getDate();
}
function Rk(e) {
  return new Date(e.getFullYear(), e.getMonth() + 1, 1);
}
function Lk(e) {
  return new Date(e.getFullYear(), e.getMonth() - 1, 1);
}
function Fk(e) {
  return e.getHours();
}
function Hk(e) {
  return e.getMinutes();
}
function zk(e) {
  return new Date(e.getFullYear(), 0, 1);
}
function jk(e) {
  return new Date(e.getFullYear(), 11, 31);
}
function Wk(e, t) {
  return wr(e, t[0]) && Kk(e, t[1]);
}
function Uk(e) {
  const t = new Date(e);
  return t instanceof Date && !isNaN(t.getTime());
}
function wr(e, t) {
  return e.getTime() > t.getTime();
}
function Gk(e, t) {
  return wr(Ji(e), Ji(t));
}
function Kk(e, t) {
  return e.getTime() < t.getTime();
}
function gv(e, t) {
  return e.getTime() === t.getTime();
}
function Yk(e, t) {
  return e.getDate() === t.getDate() && e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function qk(e, t) {
  return e.getMonth() === t.getMonth() && e.getFullYear() === t.getFullYear();
}
function Xk(e, t) {
  return e.getFullYear() === t.getFullYear();
}
function _r(e, t, n) {
  const a = new Date(e), l = new Date(t);
  switch (n) {
    case "years":
      return a.getFullYear() - l.getFullYear();
    case "quarters":
      return Math.floor((a.getMonth() - l.getMonth() + (a.getFullYear() - l.getFullYear()) * 12) / 4);
    case "months":
      return a.getMonth() - l.getMonth() + (a.getFullYear() - l.getFullYear()) * 12;
    case "weeks":
      return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60 * 24 * 7));
    case "days":
      return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60 * 24));
    case "hours":
      return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60 * 60));
    case "minutes":
      return Math.floor((a.getTime() - l.getTime()) / (1e3 * 60));
    case "seconds":
      return Math.floor((a.getTime() - l.getTime()) / 1e3);
    default:
      return a.getTime() - l.getTime();
  }
}
function Jk(e, t) {
  const n = new Date(e);
  return n.setHours(t), n;
}
function Zk(e, t) {
  const n = new Date(e);
  return n.setMinutes(t), n;
}
function Qk(e, t) {
  const n = new Date(e);
  return n.setMonth(t), n;
}
function eC(e, t) {
  const n = new Date(e);
  return n.setDate(t), n;
}
function tC(e, t) {
  const n = new Date(e);
  return n.setFullYear(t), n;
}
function Ji(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 0, 0, 0, 0);
}
function Mc(e) {
  return new Date(e.getFullYear(), e.getMonth(), e.getDate(), 23, 59, 59, 999);
}
class nC {
  constructor(t) {
    this.locale = t.locale, this.formats = t.formats;
  }
  date(t) {
    return $g(t);
  }
  toJsDate(t) {
    return t;
  }
  toISO(t) {
    return Ek(this, t);
  }
  parseISO(t) {
    return Pk(t);
  }
  addMinutes(t, n) {
    return Ik(t, n);
  }
  addHours(t, n) {
    return Nk(t, n);
  }
  addDays(t, n) {
    return dl(t, n);
  }
  addWeeks(t, n) {
    return Dk(t, n);
  }
  addMonths(t, n) {
    return Ak(t, n);
  }
  getWeekArray(t, n) {
    const a = n !== void 0 ? Number(n) : void 0;
    return wk(t, this.locale, a);
  }
  startOfWeek(t, n) {
    const a = n !== void 0 ? Number(n) : void 0;
    return Sr(t, this.locale, a);
  }
  endOfWeek(t) {
    return _k(t, this.locale);
  }
  startOfMonth(t) {
    return Tg(t);
  }
  endOfMonth(t) {
    return Og(t);
  }
  format(t, n) {
    return Vk(t, n, this.locale, this.formats);
  }
  isEqual(t, n) {
    return gv(t, n);
  }
  isValid(t) {
    return Uk(t);
  }
  isWithinRange(t, n) {
    return Wk(t, n);
  }
  isAfter(t, n) {
    return wr(t, n);
  }
  isAfterDay(t, n) {
    return Gk(t, n);
  }
  isBefore(t, n) {
    return !wr(t, n) && !gv(t, n);
  }
  isSameDay(t, n) {
    return Yk(t, n);
  }
  isSameMonth(t, n) {
    return qk(t, n);
  }
  isSameYear(t, n) {
    return Xk(t, n);
  }
  setMinutes(t, n) {
    return Zk(t, n);
  }
  setHours(t, n) {
    return Jk(t, n);
  }
  setMonth(t, n) {
    return Qk(t, n);
  }
  setDate(t, n) {
    return eC(t, n);
  }
  setYear(t, n) {
    return tC(t, n);
  }
  getDiff(t, n, a) {
    return _r(t, n, a);
  }
  getWeekdays(t, n) {
    const a = t !== void 0 ? Number(t) : void 0;
    return Ck(this.locale, a, n);
  }
  getYear(t) {
    return Xi(t);
  }
  getMonth(t) {
    return Tk(t);
  }
  getWeek(t, n, a) {
    const l = n !== void 0 ? Number(n) : void 0, i = a !== void 0 ? Number(a) : void 0;
    return Ok(t, this.locale, l, i);
  }
  getDate(t) {
    return Mk(t);
  }
  getNextMonth(t) {
    return Rk(t);
  }
  getPreviousMonth(t) {
    return Lk(t);
  }
  getHours(t) {
    return Fk(t);
  }
  getMinutes(t) {
    return Hk(t);
  }
  startOfDay(t) {
    return Ji(t);
  }
  endOfDay(t) {
    return Mc(t);
  }
  startOfYear(t) {
    return zk(t);
  }
  endOfYear(t) {
    return jk(t);
  }
}
const Bg = Symbol.for("vuetify:date-options"), yv = Symbol.for("vuetify:date-adapter");
function aC(e, t) {
  const n = Jt({
    adapter: nC,
    locale: {
      af: "af-ZA",
      // ar: '', # not the same value for all variants
      bg: "bg-BG",
      ca: "ca-ES",
      ckb: "",
      cs: "cs-CZ",
      de: "de-DE",
      el: "el-GR",
      en: "en-US",
      // es: '', # not the same value for all variants
      et: "et-EE",
      fa: "fa-IR",
      fi: "fi-FI",
      // fr: '', #not the same value for all variants
      hr: "hr-HR",
      hu: "hu-HU",
      he: "he-IL",
      id: "id-ID",
      it: "it-IT",
      ja: "ja-JP",
      ko: "ko-KR",
      lv: "lv-LV",
      lt: "lt-LT",
      nl: "nl-NL",
      no: "no-NO",
      pl: "pl-PL",
      pt: "pt-PT",
      ro: "ro-RO",
      ru: "ru-RU",
      sk: "sk-SK",
      sl: "sl-SI",
      srCyrl: "sr-SP",
      srLatn: "sr-SP",
      sv: "sv-SE",
      th: "th-TH",
      tr: "tr-TR",
      az: "az-AZ",
      uk: "uk-UA",
      vi: "vi-VN",
      zhHans: "zh-CN",
      zhHant: "zh-TW"
    }
  }, e);
  return {
    options: n,
    instance: Mg(n, t)
  };
}
function lC(e, t, n) {
  const a = e.getDiff(e.endOfDay(n ?? t), e.startOfDay(t), "days"), l = [t];
  for (let i = 1; i < a; i++) {
    const o = e.addDays(t, i);
    l.push(o);
  }
  return n && l.push(e.endOfDay(n)), l;
}
function Mg(e, t) {
  const n = It(typeof e.adapter == "function" ? new e.adapter({
    locale: e.locale[t.current.value] ?? t.current.value,
    formats: e.formats
  }) : e.adapter);
  return me(t.current, (a) => {
    n.locale = e.locale[a] ?? a ?? n.locale;
  }), n;
}
function wo() {
  const e = Me(Bg);
  if (!e) throw new Error("[Vuetify] Could not find injected date options");
  const t = nt();
  return Mg(e, t);
}
const Hr = ["sm", "md", "lg", "xl", "xxl"], wu = Symbol.for("vuetify:display"), bv = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
}, iC = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : bv;
  return Jt(bv, e);
};
function pv(e) {
  return qe && !e ? window.innerWidth : typeof e == "object" && e.clientWidth || 0;
}
function Sv(e) {
  return qe && !e ? window.innerHeight : typeof e == "object" && e.clientHeight || 0;
}
function wv(e) {
  const t = qe && !e ? window.navigator.userAgent : "ssr";
  function n(m) {
    return !!t.match(m);
  }
  const a = n(/android/i), l = n(/iphone|ipad|ipod/i), i = n(/cordova/i), o = n(/electron/i), r = n(/chrome/i), s = n(/edge/i), d = n(/firefox/i), u = n(/opera/i), c = n(/win/i), f = n(/mac/i), v = n(/linux/i);
  return {
    android: a,
    ios: l,
    cordova: i,
    electron: o,
    chrome: r,
    edge: s,
    firefox: d,
    opera: u,
    win: c,
    mac: f,
    linux: v,
    touch: _x,
    ssr: t === "ssr"
  };
}
function oC(e, t) {
  const {
    thresholds: n,
    mobileBreakpoint: a
  } = iC(e), l = fe(Sv(t)), i = fe(wv(t)), o = It({}), r = fe(pv(t));
  function s() {
    l.value = Sv(), r.value = pv();
  }
  function d() {
    s(), i.value = wv();
  }
  return ut(() => {
    const u = r.value < n.sm, c = r.value < n.md && !u, f = r.value < n.lg && !(c || u), v = r.value < n.xl && !(f || c || u), m = r.value < n.xxl && !(v || f || c || u), h = r.value >= n.xxl, g = u ? "xs" : c ? "sm" : f ? "md" : v ? "lg" : m ? "xl" : "xxl", p = typeof a == "number" ? a : n[a], y = r.value < p;
    o.xs = u, o.sm = c, o.md = f, o.lg = v, o.xl = m, o.xxl = h, o.smAndUp = !u, o.mdAndUp = !(u || c), o.lgAndUp = !(u || c || f), o.xlAndUp = !(u || c || f || v), o.smAndDown = !(f || v || m || h), o.mdAndDown = !(v || m || h), o.lgAndDown = !(m || h), o.xlAndDown = !h, o.name = g, o.height = l.value, o.width = r.value, o.mobile = y, o.mobileBreakpoint = a, o.platform = i.value, o.thresholds = n;
  }), qe && (window.addEventListener("resize", s, {
    passive: !0
  }), Dt(() => {
    window.removeEventListener("resize", s);
  }, !0)), {
    ...ci(o),
    update: d,
    ssr: !!t
  };
}
const kl = z({
  mobile: {
    type: Boolean,
    default: !1
  },
  mobileBreakpoint: [Number, String]
}, "display");
function Vn() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    mobile: null
  }, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  const n = Me(wu);
  if (!n) throw new Error("Could not find Vuetify display injection");
  const a = x(() => e.mobile ? !0 : typeof e.mobileBreakpoint == "number" ? n.width.value < e.mobileBreakpoint : e.mobileBreakpoint ? n.width.value < n.thresholds.value[e.mobileBreakpoint] : e.mobile === null ? n.mobile.value : !1), l = R(() => t ? {
    [`${t}--mobile`]: a.value
  } : {});
  return {
    ...n,
    displayClasses: l,
    mobile: a
  };
}
const Rg = Symbol.for("vuetify:goto");
function Lg() {
  return {
    container: void 0,
    duration: 300,
    layout: !1,
    offset: 0,
    easing: "easeInOutCubic",
    patterns: uk
  };
}
function rC(e) {
  return Rc(e) ?? (document.scrollingElement || document.body);
}
function Rc(e) {
  return typeof e == "string" ? document.querySelector(e) : Ec(e);
}
function Ds(e, t, n) {
  if (typeof e == "number") return t && n ? -e : e;
  let a = Rc(e), l = 0;
  for (; a; )
    l += t ? a.offsetLeft : a.offsetTop, a = a.offsetParent;
  return l;
}
function sC(e, t) {
  return {
    rtl: t.isRtl,
    options: Jt(Lg(), e)
  };
}
async function _v(e, t, n, a) {
  const l = n ? "scrollLeft" : "scrollTop", i = Jt((a == null ? void 0 : a.options) ?? Lg(), t), o = a == null ? void 0 : a.rtl.value, r = (typeof e == "number" ? e : Rc(e)) ?? 0, s = i.container === "parent" && r instanceof HTMLElement ? r.parentElement : rC(i.container), d = aa() ? i.patterns.instant : typeof i.easing == "function" ? i.easing : i.patterns[i.easing];
  if (!d) throw new TypeError(`Easing function "${i.easing}" not found.`);
  let u;
  if (typeof r == "number")
    u = Ds(r, n, o);
  else if (u = Ds(r, n, o) - Ds(s, n, o), i.layout) {
    const m = window.getComputedStyle(r).getPropertyValue("--v-layout-top");
    m && (u -= parseInt(m, 10));
  }
  u += i.offset, u = cC(s, u, !!o, !!n);
  const c = s[l] ?? 0;
  if (u === c) return Promise.resolve(u);
  const f = performance.now();
  return new Promise((v) => requestAnimationFrame(function m(h) {
    const p = (h - f) / i.duration, y = Math.floor(c + (u - c) * d(ot(p, 0, 1)));
    if (s[l] = y, p >= 1 && Math.abs(y - s[l]) < 10)
      return v(u);
    if (p > 2)
      return vn("Scroll target is not reachable"), v(s[l]);
    requestAnimationFrame(m);
  }));
}
function uC() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = Me(Rg), {
    isRtl: n
  } = Et();
  if (!t) throw new Error("[Vuetify] Could not find injected goto instance");
  const a = {
    ...t,
    // can be set via VLocaleProvider
    rtl: R(() => t.rtl.value || n.value)
  };
  async function l(i, o) {
    return _v(i, Jt(e, o), !1, a);
  }
  return l.horizontal = async (i, o) => _v(i, Jt(e, o), !0, a), l;
}
function cC(e, t, n, a) {
  const {
    scrollWidth: l,
    scrollHeight: i
  } = e, [o, r] = e === document.scrollingElement ? [window.innerWidth, window.innerHeight] : [e.offsetWidth, e.offsetHeight];
  let s, d;
  return a ? n ? (s = -(l - o), d = 0) : (s = 0, d = l - o) : (s = 0, d = i + -r), ot(t, s, d);
}
const dC = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  // delete (e.g. v-chip close)
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  // for carousel
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus",
  calendar: "mdi-calendar",
  treeviewCollapse: "mdi-menu-down",
  treeviewExpand: "mdi-menu-right",
  tableGroupCollapse: "mdi-chevron-down",
  tableGroupExpand: "mdi-chevron-right",
  eyeDropper: "mdi-eyedropper",
  upload: "mdi-cloud-upload",
  color: "mdi-palette",
  command: "mdi-apple-keyboard-command",
  ctrl: "mdi-apple-keyboard-control",
  space: "mdi-keyboard-space",
  shift: "mdi-apple-keyboard-shift",
  alt: "mdi-apple-keyboard-option",
  enter: "mdi-keyboard-return",
  arrowup: "mdi-arrow-up",
  arrowdown: "mdi-arrow-down",
  arrowleft: "mdi-arrow-left",
  arrowright: "mdi-arrow-right",
  backspace: "mdi-backspace",
  play: "mdi-play",
  pause: "mdi-pause",
  fullscreen: "mdi-fullscreen",
  fullscreenExit: "mdi-fullscreen-exit",
  volumeHigh: "mdi-volume-high",
  volumeMedium: "mdi-volume-medium",
  volumeLow: "mdi-volume-low",
  volumeOff: "mdi-volume-variant-off"
}, fC = {
  // Not using mergeProps here, functional components merge props by default (?)
  component: (e) => jn(Fc, {
    ...e,
    class: "mdi"
  })
}, Ve = [String, Function, Object, Array], _u = Symbol.for("vuetify:icons"), zr = z({
  icon: {
    type: Ve
  },
  // Could not remove this and use makeTagProps, types complained because it is not required
  tag: {
    type: [String, Object, Function],
    required: !0
  }
}, "icon"), xu = ne()({
  name: "VComponentIcon",
  props: zr(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      const a = e.icon;
      return b(e.tag, null, {
        default: () => {
          var l;
          return [e.icon ? b(a, null, null) : (l = n.default) == null ? void 0 : l.call(n)];
        }
      });
    };
  }
}), Lc = Cn({
  name: "VSvgIcon",
  inheritAttrs: !1,
  props: zr(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => b(e.tag, Q(n, {
      style: null
    }), {
      default: () => [S("svg", {
        class: "v-icon__svg",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 24 24",
        role: "img",
        "aria-hidden": "true"
      }, [Array.isArray(e.icon) ? e.icon.map((a) => Array.isArray(a) ? S("path", {
        d: a[0],
        "fill-opacity": a[1]
      }, null) : S("path", {
        d: a
      }, null)) : S("path", {
        d: e.icon
      }, null)])]
    });
  }
}), vC = Cn({
  name: "VLigatureIcon",
  props: zr(),
  setup(e) {
    return () => b(e.tag, null, {
      default: () => [e.icon]
    });
  }
}), Fc = Cn({
  name: "VClassIcon",
  props: zr(),
  setup(e) {
    return () => b(e.tag, {
      class: le(e.icon)
    }, null);
  }
});
function mC() {
  return {
    svg: {
      component: Lc
    },
    class: {
      component: Fc
    }
  };
}
function hC(e) {
  const t = mC(), n = (e == null ? void 0 : e.defaultSet) ?? "mdi";
  return n === "mdi" && !t.mdi && (t.mdi = fC), Jt({
    defaultSet: n,
    sets: t,
    aliases: {
      ...dC,
      /* eslint-disable max-len */
      vuetify: ["M8.2241 14.2009L12 21L22 3H14.4459L8.2241 14.2009Z", ["M7.26303 12.4733L7.00113 12L2 3H12.5261C12.5261 3 12.5261 3 12.5261 3L7.26303 12.4733Z", 0.6]],
      "vuetify-outline": "svg:M7.26 12.47 12.53 3H2L7.26 12.47ZM14.45 3 8.22 14.2 12 21 22 3H14.45ZM18.6 5 12 16.88 10.51 14.2 15.62 5ZM7.26 8.35 5.4 5H9.13L7.26 8.35Z",
      "vuetify-play": ["m6.376 13.184-4.11-7.192C1.505 4.66 2.467 3 4.003 3h8.532l-.953 1.576-.006.01-.396.677c-.429.732-.214 1.507.194 2.015.404.503 1.092.878 1.869.806a3.72 3.72 0 0 1 1.005.022c.276.053.434.143.523.237.138.146.38.635-.25 2.09-.893 1.63-1.553 1.722-1.847 1.677-.213-.033-.468-.158-.756-.406a4.95 4.95 0 0 1-.8-.927c-.39-.564-1.04-.84-1.66-.846-.625-.006-1.316.27-1.693.921l-.478.826-.911 1.506Z", ["M9.093 11.552c.046-.079.144-.15.32-.148a.53.53 0 0 1 .43.207c.285.414.636.847 1.046 1.2.405.35.914.662 1.516.754 1.334.205 2.502-.698 3.48-2.495l.014-.028.013-.03c.687-1.574.774-2.852-.005-3.675-.37-.391-.861-.586-1.333-.676a5.243 5.243 0 0 0-1.447-.044c-.173.016-.393-.073-.54-.257-.145-.18-.127-.316-.082-.392l.393-.672L14.287 3h5.71c1.536 0 2.499 1.659 1.737 2.992l-7.997 13.996c-.768 1.344-2.706 1.344-3.473 0l-3.037-5.314 1.377-2.278.004-.006.004-.007.481-.831Z", 0.6]]
      /* eslint-enable max-len */
    }
  }, e);
}
const gC = (e) => {
  const t = Me(_u);
  if (!t) throw new Error("Missing Vuetify Icons provide!");
  return {
    iconData: x(() => {
      var s;
      const a = un(e);
      if (!a) return {
        component: xu
      };
      let l = a;
      if (typeof l == "string" && (l = l.trim(), l.startsWith("$") && (l = (s = t.aliases) == null ? void 0 : s[l.slice(1)])), l || vn(`Could not find aliased icon "${a}"`), Array.isArray(l))
        return {
          component: Lc,
          icon: l
        };
      if (typeof l != "string")
        return {
          component: xu,
          icon: l
        };
      const i = Object.keys(t.sets).find((d) => typeof l == "string" && l.startsWith(`${d}:`)), o = i ? l.slice(i.length + 1) : l;
      return {
        component: t.sets[i ?? t.defaultSet].component,
        icon: o
      };
    })
  };
}, Zi = Symbol.for("vuetify:theme"), We = z({
  theme: String
}, "theme");
function xv() {
  return {
    defaultTheme: "light",
    prefix: "v-",
    variations: {
      colors: [],
      lighten: 0,
      darken: 0
    },
    themes: {
      light: {
        dark: !1,
        colors: {
          background: "#FFFFFF",
          surface: "#FFFFFF",
          "surface-bright": "#FFFFFF",
          "surface-light": "#EEEEEE",
          "surface-variant": "#424242",
          "on-surface-variant": "#EEEEEE",
          primary: "#1867C0",
          "primary-darken-1": "#1F5592",
          secondary: "#48A9A6",
          "secondary-darken-1": "#018786",
          error: "#B00020",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#000000",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 0.87,
          "medium-emphasis-opacity": 0.6,
          "disabled-opacity": 0.38,
          "idle-opacity": 0.04,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.12,
          "dragged-opacity": 0.08,
          "theme-kbd": "#EEEEEE",
          "theme-on-kbd": "#000000",
          "theme-code": "#F5F5F5",
          "theme-on-code": "#000000"
        }
      },
      dark: {
        dark: !0,
        colors: {
          background: "#121212",
          surface: "#212121",
          "surface-bright": "#ccbfd6",
          "surface-light": "#424242",
          "surface-variant": "#c8c8c8",
          "on-surface-variant": "#000000",
          primary: "#2196F3",
          "primary-darken-1": "#277CC1",
          secondary: "#54B6B2",
          "secondary-darken-1": "#48A9A6",
          error: "#CF6679",
          info: "#2196F3",
          success: "#4CAF50",
          warning: "#FB8C00"
        },
        variables: {
          "border-color": "#FFFFFF",
          "border-opacity": 0.12,
          "high-emphasis-opacity": 1,
          "medium-emphasis-opacity": 0.7,
          "disabled-opacity": 0.5,
          "idle-opacity": 0.1,
          "hover-opacity": 0.04,
          "focus-opacity": 0.12,
          "selected-opacity": 0.08,
          "activated-opacity": 0.12,
          "pressed-opacity": 0.16,
          "dragged-opacity": 0.08,
          "theme-kbd": "#424242",
          "theme-on-kbd": "#FFFFFF",
          "theme-code": "#343434",
          "theme-on-code": "#CCCCCC"
        }
      }
    },
    stylesheetId: "vuetify-theme-stylesheet",
    scoped: !1,
    unimportant: !1,
    utilities: !0
  };
}
function yC() {
  var a, l;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : xv();
  const t = xv();
  if (!e) return {
    ...t,
    isDisabled: !0
  };
  const n = {};
  for (const [i, o] of Object.entries(e.themes ?? {})) {
    const r = o.dark || i === "dark" ? (a = t.themes) == null ? void 0 : a.dark : (l = t.themes) == null ? void 0 : l.light;
    n[i] = Jt(r, o);
  }
  return Jt(t, {
    ...e,
    themes: n
  });
}
function Xa(e, t, n, a) {
  e.push(`${wC(t, a)} {
`, ...n.map((l) => `  ${l};
`), `}
`);
}
function kv(e, t) {
  const n = e.dark ? 2 : 1, a = e.dark ? 1 : 2, l = [];
  for (const [i, o] of Object.entries(e.colors)) {
    const r = pn(o);
    l.push(`--${t}theme-${i}: ${r.r},${r.g},${r.b}`), i.startsWith("on-") || l.push(`--${t}theme-${i}-overlay-multiplier: ${Su(o) > 0.18 ? n : a}`);
  }
  for (const [i, o] of Object.entries(e.variables)) {
    const r = typeof o == "string" && o.startsWith("#") ? pn(o) : void 0, s = r ? `${r.r}, ${r.g}, ${r.b}` : void 0;
    l.push(`--${t}${i}: ${s ?? o}`);
  }
  return l;
}
function bC(e, t, n) {
  const a = {};
  if (n)
    for (const l of ["lighten", "darken"]) {
      const i = l === "lighten" ? tk : nk;
      for (const o of bn(n[l], 1))
        a[`${e}-${l}-${o}`] = Cg(i(pn(t), o));
    }
  return a;
}
function pC(e, t) {
  if (!t) return {};
  let n = {};
  for (const a of t.colors) {
    const l = e[a];
    l && (n = {
      ...n,
      ...bC(a, l, t)
    });
  }
  return n;
}
function SC(e) {
  const t = {};
  for (const n of Object.keys(e)) {
    if (n.startsWith("on-") || e[`on-${n}`]) continue;
    const a = `on-${n}`, l = pn(e[n]);
    t[a] = Pg(l);
  }
  return t;
}
function wC(e, t) {
  if (!t) return e;
  const n = `:where(${t})`;
  return e === ":root" ? n : `${n} ${e}`;
}
function _C(e, t, n) {
  const a = xC(e, t);
  a && (a.innerHTML = n);
}
function xC(e, t) {
  if (!qe) return null;
  let n = document.getElementById(e);
  return n || (n = document.createElement("style"), n.id = e, n.type = "text/css", t && n.setAttribute("nonce", t), document.head.appendChild(n)), n;
}
function kC(e) {
  const t = yC(e), n = fe(t.defaultTheme), a = Z(t.themes), l = fe("light"), i = x({
    get() {
      return n.value === "system" ? l.value : n.value;
    },
    set(y) {
      n.value = y;
    }
  }), o = x(() => {
    const y = {};
    for (const [_, E] of Object.entries(a.value)) {
      const k = {
        ...E.colors,
        ...pC(E.colors, t.variations)
      };
      y[_] = {
        ...E,
        colors: {
          ...k,
          ...SC(k)
        }
      };
    }
    return y;
  }), r = R(() => o.value[i.value]), s = R(() => n.value === "system"), d = x(() => {
    var k;
    const y = [], _ = t.unimportant ? "" : " !important", E = t.scoped ? t.prefix : "";
    (k = r.value) != null && k.dark && Xa(y, ":root", ["color-scheme: dark"], t.scope), Xa(y, ":root", kv(r.value, t.prefix), t.scope);
    for (const [P, A] of Object.entries(o.value))
      Xa(y, `.${t.prefix}theme--${P}`, [`color-scheme: ${A.dark ? "dark" : "normal"}`, ...kv(A, t.prefix)], t.scope);
    if (t.utilities) {
      const P = [], A = [], D = new Set(Object.values(o.value).flatMap((N) => Object.keys(N.colors)));
      for (const N of D)
        N.startsWith("on-") ? Xa(A, `.${N}`, [`color: rgb(var(--${t.prefix}theme-${N}))${_}`], t.scope) : (Xa(P, `.${E}bg-${N}`, [`--${t.prefix}theme-overlay-multiplier: var(--${t.prefix}theme-${N}-overlay-multiplier)`, `background-color: rgb(var(--${t.prefix}theme-${N}))${_}`, `color: rgb(var(--${t.prefix}theme-on-${N}))${_}`], t.scope), Xa(A, `.${E}text-${N}`, [`color: rgb(var(--${t.prefix}theme-${N}))${_}`], t.scope), Xa(A, `.${E}border-${N}`, [`--${t.prefix}border-color: var(--${t.prefix}theme-${N})`], t.scope));
      y.push(...P, ...A);
    }
    return y.map((P, A) => A === 0 ? P : `    ${P}`).join("");
  }), u = R(() => t.isDisabled ? void 0 : `${t.prefix}theme--${i.value}`), c = R(() => Object.keys(o.value));
  if (Vc) {
    let _ = function() {
      l.value = y.matches ? "dark" : "light";
    };
    var p = _;
    const y = window.matchMedia("(prefers-color-scheme: dark)");
    _(), y.addEventListener("change", _, {
      passive: !0
    }), um() && Dt(() => {
      y.removeEventListener("change", _);
    });
  }
  function f(y) {
    if (t.isDisabled) return;
    const _ = y._context.provides.usehead;
    if (_) {
      let P = function() {
        return {
          style: [{
            textContent: d.value,
            id: t.stylesheetId,
            nonce: t.cspNonce || !1
          }]
        };
      };
      var E = P;
      if (_.push) {
        const A = _.push(P);
        qe && me(d, () => {
          A.patch(P);
        });
      } else
        qe ? (_.addHeadObjs(R(P)), ut(() => _.updateDOM())) : _.addHeadObjs(P());
    } else {
      let P = function() {
        _C(t.stylesheetId, t.cspNonce, d.value);
      };
      var k = P;
      qe ? me(d, P, {
        immediate: !0
      }) : P();
    }
  }
  function v(y) {
    if (y !== "system" && !c.value.includes(y)) {
      vn(`Theme "${y}" not found on the Vuetify theme instance`);
      return;
    }
    i.value = y;
  }
  function m() {
    let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : c.value;
    const _ = y.indexOf(i.value), E = _ === -1 ? 0 : (_ + 1) % y.length;
    v(y[E]);
  }
  function h() {
    let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["light", "dark"];
    m(y);
  }
  const g = new Proxy(i, {
    get(y, _) {
      return Reflect.get(y, _);
    },
    set(y, _, E) {
      return _ === "value" && pg(`theme.global.name.value = ${E}`, `theme.change('${E}')`), Reflect.set(y, _, E);
    }
  });
  return {
    install: f,
    change: v,
    cycle: m,
    toggle: h,
    isDisabled: t.isDisabled,
    isSystem: s,
    name: i,
    themes: a,
    current: r,
    computedThemes: o,
    prefix: t.prefix,
    themeClasses: u,
    styles: d,
    global: {
      name: g,
      current: r
    }
  };
}
function Ye(e) {
  St("provideTheme");
  const t = Me(Zi, null);
  if (!t) throw new Error("Could not find Vuetify theme injection");
  const n = R(() => e.theme ?? t.name.value), a = R(() => t.themes.value[n.value]), l = R(() => t.isDisabled ? void 0 : `${t.prefix}theme--${n.value}`), i = {
    ...t,
    name: n,
    current: a,
    themeClasses: l
  };
  return at(Zi, i), i;
}
function Hc() {
  St("useTheme");
  const e = Me(Zi, null);
  if (!e) throw new Error("Could not find Vuetify theme injection");
  return e;
}
function In(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "content";
  const n = gr(), a = Z();
  if (qe) {
    const l = new ResizeObserver((i) => {
      e == null || e(i, l), i.length && (t === "content" ? a.value = i[0].contentRect : a.value = i[0].target.getBoundingClientRect());
    });
    Wt(() => {
      l.disconnect();
    }), me(() => n.el, (i, o) => {
      o && (l.unobserve(o), a.value = void 0), i && l.observe(i);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef: n,
    contentRect: vl(a)
  };
}
const Qi = Symbol.for("vuetify:layout"), Fg = Symbol.for("vuetify:layout-item"), Cv = 1e3, Hg = z({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout"), Cl = z({
  name: {
    type: String
  },
  order: {
    type: [Number, String],
    default: 0
  },
  absolute: Boolean
}, "layout-item");
function zg() {
  const e = Me(Qi);
  if (!e) throw new Error("[Vuetify] Could not find injected layout");
  return {
    getLayoutItem: e.getLayoutItem,
    mainRect: e.mainRect,
    mainStyles: e.mainStyles
  };
}
function Vl(e) {
  const t = Me(Qi);
  if (!t) throw new Error("[Vuetify] Could not find injected layout");
  const n = e.id ?? `layout-item-${Yt()}`, a = St("useLayoutItem");
  at(Fg, {
    id: n
  });
  const l = fe(!1);
  vc(() => l.value = !0), Qm(() => l.value = !1);
  const {
    layoutItemStyles: i,
    layoutItemScrimStyles: o
  } = t.register(a, {
    ...e,
    active: x(() => l.value ? !1 : e.active.value),
    id: n
  });
  return Wt(() => t.unregister(n)), {
    layoutItemStyles: i,
    layoutRect: t.layoutRect,
    layoutItemScrimStyles: o
  };
}
const CC = (e, t, n, a) => {
  let l = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const i = [{
    id: "",
    layer: {
      ...l
    }
  }];
  for (const o of e) {
    const r = t.get(o), s = n.get(o), d = a.get(o);
    if (!r || !s || !d) continue;
    const u = {
      ...l,
      [r.value]: parseInt(l[r.value], 10) + (d.value ? parseInt(s.value, 10) : 0)
    };
    i.push({
      id: o,
      layer: u
    }), l = u;
  }
  return i;
};
function jg(e) {
  const t = Me(Qi, null), n = x(() => t ? t.rootZIndex.value - 100 : Cv), a = Z([]), l = It(/* @__PURE__ */ new Map()), i = It(/* @__PURE__ */ new Map()), o = It(/* @__PURE__ */ new Map()), r = It(/* @__PURE__ */ new Map()), s = It(/* @__PURE__ */ new Map()), {
    resizeRef: d,
    contentRect: u
  } = In(), c = x(() => {
    const P = /* @__PURE__ */ new Map(), A = e.overlaps ?? [];
    for (const D of A.filter((N) => N.includes(":"))) {
      const [N, V] = D.split(":");
      if (!a.value.includes(N) || !a.value.includes(V)) continue;
      const I = l.get(N), w = l.get(V), T = i.get(N), M = i.get(V);
      !I || !w || !T || !M || (P.set(V, {
        position: I.value,
        amount: parseInt(T.value, 10)
      }), P.set(N, {
        position: w.value,
        amount: -parseInt(M.value, 10)
      }));
    }
    return P;
  }), f = x(() => {
    const P = [...new Set([...o.values()].map((D) => D.value))].sort((D, N) => D - N), A = [];
    for (const D of P) {
      const N = a.value.filter((V) => {
        var I;
        return ((I = o.get(V)) == null ? void 0 : I.value) === D;
      });
      A.push(...N);
    }
    return CC(A, l, i, r);
  }), v = x(() => !Array.from(s.values()).some((P) => P.value)), m = x(() => f.value[f.value.length - 1].layer), h = R(() => ({
    "--v-layout-left": pe(m.value.left),
    "--v-layout-right": pe(m.value.right),
    "--v-layout-top": pe(m.value.top),
    "--v-layout-bottom": pe(m.value.bottom),
    ...v.value ? void 0 : {
      transition: "none"
    }
  })), g = x(() => f.value.slice(1).map((P, A) => {
    let {
      id: D
    } = P;
    const {
      layer: N
    } = f.value[A], V = i.get(D), I = l.get(D);
    return {
      id: D,
      ...N,
      size: Number(V.value),
      position: I.value
    };
  })), p = (P) => g.value.find((A) => A.id === P), y = St("createLayout"), _ = fe(!1);
  At(() => {
    _.value = !0;
  }), at(Qi, {
    register: (P, A) => {
      let {
        id: D,
        order: N,
        position: V,
        layoutSize: I,
        elementSize: w,
        active: T,
        disableTransitions: M,
        absolute: W
      } = A;
      o.set(D, N), l.set(D, V), i.set(D, I), r.set(D, T), M && s.set(D, M);
      const ee = Ul(Fg, y == null ? void 0 : y.vnode).indexOf(P);
      ee > -1 ? a.value.splice(ee, 0, D) : a.value.push(D);
      const Y = x(() => g.value.findIndex((U) => U.id === D)), L = x(() => n.value + f.value.length * 2 - Y.value * 2), H = x(() => {
        const U = V.value === "left" || V.value === "right", F = V.value === "right", oe = V.value === "bottom", ve = w.value ?? I.value, _e = ve === 0 ? "%" : "px", B = {
          [V.value]: 0,
          zIndex: L.value,
          transform: `translate${U ? "X" : "Y"}(${(T.value ? 0 : -(ve === 0 ? 100 : ve)) * (F || oe ? -1 : 1)}${_e})`,
          position: W.value || n.value !== Cv ? "absolute" : "fixed",
          ...v.value ? void 0 : {
            transition: "none"
          }
        };
        if (!_.value) return B;
        const G = g.value[Y.value];
        G || vn(`[Vuetify] Could not find layout item "${D}"`);
        const ie = c.value.get(D);
        return ie && (G[ie.position] += ie.amount), {
          ...B,
          height: U ? `calc(100% - ${G.top}px - ${G.bottom}px)` : w.value ? `${w.value}px` : void 0,
          left: F ? void 0 : `${G.left}px`,
          right: F ? `${G.right}px` : void 0,
          top: V.value !== "bottom" ? `${G.top}px` : void 0,
          bottom: V.value !== "top" ? `${G.bottom}px` : void 0,
          width: U ? w.value ? `${w.value}px` : void 0 : `calc(100% - ${G.left}px - ${G.right}px)`
        };
      }), j = x(() => ({
        zIndex: L.value - 1
      }));
      return {
        layoutItemStyles: H,
        layoutItemScrimStyles: j,
        zIndex: L
      };
    },
    unregister: (P) => {
      o.delete(P), l.delete(P), i.delete(P), r.delete(P), s.delete(P), a.value = a.value.filter((A) => A !== P);
    },
    mainRect: m,
    mainStyles: h,
    getLayoutItem: p,
    items: g,
    layoutRect: u,
    rootZIndex: n
  });
  const E = R(() => ["v-layout", {
    "v-layout--full-height": e.fullHeight
  }]), k = R(() => ({
    zIndex: t ? n.value : void 0,
    position: t ? "relative" : void 0,
    overflow: t ? "hidden" : void 0
  }));
  return {
    layoutClasses: E,
    layoutStyles: k,
    getLayoutItem: p,
    items: g,
    layoutRect: u,
    layoutRef: d
  };
}
function Wg() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint: t,
    ...n
  } = e, a = Jt(t, n), {
    aliases: l = {},
    components: i = {},
    directives: o = {}
  } = a, r = Jl();
  return r.run(() => {
    const s = ik(a.defaults), d = oC(a.display, a.ssr), u = kC(a.theme), c = hC(a.icons), f = gk(a.locale), v = aC(a.date, f), m = sC(a.goTo, f);
    function h(p) {
      for (const _ in o)
        p.directive(_, o[_]);
      for (const _ in i)
        p.component(_, i[_]);
      for (const _ in l)
        p.component(_, Cn({
          ...l[_],
          name: _,
          aliasName: l[_].name
        }));
      const y = Jl();
      if (y.run(() => {
        u.install(p);
      }), p.onUnmount(() => y.stop()), p.provide(ii, s), p.provide(wu, d), p.provide(Zi, u), p.provide(_u, c), p.provide(oi, f), p.provide(Bg, v.options), p.provide(yv, v.instance), p.provide(Rg, m), qe && a.ssr)
        if (p.$nuxt)
          p.$nuxt.hook("app:suspense:resolve", () => {
            d.update();
          });
        else {
          const {
            mount: _
          } = p;
          p.mount = function() {
            const E = _(...arguments);
            return He(() => d.update()), p.mount = _, E;
          };
        }
      p.mixin({
        computed: {
          $vuetify() {
            return It({
              defaults: Fl.call(this, ii),
              display: Fl.call(this, wu),
              theme: Fl.call(this, Zi),
              icons: Fl.call(this, _u),
              locale: Fl.call(this, oi),
              date: Fl.call(this, yv)
            });
          }
        }
      });
    }
    function g() {
      r.stop();
    }
    return {
      install: h,
      unmount: g,
      defaults: s,
      display: d,
      theme: u,
      icons: c,
      locale: f,
      date: v,
      goTo: m
    };
  });
}
const VC = "3.10.3";
Wg.version = VC;
function Fl(e) {
  var a, l;
  const t = this.$, n = ((a = t.parent) == null ? void 0 : a.provides) ?? ((l = t.vnode.appContext) == null ? void 0 : l.provides);
  if (n && e in n)
    return n[e];
}
const EC = z({
  ...ke(),
  ...tt(Hg(), ["fullHeight"]),
  ...We()
}, "VApp"), PC = ne()({
  name: "VApp",
  props: EC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ye(e), {
      layoutClasses: l,
      getLayoutItem: i,
      items: o,
      layoutRef: r
    } = jg({
      ...e,
      fullHeight: !0
    }), {
      rtlClasses: s
    } = Et();
    return re(() => {
      var d;
      return S("div", {
        ref: r,
        class: le(["v-application", a.themeClasses.value, l.value, s.value, e.class]),
        style: he([e.style])
      }, [S("div", {
        class: "v-application__wrap"
      }, [(d = n.default) == null ? void 0 : d.call(n)])]);
    }), {
      getLayoutItem: i,
      items: o,
      theme: a
    };
  }
}), Oe = z({
  tag: {
    type: [String, Object, Function],
    default: "div"
  }
}, "tag"), Ug = z({
  text: String,
  ...ke(),
  ...Oe()
}, "VToolbarTitle"), zc = ne()({
  name: "VToolbarTitle",
  props: Ug(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      const a = !!(n.default || n.text || e.text);
      return b(e.tag, {
        class: le(["v-toolbar-title", e.class]),
        style: he(e.style)
      }, {
        default: () => {
          var l;
          return [a && S("div", {
            class: "v-toolbar-title__placeholder"
          }, [n.text ? n.text() : e.text, (l = n.default) == null ? void 0 : l.call(n)])];
        }
      });
    }), {};
  }
}), IC = z({
  disabled: Boolean,
  group: Boolean,
  hideOnLeave: Boolean,
  leaveAbsolute: Boolean,
  mode: String,
  origin: String
}, "transition");
function En(e, t, n) {
  return ne()({
    name: e,
    props: IC({
      mode: n,
      origin: t
    }),
    setup(a, l) {
      let {
        slots: i
      } = l;
      const o = {
        onBeforeEnter(r) {
          a.origin && (r.style.transformOrigin = a.origin);
        },
        onLeave(r) {
          if (a.leaveAbsolute) {
            const {
              offsetTop: s,
              offsetLeft: d,
              offsetWidth: u,
              offsetHeight: c
            } = r;
            r._transitionInitialStyles = {
              position: r.style.position,
              top: r.style.top,
              left: r.style.left,
              width: r.style.width,
              height: r.style.height
            }, r.style.position = "absolute", r.style.top = `${s}px`, r.style.left = `${d}px`, r.style.width = `${u}px`, r.style.height = `${c}px`;
          }
          a.hideOnLeave && r.style.setProperty("display", "none", "important");
        },
        onAfterLeave(r) {
          if (a.leaveAbsolute && (r != null && r._transitionInitialStyles)) {
            const {
              position: s,
              top: d,
              left: u,
              width: c,
              height: f
            } = r._transitionInitialStyles;
            delete r._transitionInitialStyles, r.style.position = s || "", r.style.top = d || "", r.style.left = u || "", r.style.width = c || "", r.style.height = f || "";
          }
        }
      };
      return () => {
        const r = a.group ? _c : Ma;
        return jn(r, {
          name: a.disabled ? "" : e,
          css: !a.disabled,
          ...a.group ? void 0 : {
            mode: a.mode
          },
          ...a.disabled ? {} : o
        }, i.default);
      };
    }
  });
}
function Gg(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return ne()({
    name: e,
    props: {
      mode: {
        type: String,
        default: n
      },
      disabled: {
        type: Boolean,
        default: aa()
      },
      group: Boolean
    },
    setup(a, l) {
      let {
        slots: i
      } = l;
      const o = a.group ? _c : Ma;
      return () => jn(o, {
        name: a.disabled ? "" : e,
        css: !a.disabled,
        // mode: props.mode, // TODO: vuejs/vue-next#3104
        ...a.disabled ? {} : t
      }, i.default);
    }
  });
}
function Kg() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1) ? "width" : "height", a = Ht(`offset-${n}`);
  return {
    onBeforeEnter(o) {
      o._parent = o.parentNode, o._initialStyle = {
        transition: o.style.transition,
        overflow: o.style.overflow,
        [n]: o.style[n]
      };
    },
    onEnter(o) {
      const r = o._initialStyle;
      if (!r) return;
      o.style.setProperty("transition", "none", "important"), o.style.overflow = "hidden";
      const s = `${o[a]}px`;
      o.style[n] = "0", o.offsetHeight, o.style.transition = r.transition, e && o._parent && o._parent.classList.add(e), requestAnimationFrame(() => {
        o.style[n] = s;
      });
    },
    onAfterEnter: i,
    onEnterCancelled: i,
    onLeave(o) {
      o._initialStyle = {
        transition: "",
        overflow: o.style.overflow,
        [n]: o.style[n]
      }, o.style.overflow = "hidden", o.style[n] = `${o[a]}px`, o.offsetHeight, requestAnimationFrame(() => o.style[n] = "0");
    },
    onAfterLeave: l,
    onLeaveCancelled: l
  };
  function l(o) {
    e && o._parent && o._parent.classList.remove(e), i(o);
  }
  function i(o) {
    if (!o._initialStyle) return;
    const r = o._initialStyle[n];
    o.style.overflow = o._initialStyle.overflow, r != null && (o.style[n] = r), delete o._initialStyle;
  }
}
const NC = z({
  target: [Object, Array]
}, "v-dialog-transition"), As = /* @__PURE__ */ new WeakMap(), jr = ne()({
  name: "VDialogTransition",
  props: NC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = {
      onBeforeEnter(l) {
        l.style.pointerEvents = "none", l.style.visibility = "hidden";
      },
      async onEnter(l, i) {
        var f;
        await new Promise((v) => requestAnimationFrame(v)), await new Promise((v) => requestAnimationFrame(v)), l.style.visibility = "";
        const o = Ev(e.target, l), {
          x: r,
          y: s,
          sx: d,
          sy: u,
          speed: c
        } = o;
        if (As.set(l, o), aa())
          ga(l, [{
            opacity: 0
          }, {}], {
            duration: 125 * c,
            easing: cv
          }).finished.then(() => i());
        else {
          const v = ga(l, [{
            transform: `translate(${r}px, ${s}px) scale(${d}, ${u})`,
            opacity: 0
          }, {}], {
            duration: 225 * c,
            easing: cv
          });
          (f = Vv(l)) == null || f.forEach((m) => {
            ga(m, [{
              opacity: 0
            }, {
              opacity: 0,
              offset: 0.33
            }, {}], {
              duration: 225 * 2 * c,
              easing: qi
            });
          }), v.finished.then(() => i());
        }
      },
      onAfterEnter(l) {
        l.style.removeProperty("pointer-events");
      },
      onBeforeLeave(l) {
        l.style.pointerEvents = "none";
      },
      async onLeave(l, i) {
        var f;
        await new Promise((v) => requestAnimationFrame(v));
        let o;
        !As.has(l) || Array.isArray(e.target) || e.target.offsetParent || e.target.getClientRects().length ? o = Ev(e.target, l) : o = As.get(l);
        const {
          x: r,
          y: s,
          sx: d,
          sy: u,
          speed: c
        } = o;
        aa() ? ga(l, [{}, {
          opacity: 0
        }], {
          duration: 85 * c,
          easing: dv
        }).finished.then(() => i()) : (ga(l, [{}, {
          transform: `translate(${r}px, ${s}px) scale(${d}, ${u})`,
          opacity: 0
        }], {
          duration: 125 * c,
          easing: dv
        }).finished.then(() => i()), (f = Vv(l)) == null || f.forEach((m) => {
          ga(m, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * c,
            easing: qi
          });
        }));
      },
      onAfterLeave(l) {
        l.style.removeProperty("pointer-events");
      }
    };
    return () => e.target ? b(Ma, Q({
      name: "dialog-transition"
    }, a, {
      css: !1
    }), n) : b(Ma, {
      name: "dialog-transition"
    }, n);
  }
});
function Vv(e) {
  var n;
  const t = (n = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : n.children;
  return t && [...t];
}
function Ev(e, t) {
  const n = bg(e), a = Nc(t), [l, i] = getComputedStyle(t).transformOrigin.split(" ").map((p) => parseFloat(p)), [o, r] = getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let s = n.left + n.width / 2;
  o === "left" || r === "left" ? s -= n.width / 2 : (o === "right" || r === "right") && (s += n.width / 2);
  let d = n.top + n.height / 2;
  o === "top" || r === "top" ? d -= n.height / 2 : (o === "bottom" || r === "bottom") && (d += n.height / 2);
  const u = n.width / a.width, c = n.height / a.height, f = Math.max(1, u, c), v = u / f || 0, m = c / f || 0, h = a.width * a.height / (window.innerWidth * window.innerHeight), g = h > 0.12 ? Math.min(1.5, (h - 0.12) * 10 + 1) : 1;
  return {
    x: s - (l + a.left),
    y: d - (i + a.top),
    sx: v,
    sy: m,
    speed: g
  };
}
const DC = En("fab-transition", "center center", "out-in"), AC = En("dialog-bottom-transition"), TC = En("dialog-top-transition"), eo = En("fade-transition"), jc = En("scale-transition"), OC = En("scroll-x-transition"), $C = En("scroll-x-reverse-transition"), BC = En("scroll-y-transition"), MC = En("scroll-y-reverse-transition"), RC = En("slide-x-transition"), LC = En("slide-x-reverse-transition"), Wc = En("slide-y-transition"), FC = En("slide-y-reverse-transition"), Wr = Gg("expand-transition", Kg()), Uc = Gg("expand-x-transition", Kg("", !0)), HC = z({
  defaults: Object,
  disabled: Boolean,
  reset: [Number, String],
  root: [Boolean, String],
  scoped: Boolean
}, "VDefaultsProvider"), Be = ne(!1)({
  name: "VDefaultsProvider",
  props: HC(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      defaults: a,
      disabled: l,
      reset: i,
      root: o,
      scoped: r
    } = ci(e);
    return gt(a, {
      reset: i,
      root: o,
      scoped: r,
      disabled: l
    }), () => {
      var s;
      return (s = n.default) == null ? void 0 : s.call(n);
    };
  }
}), kt = z({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function Ct(e) {
  return {
    dimensionStyles: x(() => {
      const n = {}, a = pe(e.height), l = pe(e.maxHeight), i = pe(e.maxWidth), o = pe(e.minHeight), r = pe(e.minWidth), s = pe(e.width);
      return a != null && (n.height = a), l != null && (n.maxHeight = l), i != null && (n.maxWidth = i), o != null && (n.minHeight = o), r != null && (n.minWidth = r), s != null && (n.width = s), n;
    })
  };
}
function zC(e) {
  return {
    aspectStyles: x(() => {
      const t = Number(e.aspectRatio);
      return t ? {
        paddingBottom: String(1 / t * 100) + "%"
      } : void 0;
    })
  };
}
const Yg = z({
  aspectRatio: [String, Number],
  contentClass: null,
  inline: Boolean,
  ...ke(),
  ...kt()
}, "VResponsive"), ku = ne()({
  name: "VResponsive",
  props: Yg(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      aspectStyles: a
    } = zC(e), {
      dimensionStyles: l
    } = Ct(e);
    return re(() => {
      var i;
      return S("div", {
        class: le(["v-responsive", {
          "v-responsive--inline": e.inline
        }, e.class]),
        style: he([l.value, e.style])
      }, [S("div", {
        class: "v-responsive__sizer",
        style: he(a.value)
      }, null), (i = n.additional) == null ? void 0 : i.call(n), n.default && S("div", {
        class: le(["v-responsive__content", e.contentClass])
      }, [n.default()])]);
    }), {};
  }
});
function Gc(e) {
  return Ic(() => {
    const {
      class: t,
      style: n
    } = jC(e);
    return {
      colorClasses: t,
      colorStyles: n
    };
  });
}
function jt(e) {
  const {
    colorClasses: t,
    colorStyles: n
  } = Gc(() => ({
    text: un(e)
  }));
  return {
    textColorClasses: t,
    textColorStyles: n
  };
}
function Xe(e) {
  const {
    colorClasses: t,
    colorStyles: n
  } = Gc(() => ({
    background: un(e)
  }));
  return {
    backgroundColorClasses: t,
    backgroundColorStyles: n
  };
}
function jC(e) {
  const t = un(e), n = [], a = {};
  if (t.background)
    if (bu(t.background)) {
      if (a.backgroundColor = t.background, !t.text && Jx(t.background)) {
        const l = pn(t.background);
        if (l.a == null || l.a === 1) {
          const i = Pg(l);
          a.color = i, a.caretColor = i;
        }
      }
    } else
      n.push(`bg-${t.background}`);
  return t.text && (bu(t.text) ? (a.color = t.text, a.caretColor = t.text) : n.push(`text-${t.text}`)), {
    class: n,
    style: a
  };
}
const ft = z({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  },
  tile: Boolean
}, "rounded");
function yt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  return {
    roundedClasses: x(() => {
      const a = mt(e) ? e.value : e.rounded, l = mt(e) ? !1 : e.tile, i = [];
      if (l || a === !1)
        i.push("rounded-0");
      else if (a === !0 || a === "")
        i.push(`${t}--rounded`);
      else if (typeof a == "string" || a === 0)
        for (const o of String(a).split(" "))
          i.push(`rounded-${o}`);
      return i;
    })
  };
}
const Wn = z({
  transition: {
    type: null,
    default: "fade-transition",
    validator: (e) => e !== !0
  }
}, "transition"), Zt = (e, t) => {
  let {
    slots: n
  } = t;
  const {
    transition: a,
    disabled: l,
    group: i,
    ...o
  } = e, {
    component: r = i ? _c : Ma,
    ...s
  } = Ki(a) ? a : {};
  let d;
  return Ki(a) ? d = Q(s, Tx({
    disabled: l,
    group: i
  }), o) : d = Q({
    name: l || !a ? "" : a
  }, o), jn(r, d, n);
};
function WC(e, t) {
  if (!Cc) return;
  const n = t.modifiers || {}, a = t.value, {
    handler: l,
    options: i
  } = typeof a == "object" ? a : {
    handler: a,
    options: {}
  }, o = new IntersectionObserver(function() {
    var c;
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], s = arguments.length > 1 ? arguments[1] : void 0;
    const d = (c = e._observe) == null ? void 0 : c[t.instance.$.uid];
    if (!d) return;
    const u = r.some((f) => f.isIntersecting);
    l && (!n.quiet || d.init) && (!n.once || u || d.init) && l(u, r, s), u && n.once ? qg(e, t) : d.init = !0;
  }, i);
  e._observe = Object(e._observe), e._observe[t.instance.$.uid] = {
    init: !1,
    observer: o
  }, o.observe(e);
}
function qg(e, t) {
  var a;
  const n = (a = e._observe) == null ? void 0 : a[t.instance.$.uid];
  n && (n.observer.unobserve(e), delete e._observe[t.instance.$.uid]);
}
const Hn = {
  mounted: WC,
  unmounted: qg
}, Xg = z({
  absolute: Boolean,
  alt: String,
  cover: Boolean,
  color: String,
  draggable: {
    type: [Boolean, String],
    default: void 0
  },
  eager: Boolean,
  gradient: String,
  lazySrc: String,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  sizes: String,
  src: {
    type: [String, Object],
    default: ""
  },
  crossorigin: String,
  referrerpolicy: String,
  srcset: String,
  position: String,
  ...Yg(),
  ...ke(),
  ...ft(),
  ...Wn()
}, "VImg"), Sa = ne()({
  name: "VImg",
  directives: {
    vIntersect: Hn
  },
  props: Xg(),
  emits: {
    loadstart: (e) => !0,
    load: (e) => !0,
    error: (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      backgroundColorClasses: l,
      backgroundColorStyles: i
    } = Xe(() => e.color), {
      roundedClasses: o
    } = yt(e), r = St("VImg"), s = fe(""), d = Z(), u = fe(e.eager ? "loading" : "idle"), c = fe(), f = fe(), v = x(() => e.src && typeof e.src == "object" ? {
      src: e.src.src,
      srcset: e.srcset || e.src.srcset,
      lazySrc: e.lazySrc || e.src.lazySrc,
      aspect: Number(e.aspectRatio || e.src.aspect || 0)
    } : {
      src: e.src,
      srcset: e.srcset,
      lazySrc: e.lazySrc,
      aspect: Number(e.aspectRatio || 0)
    }), m = x(() => v.value.aspect || c.value / f.value || 0);
    me(() => e.src, () => {
      h(u.value !== "idle");
    }), me(m, (w, T) => {
      !w && T && d.value && E(d.value);
    }), fi(() => h());
    function h(w) {
      if (!(e.eager && w) && !(Cc && !w && !e.eager)) {
        if (u.value = "loading", v.value.lazySrc) {
          const T = new Image();
          T.src = v.value.lazySrc, E(T, null);
        }
        v.value.src && He(() => {
          var T;
          n("loadstart", ((T = d.value) == null ? void 0 : T.currentSrc) || v.value.src), setTimeout(() => {
            var M;
            if (!r.isUnmounted)
              if ((M = d.value) != null && M.complete) {
                if (d.value.naturalWidth || p(), u.value === "error") return;
                m.value || E(d.value, null), u.value === "loading" && g();
              } else
                m.value || E(d.value), y();
          });
        });
      }
    }
    function g() {
      var w;
      r.isUnmounted || (y(), E(d.value), u.value = "loaded", n("load", ((w = d.value) == null ? void 0 : w.currentSrc) || v.value.src));
    }
    function p() {
      var w;
      r.isUnmounted || (u.value = "error", n("error", ((w = d.value) == null ? void 0 : w.currentSrc) || v.value.src));
    }
    function y() {
      const w = d.value;
      w && (s.value = w.currentSrc || w.src);
    }
    let _ = -1;
    Wt(() => {
      clearTimeout(_);
    });
    function E(w) {
      let T = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const M = () => {
        if (clearTimeout(_), r.isUnmounted) return;
        const {
          naturalHeight: W,
          naturalWidth: J
        } = w;
        W || J ? (c.value = J, f.value = W) : !w.complete && u.value === "loading" && T != null ? _ = window.setTimeout(M, T) : (w.currentSrc.endsWith(".svg") || w.currentSrc.startsWith("data:image/svg+xml")) && (c.value = 1, f.value = 1);
      };
      M();
    }
    const k = R(() => ({
      "v-img__img--cover": e.cover,
      "v-img__img--contain": !e.cover
    })), P = () => {
      var M;
      if (!v.value.src || u.value === "idle") return null;
      const w = S("img", {
        class: le(["v-img__img", k.value]),
        style: {
          objectPosition: e.position
        },
        crossorigin: e.crossorigin,
        src: v.value.src,
        srcset: v.value.srcset,
        alt: e.alt,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable,
        sizes: e.sizes,
        ref: d,
        onLoad: g,
        onError: p
      }, null), T = (M = a.sources) == null ? void 0 : M.call(a);
      return b(Zt, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => [dt(T ? S("picture", {
          class: "v-img__picture"
        }, [T, w]) : w, [[Nn, u.value === "loaded"]])]
      });
    }, A = () => b(Zt, {
      transition: e.transition
    }, {
      default: () => [v.value.lazySrc && u.value !== "loaded" && S("img", {
        class: le(["v-img__img", "v-img__img--preload", k.value]),
        style: {
          objectPosition: e.position
        },
        crossorigin: e.crossorigin,
        src: v.value.lazySrc,
        alt: e.alt,
        referrerpolicy: e.referrerpolicy,
        draggable: e.draggable
      }, null)]
    }), D = () => a.placeholder ? b(Zt, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [(u.value === "loading" || u.value === "error" && !a.error) && S("div", {
        class: "v-img__placeholder"
      }, [a.placeholder()])]
    }) : null, N = () => a.error ? b(Zt, {
      transition: e.transition,
      appear: !0
    }, {
      default: () => [u.value === "error" && S("div", {
        class: "v-img__error"
      }, [a.error()])]
    }) : null, V = () => e.gradient ? S("div", {
      class: "v-img__gradient",
      style: {
        backgroundImage: `linear-gradient(${e.gradient})`
      }
    }, null) : null, I = fe(!1);
    {
      const w = me(m, (T) => {
        T && (requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            I.value = !0;
          });
        }), w());
      });
    }
    return re(() => {
      const w = ku.filterProps(e);
      return dt(b(ku, Q({
        class: ["v-img", {
          "v-img--absolute": e.absolute,
          "v-img--booting": !I.value
        }, l.value, o.value, e.class],
        style: [{
          width: pe(e.width === "auto" ? c.value : e.width)
        }, i.value, e.style]
      }, w, {
        aspectRatio: m.value,
        "aria-label": e.alt,
        role: e.alt ? "img" : void 0
      }), {
        additional: () => S(ye, null, [b(P, null, null), b(A, null, null), b(V, null, null), b(D, null, null), b(N, null, null)]),
        default: a.default
      }), [[Hn, {
        handler: h,
        options: e.options
      }, null, {
        once: !0
      }]]);
    }), {
      currentSrc: s,
      image: d,
      state: u,
      naturalWidth: c,
      naturalHeight: f
    };
  }
}), cn = z({
  border: [Boolean, Number, String]
}, "border");
function hn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  return {
    borderClasses: x(() => {
      const a = e.border;
      return a === !0 || a === "" ? `${t}--border` : typeof a == "string" || a === 0 ? String(a).split(" ").map((l) => `border-${l}`) : [];
    })
  };
}
const Pt = z({
  elevation: {
    type: [Number, String],
    validator(e) {
      const t = parseInt(e);
      return !isNaN(t) && t >= 0 && // Material Design has a maximum elevation of 24
      // https://material.io/design/environment/elevation.html#default-elevations
      t <= 24;
    }
  }
}, "elevation");
function Rt(e) {
  return {
    elevationClasses: R(() => {
      const n = mt(e) ? e.value : e.elevation;
      return n == null ? [] : [`elevation-${n}`];
    })
  };
}
const UC = [null, "prominent", "default", "comfortable", "compact"], Jg = z({
  absolute: Boolean,
  collapse: Boolean,
  color: String,
  density: {
    type: String,
    default: "default",
    validator: (e) => UC.includes(e)
  },
  extended: {
    type: Boolean,
    default: null
  },
  extensionHeight: {
    type: [Number, String],
    default: 48
  },
  flat: Boolean,
  floating: Boolean,
  height: {
    type: [Number, String],
    default: 64
  },
  image: String,
  title: String,
  ...cn(),
  ...ke(),
  ...Pt(),
  ...ft(),
  ...Oe({
    tag: "header"
  }),
  ...We()
}, "VToolbar"), Cu = ne()({
  name: "VToolbar",
  props: Jg(),
  setup(e, t) {
    var v;
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: l
    } = Xe(() => e.color), {
      borderClasses: i
    } = hn(e), {
      elevationClasses: o
    } = Rt(e), {
      roundedClasses: r
    } = yt(e), {
      themeClasses: s
    } = Ye(e), {
      rtlClasses: d
    } = Et(), u = fe(e.extended === null ? !!((v = n.extension) != null && v.call(n)) : e.extended), c = x(() => parseInt(Number(e.height) + (e.density === "prominent" ? Number(e.height) : 0) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0), 10)), f = x(() => u.value ? parseInt(Number(e.extensionHeight) + (e.density === "prominent" ? Number(e.extensionHeight) : 0) - (e.density === "comfortable" ? 4 : 0) - (e.density === "compact" ? 8 : 0), 10) : 0);
    return gt({
      VBtn: {
        variant: "text"
      }
    }), re(() => {
      var p;
      const m = !!(e.title || n.title), h = !!(n.image || e.image), g = (p = n.extension) == null ? void 0 : p.call(n);
      return u.value = e.extended === null ? !!g : e.extended, b(e.tag, {
        class: le(["v-toolbar", {
          "v-toolbar--absolute": e.absolute,
          "v-toolbar--collapse": e.collapse,
          "v-toolbar--flat": e.flat,
          "v-toolbar--floating": e.floating,
          [`v-toolbar--density-${e.density}`]: !0
        }, a.value, i.value, o.value, r.value, s.value, d.value, e.class]),
        style: he([l.value, e.style])
      }, {
        default: () => [h && S("div", {
          key: "image",
          class: "v-toolbar__image"
        }, [n.image ? b(Be, {
          key: "image-defaults",
          disabled: !e.image,
          defaults: {
            VImg: {
              cover: !0,
              src: e.image
            }
          }
        }, n.image) : b(Sa, {
          key: "image-img",
          cover: !0,
          src: e.image
        }, null)]), b(Be, {
          defaults: {
            VTabs: {
              height: pe(c.value)
            }
          }
        }, {
          default: () => {
            var y, _, E;
            return [S("div", {
              class: "v-toolbar__content",
              style: {
                height: pe(c.value)
              }
            }, [n.prepend && S("div", {
              class: "v-toolbar__prepend"
            }, [(y = n.prepend) == null ? void 0 : y.call(n)]), m && b(zc, {
              key: "title",
              text: e.title
            }, {
              text: n.title
            }), (_ = n.default) == null ? void 0 : _.call(n), n.append && S("div", {
              class: "v-toolbar__append"
            }, [(E = n.append) == null ? void 0 : E.call(n)])])];
          }
        }), b(Be, {
          defaults: {
            VTabs: {
              height: pe(f.value)
            }
          }
        }, {
          default: () => [b(Wr, null, {
            default: () => [u.value && S("div", {
              class: "v-toolbar__extension",
              style: {
                height: pe(f.value)
              }
            }, [g])]
          })]
        })]
      });
    }), {
      contentHeight: c,
      extensionHeight: f
    };
  }
}), GC = z({
  scrollTarget: {
    type: String
  },
  scrollThreshold: {
    type: [String, Number],
    default: 300
  }
}, "scroll");
function KC(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    canScroll: n
  } = t;
  let a = 0, l = 0;
  const i = Z(null), o = fe(0), r = fe(0), s = fe(0), d = fe(!1), u = fe(!1), c = x(() => Number(e.scrollThreshold)), f = x(() => ot((c.value - o.value) / c.value || 0)), v = () => {
    const m = i.value;
    if (!m || n && !n.value) return;
    a = o.value, o.value = "window" in m ? m.pageYOffset : m.scrollTop;
    const h = m instanceof Window ? document.documentElement.scrollHeight : m.scrollHeight;
    if (l !== h) {
      l = h;
      return;
    }
    u.value = o.value < a, s.value = Math.abs(o.value - c.value);
  };
  return me(u, () => {
    r.value = r.value || o.value;
  }), me(d, () => {
    r.value = 0;
  }), At(() => {
    me(() => e.scrollTarget, (m) => {
      var g;
      const h = m ? document.querySelector(m) : window;
      if (!h) {
        vn(`Unable to locate element with identifier ${m}`);
        return;
      }
      h !== i.value && ((g = i.value) == null || g.removeEventListener("scroll", v), i.value = h, i.value.addEventListener("scroll", v, {
        passive: !0
      }));
    }, {
      immediate: !0
    });
  }), Wt(() => {
    var m;
    (m = i.value) == null || m.removeEventListener("scroll", v);
  }), n && me(n, v, {
    immediate: !0
  }), {
    scrollThreshold: c,
    currentScroll: o,
    currentThreshold: s,
    isScrollActive: d,
    scrollRatio: f,
    // required only for testing
    // probably can be removed
    // later (2 chars chlng)
    isScrollingUp: u,
    savedScroll: r
  };
}
function El() {
  const e = fe(!1);
  return At(() => {
    window.requestAnimationFrame(() => {
      e.value = !0;
    });
  }), {
    ssrBootStyles: R(() => e.value ? void 0 : {
      transition: "none !important"
    }),
    isBooted: vl(e)
  };
}
const YC = z({
  scrollBehavior: String,
  modelValue: {
    type: Boolean,
    default: !0
  },
  location: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ...Jg(),
  ...Cl(),
  ...GC(),
  height: {
    type: [Number, String],
    default: 64
  }
}, "VAppBar"), qC = ne()({
  name: "VAppBar",
  props: YC(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Z(), l = Ee(e, "modelValue"), i = x(() => {
      var _;
      const y = new Set(((_ = e.scrollBehavior) == null ? void 0 : _.split(" ")) ?? []);
      return {
        hide: y.has("hide"),
        fullyHide: y.has("fully-hide"),
        inverted: y.has("inverted"),
        collapse: y.has("collapse"),
        elevate: y.has("elevate"),
        fadeImage: y.has("fade-image")
        // shrink: behavior.has('shrink'),
      };
    }), o = x(() => {
      const y = i.value;
      return y.hide || y.fullyHide || y.inverted || y.collapse || y.elevate || y.fadeImage || // behavior.shrink ||
      !l.value;
    }), {
      currentScroll: r,
      scrollThreshold: s,
      isScrollingUp: d,
      scrollRatio: u
    } = KC(e, {
      canScroll: o
    }), c = R(() => i.value.hide || i.value.fullyHide), f = x(() => e.collapse || i.value.collapse && (i.value.inverted ? u.value > 0 : u.value === 0)), v = x(() => e.flat || i.value.fullyHide && !l.value || i.value.elevate && (i.value.inverted ? r.value > 0 : r.value === 0)), m = x(() => i.value.fadeImage ? i.value.inverted ? 1 - u.value : u.value : void 0), h = x(() => {
      var E, k;
      if (i.value.hide && i.value.inverted) return 0;
      const y = ((E = a.value) == null ? void 0 : E.contentHeight) ?? 0, _ = ((k = a.value) == null ? void 0 : k.extensionHeight) ?? 0;
      return c.value ? r.value < s.value || i.value.fullyHide ? y + _ : y : y + _;
    });
    Gt(() => !!e.scrollBehavior, () => {
      ut(() => {
        c.value ? i.value.inverted ? l.value = r.value > s.value : l.value = d.value || r.value < s.value : l.value = !0;
      });
    });
    const {
      ssrBootStyles: g
    } = El(), {
      layoutItemStyles: p
    } = Vl({
      id: e.name,
      order: x(() => parseInt(e.order, 10)),
      position: R(() => e.location),
      layoutSize: h,
      elementSize: fe(void 0),
      active: l,
      absolute: R(() => e.absolute)
    });
    return re(() => {
      const y = Cu.filterProps(e);
      return b(Cu, Q({
        ref: a,
        class: ["v-app-bar", {
          "v-app-bar--bottom": e.location === "bottom"
        }, e.class],
        style: [{
          ...p.value,
          "--v-toolbar-image-opacity": m.value,
          height: void 0,
          ...g.value
        }, e.style]
      }, y, {
        collapse: f.value,
        flat: v.value
      }), n);
    }), {};
  }
}), XC = [null, "default", "comfortable", "compact"], Tt = z({
  density: {
    type: String,
    default: "default",
    validator: (e) => XC.includes(e)
  }
}, "density");
function tn(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  return {
    densityClasses: R(() => `${t}--density-${e.density}`)
  };
}
const JC = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function ja(e, t) {
  return S(ye, null, [e && S("span", {
    key: "overlay",
    class: le(`${t}__overlay`)
  }, null), S("span", {
    key: "underlay",
    class: le(`${t}__underlay`)
  }, null)]);
}
const Dn = z({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (e) => JC.includes(e)
  }
}, "variant");
function Pl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  const n = R(() => {
    const {
      variant: i
    } = un(e);
    return `${t}--variant-${i}`;
  }), {
    colorClasses: a,
    colorStyles: l
  } = Gc(() => {
    const {
      variant: i,
      color: o
    } = un(e);
    return {
      [["elevated", "flat"].includes(i) ? "background" : "text"]: o
    };
  });
  return {
    colorClasses: a,
    colorStyles: l,
    variantClasses: n
  };
}
const Zg = z({
  baseColor: String,
  divided: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...cn(),
  ...ke(),
  ...Tt(),
  ...Pt(),
  ...ft(),
  ...Oe(),
  ...We(),
  ...Dn()
}, "VBtnGroup"), Vu = ne()({
  name: "VBtnGroup",
  props: Zg(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      densityClasses: l
    } = tn(e), {
      borderClasses: i
    } = hn(e), {
      elevationClasses: o
    } = Rt(e), {
      roundedClasses: r
    } = yt(e);
    gt({
      VBtn: {
        height: R(() => e.direction === "horizontal" ? "auto" : null),
        baseColor: R(() => e.baseColor),
        color: R(() => e.color),
        density: R(() => e.density),
        flat: !0,
        variant: R(() => e.variant)
      }
    }), re(() => b(e.tag, {
      class: le(["v-btn-group", `v-btn-group--${e.direction}`, {
        "v-btn-group--divided": e.divided
      }, a.value, i.value, l.value, o.value, r.value, e.class]),
      style: he(e.style)
    }, n));
  }
}), Il = z({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group"), Nl = z({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function Dl(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const a = St("useGroupItem");
  if (!a)
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  const l = Yt();
  at(Symbol.for(`${t.description}:id`), l);
  const i = Me(t, null);
  if (!i) {
    if (!n) return i;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`);
  }
  const o = R(() => e.value), r = x(() => !!(i.disabled.value || e.disabled));
  i.register({
    id: l,
    value: o,
    disabled: r
  }, a), Wt(() => {
    i.unregister(l);
  });
  const s = x(() => i.isSelected(l)), d = x(() => i.items.value[0].id === l), u = x(() => i.items.value[i.items.value.length - 1].id === l), c = x(() => s.value && [i.selectedClass.value, e.selectedClass]);
  return me(s, (f) => {
    a.emit("group:selected", {
      value: f
    });
  }, {
    flush: "sync"
  }), {
    id: l,
    isSelected: s,
    isFirst: d,
    isLast: u,
    toggle: () => i.select(l, !s.value),
    select: (f) => i.select(l, f),
    selectedClass: c,
    value: o,
    disabled: r,
    group: i
  };
}
function Wa(e, t) {
  let n = !1;
  const a = It([]), l = Ee(e, "modelValue", [], (f) => f === void 0 ? [] : Qg(a, f === null ? [null] : ht(f)), (f) => {
    const v = QC(a, f);
    return e.multiple ? v : v[0];
  }), i = St("useGroup");
  function o(f, v) {
    const m = f, h = Symbol.for(`${t.description}:id`), p = Ul(h, i == null ? void 0 : i.vnode).indexOf(v);
    bt(m.value) === void 0 && (m.value = p, m.useIndexAsValue = !0), p > -1 ? a.splice(p, 0, m) : a.push(m);
  }
  function r(f) {
    if (n) return;
    s();
    const v = a.findIndex((m) => m.id === f);
    a.splice(v, 1);
  }
  function s() {
    const f = a.find((v) => !v.disabled);
    f && e.mandatory === "force" && !l.value.length && (l.value = [f.id]);
  }
  At(() => {
    s();
  }), Wt(() => {
    n = !0;
  }), mc(() => {
    for (let f = 0; f < a.length; f++)
      a[f].useIndexAsValue && (a[f].value = f);
  });
  function d(f, v) {
    const m = a.find((h) => h.id === f);
    if (!(v && (m != null && m.disabled)))
      if (e.multiple) {
        const h = l.value.slice(), g = h.findIndex((y) => y === f), p = ~g;
        if (v = v ?? !p, p && e.mandatory && h.length <= 1 || !p && e.max != null && h.length + 1 > e.max) return;
        g < 0 && v ? h.push(f) : g >= 0 && !v && h.splice(g, 1), l.value = h;
      } else {
        const h = l.value.includes(f);
        if (e.mandatory && h || !h && !v) return;
        l.value = v ?? !h ? [f] : [];
      }
  }
  function u(f) {
    if (e.multiple && vn('This method is not supported when using "multiple" prop'), l.value.length) {
      const v = l.value[0], m = a.findIndex((p) => p.id === v);
      let h = (m + f) % a.length, g = a[h];
      for (; g.disabled && h !== m; )
        h = (h + f) % a.length, g = a[h];
      if (g.disabled) return;
      l.value = [a[h].id];
    } else {
      const v = a.find((m) => !m.disabled);
      v && (l.value = [v.id]);
    }
  }
  const c = {
    register: o,
    unregister: r,
    selected: l,
    select: d,
    disabled: R(() => e.disabled),
    prev: () => u(a.length - 1),
    next: () => u(1),
    isSelected: (f) => l.value.includes(f),
    selectedClass: R(() => e.selectedClass),
    items: R(() => a),
    getItemIndex: (f) => ZC(a, f)
  };
  return at(t, c), c;
}
function ZC(e, t) {
  const n = Qg(e, [t]);
  return n.length ? e.findIndex((a) => a.id === n[0]) : -1;
}
function Qg(e, t) {
  const n = [];
  return t.forEach((a) => {
    const l = e.find((o) => Mt(a, o.value)), i = e[a];
    (l == null ? void 0 : l.value) !== void 0 ? n.push(l.id) : i != null && i.useIndexAsValue && n.push(i.id);
  }), n;
}
function QC(e, t) {
  const n = [];
  return t.forEach((a) => {
    const l = e.findIndex((i) => i.id === a);
    if (~l) {
      const i = e[l];
      n.push(i.value !== void 0 ? i.value : l);
    }
  }), n;
}
const Kc = Symbol.for("vuetify:v-btn-toggle"), eV = z({
  ...Zg(),
  ...Il()
}, "VBtnToggle"), tV = ne()({
  name: "VBtnToggle",
  props: eV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: a,
      next: l,
      prev: i,
      select: o,
      selected: r
    } = Wa(e, Kc);
    return re(() => {
      const s = Vu.filterProps(e);
      return b(Vu, Q({
        class: ["v-btn-toggle", e.class]
      }, s, {
        style: e.style
      }), {
        default: () => {
          var d;
          return [(d = n.default) == null ? void 0 : d.call(n, {
            isSelected: a,
            next: l,
            prev: i,
            select: o,
            selected: r
          })];
        }
      });
    }), {
      next: l,
      prev: i,
      select: o
    };
  }
}), nV = ["x-small", "small", "default", "large", "x-large"], sa = z({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function vi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  return Ic(() => {
    const n = e.size;
    let a, l;
    return hr(nV, n) ? a = `${t}--size-${n}` : n && (l = {
      width: pe(n),
      height: pe(n)
    }), {
      sizeClasses: a,
      sizeStyles: l
    };
  });
}
const aV = z({
  color: String,
  disabled: Boolean,
  start: Boolean,
  end: Boolean,
  icon: Ve,
  opacity: [String, Number],
  ...ke(),
  ...sa(),
  ...Oe({
    tag: "i"
  }),
  ...We()
}, "VIcon"), Ue = ne()({
  name: "VIcon",
  props: aV(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const l = fe(), {
      themeClasses: i
    } = Hc(), {
      iconData: o
    } = gC(() => l.value || e.icon), {
      sizeClasses: r
    } = vi(e), {
      textColorClasses: s,
      textColorStyles: d
    } = jt(() => e.color);
    return re(() => {
      var f, v;
      const u = (f = a.default) == null ? void 0 : f.call(a);
      u && (l.value = (v = fg(u).filter((m) => m.type === xl && m.children && typeof m.children == "string")[0]) == null ? void 0 : v.children);
      const c = !!(n.onClick || n.onClickOnce);
      return b(o.value.component, {
        tag: e.tag,
        icon: o.value.icon,
        class: le(["v-icon", "notranslate", i.value, r.value, s.value, {
          "v-icon--clickable": c,
          "v-icon--disabled": e.disabled,
          "v-icon--start": e.start,
          "v-icon--end": e.end
        }, e.class]),
        style: he([{
          "--v-icon-opacity": e.opacity
        }, r.value ? void 0 : {
          fontSize: pe(e.size),
          height: pe(e.size),
          width: pe(e.size)
        }, d.value, e.style]),
        role: c ? "button" : void 0,
        "aria-hidden": !c,
        tabindex: c ? e.disabled ? -1 : 0 : void 0
      }, {
        default: () => [u]
      });
    }), {};
  }
});
function _o(e, t) {
  const n = Z(), a = fe(!1);
  if (Cc) {
    const l = new IntersectionObserver((i) => {
      a.value = !!i.find((o) => o.isIntersecting);
    }, t);
    Dt(() => {
      l.disconnect();
    }), me(n, (i, o) => {
      o && (l.unobserve(o), a.value = !1), i && l.observe(i);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef: n,
    isIntersecting: a
  };
}
const lV = z({
  bgColor: String,
  color: String,
  indeterminate: [Boolean, String],
  modelValue: {
    type: [Number, String],
    default: 0
  },
  rotate: {
    type: [Number, String],
    default: 0
  },
  width: {
    type: [Number, String],
    default: 4
  },
  ...ke(),
  ...sa(),
  ...Oe({
    tag: "div"
  }),
  ...We()
}, "VProgressCircular"), yl = ne()({
  name: "VProgressCircular",
  props: lV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = 20, l = 2 * Math.PI * a, i = Z(), {
      themeClasses: o
    } = Ye(e), {
      sizeClasses: r,
      sizeStyles: s
    } = vi(e), {
      textColorClasses: d,
      textColorStyles: u
    } = jt(() => e.color), {
      textColorClasses: c,
      textColorStyles: f
    } = jt(() => e.bgColor), {
      intersectionRef: v,
      isIntersecting: m
    } = _o(), {
      resizeRef: h,
      contentRect: g
    } = In(), p = R(() => ot(parseFloat(e.modelValue), 0, 100)), y = R(() => Number(e.width)), _ = R(() => s.value ? Number(e.size) : g.value ? g.value.width : Math.max(y.value, 32)), E = R(() => a / (1 - y.value / _.value) * 2), k = R(() => y.value / _.value * E.value), P = R(() => pe((100 - p.value) / 100 * l));
    return ut(() => {
      v.value = i.value, h.value = i.value;
    }), re(() => b(e.tag, {
      ref: i,
      class: le(["v-progress-circular", {
        "v-progress-circular--indeterminate": !!e.indeterminate,
        "v-progress-circular--visible": m.value,
        "v-progress-circular--disable-shrink": e.indeterminate && (e.indeterminate === "disable-shrink" || aa())
      }, o.value, r.value, d.value, e.class]),
      style: he([s.value, u.value, e.style]),
      role: "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": e.indeterminate ? void 0 : p.value
    }, {
      default: () => [S("svg", {
        style: {
          transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))`
        },
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${E.value} ${E.value}`
      }, [S("circle", {
        class: le(["v-progress-circular__underlay", c.value]),
        style: he(f.value),
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: a,
        "stroke-width": k.value,
        "stroke-dasharray": l,
        "stroke-dashoffset": 0
      }, null), S("circle", {
        class: "v-progress-circular__overlay",
        fill: "transparent",
        cx: "50%",
        cy: "50%",
        r: a,
        "stroke-width": k.value,
        "stroke-dasharray": l,
        "stroke-dashoffset": P.value
      }, null)]), n.default && S("div", {
        class: "v-progress-circular__content"
      }, [n.default({
        value: p.value
      })])]
    })), {};
  }
}), Pv = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
}, Va = z({
  location: String
}, "location");
function Al(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl: a
  } = Et();
  return {
    locationStyles: x(() => {
      if (!e.location) return {};
      const {
        side: i,
        align: o
      } = gu(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, a.value);
      function r(d) {
        return n ? n(d) : 0;
      }
      const s = {};
      return i !== "center" && (t ? s[Pv[i]] = `calc(100% - ${r(i)}px)` : s[i] = 0), o !== "center" ? t ? s[Pv[o]] = `calc(100% - ${r(o)}px)` : s[o] = 0 : (i === "center" ? s.top = s.left = "50%" : s[{
        top: "left",
        bottom: "left",
        left: "top",
        right: "top"
      }[i]] = "50%", s.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[i]), s;
    })
  };
}
const iV = z({
  chunkCount: {
    type: [Number, String],
    default: null
  },
  chunkWidth: {
    type: [Number, String],
    default: null
  },
  chunkGap: {
    type: [Number, String],
    default: 4
  }
}, "chunks");
function oV(e, t) {
  const n = R(() => !!e.chunkCount || !!e.chunkWidth), a = x(() => {
    const r = un(t);
    if (!r)
      return 0;
    if (!e.chunkCount)
      return Number(e.chunkWidth);
    const s = Number(e.chunkCount);
    return (r - Number(e.chunkGap) * (s - 1)) / s;
  }), l = R(() => Number(e.chunkGap)), i = x(() => {
    if (!n.value)
      return {};
    const r = pe(l.value), s = pe(a.value);
    return {
      maskRepeat: "repeat-x",
      maskImage: `linear-gradient(90deg, #000, #000 ${s}, transparent ${s}, transparent)`,
      maskSize: `calc(${s} + ${r}) 100%`
    };
  });
  function o(r) {
    const s = un(t);
    if (!s)
      return r;
    const d = 100 * l.value / s, u = 100 * (a.value + l.value) / s, c = Math.floor((r + d) / u);
    return ot(0, c * u - d / 2, 100);
  }
  return {
    hasChunks: n,
    chunksMaskStyles: i,
    snapValueToChunk: o
  };
}
const rV = z({
  absolute: Boolean,
  active: {
    type: Boolean,
    default: !0
  },
  bgColor: String,
  bgOpacity: [Number, String],
  bufferValue: {
    type: [Number, String],
    default: 0
  },
  bufferColor: String,
  bufferOpacity: [Number, String],
  clickable: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: 4
  },
  indeterminate: Boolean,
  max: {
    type: [Number, String],
    default: 100
  },
  modelValue: {
    type: [Number, String],
    default: 0
  },
  opacity: [Number, String],
  reverse: Boolean,
  stream: Boolean,
  striped: Boolean,
  roundedBar: Boolean,
  ...iV(),
  ...ke(),
  ...Va({
    location: "top"
  }),
  ...ft(),
  ...Oe(),
  ...We()
}, "VProgressLinear"), Ur = ne()({
  name: "VProgressLinear",
  props: rV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Z(), l = Ee(e, "modelValue"), {
      isRtl: i,
      rtlClasses: o
    } = Et(), {
      themeClasses: r
    } = Ye(e), {
      locationStyles: s
    } = Al(e), {
      textColorClasses: d,
      textColorStyles: u
    } = jt(() => e.color), {
      backgroundColorClasses: c,
      backgroundColorStyles: f
    } = Xe(() => e.bgColor || e.color), {
      backgroundColorClasses: v,
      backgroundColorStyles: m
    } = Xe(() => e.bufferColor || e.bgColor || e.color), {
      backgroundColorClasses: h,
      backgroundColorStyles: g
    } = Xe(() => e.color), {
      roundedClasses: p
    } = yt(e), {
      intersectionRef: y,
      isIntersecting: _
    } = _o(), E = x(() => parseFloat(e.max)), k = x(() => parseFloat(e.height)), P = x(() => ot(parseFloat(e.bufferValue) / E.value * 100, 0, 100)), A = x(() => ot(parseFloat(l.value) / E.value * 100, 0, 100)), D = x(() => i.value !== e.reverse), N = x(() => e.indeterminate ? "fade-transition" : "slide-x-transition"), V = fe(0), {
      hasChunks: I,
      chunksMaskStyles: w,
      snapValueToChunk: T
    } = oV(e, V);
    Gt(I, () => {
      const {
        resizeRef: ee
      } = In((Y) => V.value = Y[0].contentRect.width);
      ut(() => ee.value = a.value);
    });
    const M = x(() => I.value ? T(P.value) : P.value), W = x(() => I.value ? T(A.value) : A.value);
    function J(ee) {
      if (!y.value) return;
      const {
        left: Y,
        right: L,
        width: H
      } = y.value.getBoundingClientRect(), j = D.value ? H - ee.clientX + (L - H) : ee.clientX - Y;
      l.value = Math.round(j / H * E.value);
    }
    return ut(() => {
      y.value = a.value;
    }), re(() => b(e.tag, {
      ref: a,
      class: le(["v-progress-linear", {
        "v-progress-linear--absolute": e.absolute,
        "v-progress-linear--active": e.active && _.value,
        "v-progress-linear--reverse": D.value,
        "v-progress-linear--rounded": e.rounded,
        "v-progress-linear--rounded-bar": e.roundedBar,
        "v-progress-linear--striped": e.striped,
        "v-progress-linear--clickable": e.clickable
      }, p.value, r.value, o.value, e.class]),
      style: he([{
        bottom: e.location === "bottom" ? 0 : void 0,
        top: e.location === "top" ? 0 : void 0,
        height: e.active ? pe(k.value) : 0,
        "--v-progress-linear-height": pe(k.value),
        ...e.absolute ? s.value : {}
      }, w.value, e.style]),
      role: "progressbar",
      "aria-hidden": e.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": e.max,
      "aria-valuenow": e.indeterminate ? void 0 : Math.min(parseFloat(l.value), E.value),
      onClick: e.clickable && J
    }, {
      default: () => [e.stream && S("div", {
        key: "stream",
        class: le(["v-progress-linear__stream", d.value]),
        style: {
          ...u.value,
          [D.value ? "left" : "right"]: pe(-k.value),
          borderTop: `${pe(k.value / 2)} dotted`,
          opacity: parseFloat(e.bufferOpacity),
          top: `calc(50% - ${pe(k.value / 4)})`,
          width: pe(100 - P.value, "%"),
          "--v-progress-linear-stream-to": pe(k.value * (D.value ? 1 : -1))
        }
      }, null), S("div", {
        class: le(["v-progress-linear__background", c.value]),
        style: he([f.value, {
          opacity: parseFloat(e.bgOpacity),
          width: e.stream ? 0 : void 0
        }])
      }, null), S("div", {
        class: le(["v-progress-linear__buffer", v.value]),
        style: he([m.value, {
          opacity: parseFloat(e.bufferOpacity),
          width: pe(M.value, "%")
        }])
      }, null), b(Ma, {
        name: N.value
      }, {
        default: () => [e.indeterminate ? S("div", {
          class: "v-progress-linear__indeterminate"
        }, [["long", "short"].map((ee) => S("div", {
          key: ee,
          class: le(["v-progress-linear__indeterminate", ee, h.value]),
          style: he(g.value)
        }, null))]) : S("div", {
          class: le(["v-progress-linear__determinate", h.value]),
          style: he([g.value, {
            width: pe(W.value, "%")
          }])
        }, null)]
      }), n.default && S("div", {
        class: "v-progress-linear__content"
      }, [n.default({
        value: A.value,
        buffer: P.value
      })])]
    })), {};
  }
}), Gr = z({
  loading: [Boolean, String]
}, "loader");
function xo(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  return {
    loaderClasses: R(() => ({
      [`${t}--loading`]: e.loading
    }))
  };
}
function ko(e, t) {
  var a;
  let {
    slots: n
  } = t;
  return S("div", {
    class: le(`${e.name}__loader`)
  }, [((a = n.default) == null ? void 0 : a.call(n, {
    color: e.color,
    isActive: e.active
  })) || b(Ur, {
    absolute: e.absolute,
    active: e.active,
    color: e.color,
    height: "2",
    indeterminate: !0
  }, null)]);
}
const sV = ["static", "relative", "fixed", "absolute", "sticky"], mi = z({
  position: {
    type: String,
    validator: (
      /* istanbul ignore next */
      (e) => sV.includes(e)
    )
  }
}, "position");
function hi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  return {
    positionClasses: R(() => e.position ? `${t}--${e.position}` : void 0)
  };
}
function uV() {
  const e = St("useRoute");
  return x(() => {
    var t;
    return (t = e == null ? void 0 : e.proxy) == null ? void 0 : t.$route;
  });
}
function ey() {
  var e, t;
  return (t = (e = St("useRouter")) == null ? void 0 : e.proxy) == null ? void 0 : t.$router;
}
function Co(e, t) {
  var c, f;
  const n = ow("RouterLink"), a = R(() => !!(e.href || e.to)), l = x(() => (a == null ? void 0 : a.value) || Xf(t, "click") || Xf(e, "click"));
  if (typeof n == "string" || !("useLink" in n)) {
    const v = R(() => e.href);
    return {
      isLink: a,
      isRouterLink: R(() => !1),
      isClickable: l,
      href: v,
      linkProps: It({
        href: v
      })
    };
  }
  const i = n.useLink({
    to: R(() => e.to || ""),
    replace: R(() => e.replace)
  }), o = x(() => e.to ? i : void 0), r = uV(), s = x(() => {
    var v, m, h;
    return o.value ? e.exact ? r.value ? ((h = o.value.isExactActive) == null ? void 0 : h.value) && Mt(o.value.route.value.query, r.value.query) : ((m = o.value.isExactActive) == null ? void 0 : m.value) ?? !1 : ((v = o.value.isActive) == null ? void 0 : v.value) ?? !1 : !1;
  }), d = x(() => {
    var v;
    return e.to ? (v = o.value) == null ? void 0 : v.route.value.href : e.href;
  }), u = R(() => !!e.to);
  return {
    isLink: a,
    isRouterLink: u,
    isClickable: l,
    isActive: s,
    route: (c = o.value) == null ? void 0 : c.route,
    navigate: (f = o.value) == null ? void 0 : f.navigate,
    href: d,
    linkProps: It({
      href: d,
      "aria-current": R(() => s.value ? "page" : void 0),
      "aria-disabled": R(() => e.disabled && a.value ? "true" : void 0),
      tabindex: R(() => e.disabled && a.value ? "-1" : void 0)
    })
  };
}
const Vo = z({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let Ts = !1;
function cV(e, t) {
  let n = !1, a, l;
  qe && (e != null && e.beforeEach) && (He(() => {
    window.addEventListener("popstate", i), a = e.beforeEach((o, r, s) => {
      Ts ? n ? t(s) : s() : setTimeout(() => n ? t(s) : s()), Ts = !0;
    }), l = e == null ? void 0 : e.afterEach(() => {
      Ts = !1;
    });
  }), Dt(() => {
    window.removeEventListener("popstate", i), a == null || a(), l == null || l();
  }));
  function i(o) {
    var r;
    (r = o.state) != null && r.replaced || (n = !0, setTimeout(() => n = !1));
  }
}
function dV(e, t) {
  me(() => {
    var n;
    return (n = e.isActive) == null ? void 0 : n.value;
  }, (n) => {
    e.isLink.value && n != null && t && He(() => {
      t(n);
    });
  }, {
    immediate: !0
  });
}
const Eu = Symbol("rippleStop"), fV = 80;
function Iv(e, t) {
  e.style.transform = t, e.style.webkitTransform = t;
}
function Pu(e) {
  return e.constructor.name === "TouchEvent";
}
function ty(e) {
  return e.constructor.name === "KeyboardEvent";
}
const vV = function(e, t) {
  var c;
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = 0, l = 0;
  if (!ty(e)) {
    const f = t.getBoundingClientRect(), v = Pu(e) ? e.touches[e.touches.length - 1] : e;
    a = v.clientX - f.left, l = v.clientY - f.top;
  }
  let i = 0, o = 0.3;
  (c = t._ripple) != null && c.circle ? (o = 0.15, i = t.clientWidth / 2, i = n.center ? i : i + Math.sqrt((a - i) ** 2 + (l - i) ** 2) / 4) : i = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
  const r = `${(t.clientWidth - i * 2) / 2}px`, s = `${(t.clientHeight - i * 2) / 2}px`, d = n.center ? r : `${a - i}px`, u = n.center ? s : `${l - i}px`;
  return {
    radius: i,
    scale: o,
    x: d,
    y: u,
    centerX: r,
    centerY: s
  };
}, xr = {
  /* eslint-disable max-statements */
  show(e, t) {
    var v;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!((v = t == null ? void 0 : t._ripple) != null && v.enabled))
      return;
    const a = document.createElement("span"), l = document.createElement("span");
    a.appendChild(l), a.className = "v-ripple__container", n.class && (a.className += ` ${n.class}`);
    const {
      radius: i,
      scale: o,
      x: r,
      y: s,
      centerX: d,
      centerY: u
    } = vV(e, t, n), c = `${i * 2}px`;
    l.className = "v-ripple__animation", l.style.width = c, l.style.height = c, t.appendChild(a);
    const f = window.getComputedStyle(t);
    f && f.position === "static" && (t.style.position = "relative", t.dataset.previousPosition = "static"), l.classList.add("v-ripple__animation--enter"), l.classList.add("v-ripple__animation--visible"), Iv(l, `translate(${r}, ${s}) scale3d(${o},${o},${o})`), l.dataset.activated = String(performance.now()), requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        l.classList.remove("v-ripple__animation--enter"), l.classList.add("v-ripple__animation--in"), Iv(l, `translate(${d}, ${u}) scale3d(1,1,1)`);
      });
    });
  },
  hide(e) {
    var i;
    if (!((i = e == null ? void 0 : e._ripple) != null && i.enabled)) return;
    const t = e.getElementsByClassName("v-ripple__animation");
    if (t.length === 0) return;
    const n = Array.from(t).findLast((o) => !o.dataset.isHiding);
    if (n) n.dataset.isHiding = "true";
    else return;
    const a = performance.now() - Number(n.dataset.activated), l = Math.max(250 - a, 0);
    setTimeout(() => {
      n.classList.remove("v-ripple__animation--in"), n.classList.add("v-ripple__animation--out"), setTimeout(() => {
        var r;
        e.getElementsByClassName("v-ripple__animation").length === 1 && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition, delete e.dataset.previousPosition), ((r = n.parentNode) == null ? void 0 : r.parentNode) === e && e.removeChild(n.parentNode);
      }, 300);
    }, l);
  }
};
function ny(e) {
  return typeof e > "u" || !!e;
}
function to(e) {
  const t = {}, n = e.currentTarget;
  if (!(!(n != null && n._ripple) || n._ripple.touched || e[Eu])) {
    if (e[Eu] = !0, Pu(e))
      n._ripple.touched = !0, n._ripple.isTouch = !0;
    else if (n._ripple.isTouch) return;
    if (t.center = n._ripple.centered || ty(e), n._ripple.class && (t.class = n._ripple.class), Pu(e)) {
      if (n._ripple.showTimerCommit) return;
      n._ripple.showTimerCommit = () => {
        xr.show(e, n, t);
      }, n._ripple.showTimer = window.setTimeout(() => {
        var a;
        (a = n == null ? void 0 : n._ripple) != null && a.showTimerCommit && (n._ripple.showTimerCommit(), n._ripple.showTimerCommit = null);
      }, fV);
    } else
      xr.show(e, n, t);
  }
}
function Nv(e) {
  e[Eu] = !0;
}
function gn(e) {
  const t = e.currentTarget;
  if (t != null && t._ripple) {
    if (window.clearTimeout(t._ripple.showTimer), e.type === "touchend" && t._ripple.showTimerCommit) {
      t._ripple.showTimerCommit(), t._ripple.showTimerCommit = null, t._ripple.showTimer = window.setTimeout(() => {
        gn(e);
      });
      return;
    }
    window.setTimeout(() => {
      t._ripple && (t._ripple.touched = !1);
    }), xr.hide(t);
  }
}
function ay(e) {
  const t = e.currentTarget;
  t != null && t._ripple && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null), window.clearTimeout(t._ripple.showTimer));
}
let no = !1;
function Dv(e, t) {
  !no && t.includes(e.key) && (no = !0, to(e));
}
function ly(e) {
  no = !1, gn(e);
}
function iy(e) {
  no && (no = !1, gn(e));
}
function oy(e, t, n) {
  const {
    value: a,
    modifiers: l
  } = t, i = ny(a);
  i || xr.hide(e), e._ripple = e._ripple ?? {}, e._ripple.enabled = i, e._ripple.centered = l.center, e._ripple.circle = l.circle;
  const o = Ki(a) ? a : {};
  o.class && (e._ripple.class = o.class);
  const r = o.keys ?? ["Enter", "Space"];
  if (e._ripple.keyDownHandler = (s) => Dv(s, r), i && !n) {
    if (l.stop) {
      e.addEventListener("touchstart", Nv, {
        passive: !0
      }), e.addEventListener("mousedown", Nv);
      return;
    }
    e.addEventListener("touchstart", to, {
      passive: !0
    }), e.addEventListener("touchend", gn, {
      passive: !0
    }), e.addEventListener("touchmove", ay, {
      passive: !0
    }), e.addEventListener("touchcancel", gn), e.addEventListener("mousedown", to), e.addEventListener("mouseup", gn), e.addEventListener("mouseleave", gn), e.addEventListener("keydown", (s) => Dv(s, r)), e.addEventListener("keyup", ly), e.addEventListener("blur", iy), e.addEventListener("dragstart", gn, {
      passive: !0
    });
  } else !i && n && ry(e);
}
function ry(e) {
  var t;
  e.removeEventListener("mousedown", to), e.removeEventListener("touchstart", to), e.removeEventListener("touchend", gn), e.removeEventListener("touchmove", ay), e.removeEventListener("touchcancel", gn), e.removeEventListener("mouseup", gn), e.removeEventListener("mouseleave", gn), (t = e._ripple) != null && t.keyDownHandler && e.removeEventListener("keydown", e._ripple.keyDownHandler), e.removeEventListener("keyup", ly), e.removeEventListener("dragstart", gn), e.removeEventListener("blur", iy);
}
function mV(e, t) {
  oy(e, t, !1);
}
function hV(e) {
  ry(e), delete e._ripple;
}
function gV(e, t) {
  if (t.value === t.oldValue)
    return;
  const n = ny(t.oldValue);
  oy(e, t, n);
}
const en = {
  mounted: mV,
  unmounted: hV,
  updated: gV
}, Kr = z({
  active: {
    type: Boolean,
    default: void 0
  },
  activeColor: String,
  baseColor: String,
  symbol: {
    type: null,
    default: Kc
  },
  flat: Boolean,
  icon: [Boolean, String, Function, Object],
  prependIcon: Ve,
  appendIcon: Ve,
  block: Boolean,
  readonly: Boolean,
  slim: Boolean,
  stacked: Boolean,
  spaced: String,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...cn(),
  ...ke(),
  ...Tt(),
  ...kt(),
  ...Pt(),
  ...Nl(),
  ...Gr(),
  ...Va(),
  ...mi(),
  ...ft(),
  ...Vo(),
  ...sa(),
  ...Oe({
    tag: "button"
  }),
  ...We(),
  ...Dn({
    variant: "elevated"
  })
}, "VBtn"), Le = ne()({
  name: "VBtn",
  props: Kr(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      themeClasses: l
    } = Ye(e), {
      borderClasses: i
    } = hn(e), {
      densityClasses: o
    } = tn(e), {
      dimensionStyles: r
    } = Ct(e), {
      elevationClasses: s
    } = Rt(e), {
      loaderClasses: d
    } = xo(e), {
      locationStyles: u
    } = Al(e), {
      positionClasses: c
    } = hi(e), {
      roundedClasses: f
    } = yt(e), {
      sizeClasses: v,
      sizeStyles: m
    } = vi(e), h = Dl(e, e.symbol, !1), g = Co(e, n), p = x(() => {
      var I;
      return e.active !== void 0 ? e.active : g.isRouterLink.value ? (I = g.isActive) == null ? void 0 : I.value : h == null ? void 0 : h.isSelected.value;
    }), y = R(() => p.value ? e.activeColor ?? e.color : e.color), _ = x(() => {
      var w, T;
      return {
        color: (h == null ? void 0 : h.isSelected.value) && (!g.isLink.value || ((w = g.isActive) == null ? void 0 : w.value)) || !h || ((T = g.isActive) == null ? void 0 : T.value) ? y.value ?? e.baseColor : e.baseColor,
        variant: e.variant
      };
    }), {
      colorClasses: E,
      colorStyles: k,
      variantClasses: P
    } = Pl(_), A = x(() => (h == null ? void 0 : h.disabled.value) || e.disabled), D = R(() => e.variant === "elevated" && !(e.disabled || e.flat || e.border)), N = x(() => {
      if (!(e.value === void 0 || typeof e.value == "symbol"))
        return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value;
    });
    function V(I) {
      var w;
      A.value || g.isLink.value && (I.metaKey || I.ctrlKey || I.shiftKey || I.button !== 0 || n.target === "_blank") || (g.isLink.value ? (w = g.navigate) == null || w.call(g, I) : h == null || h.toggle());
    }
    return dV(g, h == null ? void 0 : h.select), re(() => {
      const I = g.isLink.value ? "a" : e.tag, w = !!(e.prependIcon || a.prepend), T = !!(e.appendIcon || a.append), M = !!(e.icon && e.icon !== !0);
      return dt(b(I, Q(g.linkProps, {
        type: I === "a" ? void 0 : "button",
        class: ["v-btn", h == null ? void 0 : h.selectedClass.value, {
          "v-btn--active": p.value,
          "v-btn--block": e.block,
          "v-btn--disabled": A.value,
          "v-btn--elevated": D.value,
          "v-btn--flat": e.flat,
          "v-btn--icon": !!e.icon,
          "v-btn--loading": e.loading,
          "v-btn--readonly": e.readonly,
          "v-btn--slim": e.slim,
          "v-btn--stacked": e.stacked
        }, e.spaced ? ["v-btn--spaced", `v-btn--spaced-${e.spaced}`] : [], l.value, i.value, E.value, o.value, s.value, d.value, c.value, f.value, v.value, P.value, e.class],
        style: [k.value, r.value, u.value, m.value, e.style],
        "aria-busy": e.loading ? !0 : void 0,
        disabled: A.value && I !== "a" || void 0,
        tabindex: e.loading || e.readonly ? -1 : void 0,
        onClick: V,
        value: N.value
      }), {
        default: () => {
          var W;
          return [ja(!0, "v-btn"), !e.icon && w && S("span", {
            key: "prepend",
            class: "v-btn__prepend"
          }, [a.prepend ? b(Be, {
            key: "prepend-defaults",
            disabled: !e.prependIcon,
            defaults: {
              VIcon: {
                icon: e.prependIcon
              }
            }
          }, a.prepend) : b(Ue, {
            key: "prepend-icon",
            icon: e.prependIcon
          }, null)]), S("span", {
            class: "v-btn__content",
            "data-no-activator": ""
          }, [!a.default && M ? b(Ue, {
            key: "content-icon",
            icon: e.icon
          }, null) : b(Be, {
            key: "content-defaults",
            disabled: !M,
            defaults: {
              VIcon: {
                icon: e.icon
              }
            }
          }, {
            default: () => {
              var J;
              return [((J = a.default) == null ? void 0 : J.call(a)) ?? Re(e.text)];
            }
          })]), !e.icon && T && S("span", {
            key: "append",
            class: "v-btn__append"
          }, [a.append ? b(Be, {
            key: "append-defaults",
            disabled: !e.appendIcon,
            defaults: {
              VIcon: {
                icon: e.appendIcon
              }
            }
          }, a.append) : b(Ue, {
            key: "append-icon",
            icon: e.appendIcon
          }, null)]), !!e.loading && S("span", {
            key: "loader",
            class: "v-btn__loader"
          }, [((W = a.loader) == null ? void 0 : W.call(a)) ?? b(yl, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            width: "2"
          }, null)])];
        }
      }), [[en, !A.value && e.ripple, "", {
        center: !!e.icon
      }]]);
    }), {
      group: h
    };
  }
}), yV = z({
  ...tt(Kr({
    icon: "$menu",
    variant: "text"
  }), ["spaced"])
}, "VAppBarNavIcon"), bV = ne()({
  name: "VAppBarNavIcon",
  props: yV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => b(Le, Q(e, {
      class: ["v-app-bar-nav-icon"]
    }), n)), {};
  }
}), pV = ne()({
  name: "VAppBarTitle",
  props: Ug(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => b(zc, Q(e, {
      class: "v-app-bar-title"
    }), n)), {};
  }
}), sy = Ca("v-alert-title"), SV = z({
  iconSize: [Number, String],
  iconSizes: {
    type: Array,
    default: () => [["x-small", 10], ["small", 16], ["default", 24], ["large", 28], ["x-large", 32]]
  }
}, "iconSize");
function wV(e, t) {
  return {
    iconSize: x(() => {
      const a = new Map(e.iconSizes), l = e.iconSize ?? t() ?? "default";
      return a.has(l) ? a.get(l) : l;
    })
  };
}
const _V = ["success", "info", "warning", "error"], xV = z({
  border: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["top", "end", "bottom", "start"].includes(e)
  },
  borderColor: String,
  closable: Boolean,
  closeIcon: {
    type: Ve,
    default: "$close"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  icon: {
    type: [Boolean, String, Function, Object],
    default: null
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  prominent: Boolean,
  title: String,
  text: String,
  type: {
    type: String,
    validator: (e) => _V.includes(e)
  },
  ...ke(),
  ...Tt(),
  ...kt(),
  ...Pt(),
  ...SV(),
  ...Va(),
  ...mi(),
  ...ft(),
  ...Oe(),
  ...We(),
  ...Dn({
    variant: "flat"
  })
}, "VAlert"), kV = ne()({
  name: "VAlert",
  props: xV(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const l = Ee(e, "modelValue"), i = R(() => {
      if (e.icon !== !1)
        return e.type ? e.icon ?? `$${e.type}` : e.icon;
    }), {
      iconSize: o
    } = wV(e, () => e.prominent ? 44 : void 0), {
      themeClasses: r
    } = Ye(e), {
      colorClasses: s,
      colorStyles: d,
      variantClasses: u
    } = Pl(() => ({
      color: e.color ?? e.type,
      variant: e.variant
    })), {
      densityClasses: c
    } = tn(e), {
      dimensionStyles: f
    } = Ct(e), {
      elevationClasses: v
    } = Rt(e), {
      locationStyles: m
    } = Al(e), {
      positionClasses: h
    } = hi(e), {
      roundedClasses: g
    } = yt(e), {
      textColorClasses: p,
      textColorStyles: y
    } = jt(() => e.borderColor), {
      t: _
    } = nt(), E = R(() => ({
      "aria-label": _(e.closeLabel),
      onClick(k) {
        l.value = !1, n("click:close", k);
      }
    }));
    return () => {
      const k = !!(a.prepend || i.value), P = !!(a.title || e.title), A = !!(a.close || e.closable), D = {
        density: e.density,
        icon: i.value,
        size: e.iconSize || e.prominent ? o.value : void 0
      };
      return l.value && b(e.tag, {
        class: le(["v-alert", e.border && {
          "v-alert--border": !!e.border,
          [`v-alert--border-${e.border === !0 ? "start" : e.border}`]: !0
        }, {
          "v-alert--prominent": e.prominent
        }, r.value, s.value, c.value, v.value, h.value, g.value, u.value, e.class]),
        style: he([d.value, f.value, m.value, e.style]),
        role: "alert"
      }, {
        default: () => {
          var N, V;
          return [ja(!1, "v-alert"), e.border && S("div", {
            key: "border",
            class: le(["v-alert__border", p.value]),
            style: he(y.value)
          }, null), k && S("div", {
            key: "prepend",
            class: "v-alert__prepend"
          }, [a.prepend ? b(Be, {
            key: "prepend-defaults",
            disabled: !i.value,
            defaults: {
              VIcon: {
                ...D
              }
            }
          }, a.prepend) : b(Ue, Q({
            key: "prepend-icon"
          }, D), null)]), S("div", {
            class: "v-alert__content"
          }, [P && b(sy, {
            key: "title"
          }, {
            default: () => {
              var I;
              return [((I = a.title) == null ? void 0 : I.call(a)) ?? e.title];
            }
          }), ((N = a.text) == null ? void 0 : N.call(a)) ?? e.text, (V = a.default) == null ? void 0 : V.call(a)]), a.append && S("div", {
            key: "append",
            class: "v-alert__append"
          }, [a.append()]), A && S("div", {
            key: "close",
            class: "v-alert__close"
          }, [a.close ? b(Be, {
            key: "close-defaults",
            defaults: {
              VBtn: {
                icon: e.closeIcon,
                size: "x-small",
                variant: "text"
              }
            }
          }, {
            default: () => {
              var I;
              return [(I = a.close) == null ? void 0 : I.call(a, {
                props: E.value
              })];
            }
          }) : b(Le, Q({
            key: "close-btn",
            icon: e.closeIcon,
            size: "x-small",
            variant: "text"
          }, E.value), null)])];
        }
      });
    };
  }
}), CV = z({
  start: Boolean,
  end: Boolean,
  icon: Ve,
  image: String,
  text: String,
  ...cn(),
  ...ke(),
  ...Tt(),
  ...ft(),
  ...sa(),
  ...Oe(),
  ...We(),
  ...Dn({
    variant: "flat"
  })
}, "VAvatar"), kn = ne()({
  name: "VAvatar",
  props: CV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      borderClasses: l
    } = hn(e), {
      colorClasses: i,
      colorStyles: o,
      variantClasses: r
    } = Pl(e), {
      densityClasses: s
    } = tn(e), {
      roundedClasses: d
    } = yt(e), {
      sizeClasses: u,
      sizeStyles: c
    } = vi(e);
    return re(() => b(e.tag, {
      class: le(["v-avatar", {
        "v-avatar--start": e.start,
        "v-avatar--end": e.end
      }, a.value, l.value, i.value, s.value, d.value, u.value, r.value, e.class]),
      style: he([o.value, c.value, e.style])
    }, {
      default: () => [n.default ? b(Be, {
        key: "content-defaults",
        defaults: {
          VImg: {
            cover: !0,
            src: e.image
          },
          VIcon: {
            icon: e.icon
          }
        }
      }, {
        default: () => [n.default()]
      }) : e.image ? b(Sa, {
        key: "image",
        src: e.image,
        alt: "",
        cover: !0
      }, null) : e.icon ? b(Ue, {
        key: "icon",
        icon: e.icon
      }, null) : e.text, ja(!1, "v-avatar")]
    })), {};
  }
}), VV = z({
  text: String,
  onClick: zt(),
  ...ke(),
  ...We()
}, "VLabel"), gi = ne()({
  name: "VLabel",
  props: VV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      var a;
      return S("label", {
        class: le(["v-label", {
          "v-label--clickable": !!e.onClick
        }, e.class]),
        style: he(e.style),
        onClick: e.onClick
      }, [e.text, (a = n.default) == null ? void 0 : a.call(n)]);
    }), {};
  }
}), uy = Symbol.for("vuetify:selection-control-group"), Yc = z({
  color: String,
  disabled: {
    type: Boolean,
    default: null
  },
  defaultsTarget: String,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: Ve,
  trueIcon: Ve,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: {
    type: Boolean,
    default: null
  },
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: Mt
  },
  ...ke(),
  ...Tt(),
  ...We()
}, "SelectionControlGroup"), EV = z({
  ...Yc({
    defaultsTarget: "VSelectionControl"
  })
}, "VSelectionControlGroup"), cy = ne()({
  name: "VSelectionControlGroup",
  props: EV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue"), l = Yt(), i = R(() => e.id || `v-selection-control-group-${l}`), o = R(() => e.name || i.value), r = /* @__PURE__ */ new Set();
    return at(uy, {
      modelValue: a,
      forceUpdate: () => {
        r.forEach((s) => s());
      },
      onForceUpdate: (s) => {
        r.add(s), Dt(() => {
          r.delete(s);
        });
      }
    }), gt({
      [e.defaultsTarget]: {
        color: R(() => e.color),
        disabled: R(() => e.disabled),
        density: R(() => e.density),
        error: R(() => e.error),
        inline: R(() => e.inline),
        modelValue: a,
        multiple: R(() => !!e.multiple || e.multiple == null && Array.isArray(a.value)),
        name: o,
        falseIcon: R(() => e.falseIcon),
        trueIcon: R(() => e.trueIcon),
        readonly: R(() => e.readonly),
        ripple: R(() => e.ripple),
        type: R(() => e.type),
        valueComparator: R(() => e.valueComparator)
      }
    }), re(() => {
      var s;
      return S("div", {
        class: le(["v-selection-control-group", {
          "v-selection-control-group--inline": e.inline
        }, e.class]),
        style: he(e.style),
        role: e.type === "radio" ? "radiogroup" : void 0
      }, [(s = n.default) == null ? void 0 : s.call(n)]);
    }), {};
  }
}), Yr = z({
  label: String,
  baseColor: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...ke(),
  ...Yc()
}, "VSelectionControl");
function PV(e) {
  const t = Me(uy, void 0), {
    densityClasses: n
  } = tn(e), a = Ee(e, "modelValue"), l = x(() => e.trueValue !== void 0 ? e.trueValue : e.value !== void 0 ? e.value : !0), i = x(() => e.falseValue !== void 0 ? e.falseValue : !1), o = x(() => !!e.multiple || e.multiple == null && Array.isArray(a.value)), r = x({
    get() {
      const v = t ? t.modelValue.value : a.value;
      return o.value ? ht(v).some((m) => e.valueComparator(m, l.value)) : e.valueComparator(v, l.value);
    },
    set(v) {
      if (e.readonly) return;
      const m = v ? l.value : i.value;
      let h = m;
      o.value && (h = v ? [...ht(a.value), m] : ht(a.value).filter((g) => !e.valueComparator(g, l.value))), t ? t.modelValue.value = h : a.value = h;
    }
  }), {
    textColorClasses: s,
    textColorStyles: d
  } = jt(() => {
    if (!(e.error || e.disabled))
      return r.value ? e.color : e.baseColor;
  }), {
    backgroundColorClasses: u,
    backgroundColorStyles: c
  } = Xe(() => r.value && !e.error && !e.disabled ? e.color : e.baseColor), f = x(() => r.value ? e.trueIcon : e.falseIcon);
  return {
    group: t,
    densityClasses: n,
    trueValue: l,
    falseValue: i,
    model: r,
    textColorClasses: s,
    textColorStyles: d,
    backgroundColorClasses: u,
    backgroundColorStyles: c,
    icon: f
  };
}
const La = ne()({
  name: "VSelectionControl",
  directives: {
    vRipple: en
  },
  inheritAttrs: !1,
  props: Yr(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      group: l,
      densityClasses: i,
      icon: o,
      model: r,
      textColorClasses: s,
      textColorStyles: d,
      backgroundColorClasses: u,
      backgroundColorStyles: c,
      trueValue: f
    } = PV(e), v = Yt(), m = fe(!1), h = fe(!1), g = Z(), p = R(() => e.id || `input-${v}`), y = R(() => !e.disabled && !e.readonly);
    l == null || l.onForceUpdate(() => {
      g.value && (g.value.checked = r.value);
    });
    function _(A) {
      y.value && (m.value = !0, ni(A.target, ":focus-visible") !== !1 && (h.value = !0));
    }
    function E() {
      m.value = !1, h.value = !1;
    }
    function k(A) {
      A.stopPropagation();
    }
    function P(A) {
      if (!y.value) {
        g.value && (g.value.checked = r.value);
        return;
      }
      e.readonly && l && He(() => l.forceUpdate()), r.value = A.target.checked;
    }
    return re(() => {
      var I, w;
      const A = a.label ? a.label({
        label: e.label,
        props: {
          for: p.value
        }
      }) : e.label, [D, N] = za(n), V = S("input", Q({
        ref: g,
        checked: r.value,
        disabled: !!e.disabled,
        id: p.value,
        onBlur: E,
        onFocus: _,
        onInput: P,
        "aria-disabled": !!e.disabled,
        "aria-label": e.label,
        type: e.type,
        value: f.value,
        name: e.name,
        "aria-checked": e.type === "checkbox" ? r.value : void 0
      }, N), null);
      return S("div", Q({
        class: ["v-selection-control", {
          "v-selection-control--dirty": r.value,
          "v-selection-control--disabled": e.disabled,
          "v-selection-control--error": e.error,
          "v-selection-control--focused": m.value,
          "v-selection-control--focus-visible": h.value,
          "v-selection-control--inline": e.inline
        }, i.value, e.class]
      }, D, {
        style: e.style
      }), [S("div", {
        class: le(["v-selection-control__wrapper", s.value]),
        style: he(d.value)
      }, [(I = a.default) == null ? void 0 : I.call(a, {
        backgroundColorClasses: u,
        backgroundColorStyles: c
      }), dt(S("div", {
        class: le(["v-selection-control__input"])
      }, [((w = a.input) == null ? void 0 : w.call(a, {
        model: r,
        textColorClasses: s,
        textColorStyles: d,
        backgroundColorClasses: u,
        backgroundColorStyles: c,
        inputNode: V,
        icon: o.value,
        props: {
          onFocus: _,
          onBlur: E,
          id: p.value
        }
      })) ?? S(ye, null, [o.value && b(Ue, {
        key: "icon",
        icon: o.value
      }, null), V])]), [[en, !e.disabled && !e.readonly && e.ripple, null, {
        center: !0,
        circle: !0
      }]])]), A && b(gi, {
        for: p.value,
        onClick: k
      }, {
        default: () => [A]
      })]);
    }), {
      isFocused: m,
      input: g
    };
  }
}), dy = z({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: Ve,
    default: "$checkboxIndeterminate"
  },
  ...Yr({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "VCheckboxBtn"), ia = ne()({
  name: "VCheckboxBtn",
  props: dy(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "indeterminate"), l = Ee(e, "modelValue");
    function i(s) {
      a.value && (a.value = !1);
    }
    const o = R(() => a.value ? e.indeterminateIcon : e.falseIcon), r = R(() => a.value ? e.indeterminateIcon : e.trueIcon);
    return re(() => {
      const s = tt(La.filterProps(e), ["modelValue"]);
      return b(La, Q(s, {
        modelValue: l.value,
        "onUpdate:modelValue": [(d) => l.value = d, i],
        class: ["v-checkbox-btn", e.class],
        style: e.style,
        type: "checkbox",
        falseIcon: o.value,
        trueIcon: r.value,
        "aria-checked": a.value ? "mixed" : void 0
      }), n);
    }), {};
  }
});
function fy(e) {
  const {
    t
  } = nt();
  function n(a) {
    let {
      name: l,
      color: i,
      ...o
    } = a;
    const r = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[l], s = e[`onClick:${l}`];
    function d(c) {
      c.key !== "Enter" && c.key !== " " || (c.preventDefault(), c.stopPropagation(), bo(s, new PointerEvent("click", c)));
    }
    const u = s && r ? t(`$vuetify.input.${r}`, e.label ?? "") : void 0;
    return b(Ue, Q({
      icon: e[`${l}Icon`],
      "aria-label": u,
      onClick: s,
      onKeydown: d,
      color: i
    }, o), null);
  }
  return {
    InputIcon: n
  };
}
const IV = z({
  active: Boolean,
  color: String,
  messages: {
    type: [Array, String],
    default: () => []
  },
  ...ke(),
  ...Wn({
    transition: {
      component: Wc,
      leaveAbsolute: !0,
      group: !0
    }
  })
}, "VMessages"), vy = ne()({
  name: "VMessages",
  props: IV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = x(() => ht(e.messages)), {
      textColorClasses: l,
      textColorStyles: i
    } = jt(() => e.color);
    return re(() => b(Zt, {
      transition: e.transition,
      tag: "div",
      class: le(["v-messages", l.value, e.class]),
      style: he([i.value, e.style])
    }, {
      default: () => [e.active && a.value.map((o, r) => S("div", {
        class: "v-messages__message",
        key: `${r}-${a.value}`
      }, [n.message ? n.message({
        message: o
      }) : o]))]
    })), {};
  }
}), Eo = z({
  focused: Boolean,
  "onUpdate:focused": zt()
}, "focus");
function Ea(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra();
  const n = Ee(e, "focused"), a = R(() => ({
    [`${t}--focused`]: n.value
  }));
  function l() {
    n.value = !0;
  }
  function i() {
    n.value = !1;
  }
  return {
    focusClasses: a,
    isFocused: n,
    focus: l,
    blur: i
  };
}
const my = Symbol.for("vuetify:form"), NV = z({
  disabled: Boolean,
  fastFail: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  validateOn: {
    type: String,
    default: "input"
  }
}, "form");
function DV(e) {
  const t = Ee(e, "modelValue"), n = R(() => e.disabled), a = R(() => e.readonly), l = fe(!1), i = Z([]), o = Z([]);
  async function r() {
    const u = [];
    let c = !0;
    o.value = [], l.value = !0;
    for (const f of i.value) {
      const v = await f.validate();
      if (v.length > 0 && (c = !1, u.push({
        id: f.id,
        errorMessages: v
      })), !c && e.fastFail) break;
    }
    return o.value = u, l.value = !1, {
      valid: c,
      errors: o.value
    };
  }
  function s() {
    i.value.forEach((u) => u.reset());
  }
  function d() {
    i.value.forEach((u) => u.resetValidation());
  }
  return me(i, () => {
    let u = 0, c = 0;
    const f = [];
    for (const v of i.value)
      v.isValid === !1 ? (c++, f.push({
        id: v.id,
        errorMessages: v.errorMessages
      })) : v.isValid === !0 && u++;
    o.value = f, t.value = c > 0 ? !1 : u === i.value.length ? !0 : null;
  }, {
    deep: !0,
    flush: "post"
  }), at(my, {
    register: (u) => {
      let {
        id: c,
        vm: f,
        validate: v,
        reset: m,
        resetValidation: h
      } = u;
      i.value.some((g) => g.id === c) && vn(`Duplicate input name "${c}"`), i.value.push({
        id: c,
        validate: v,
        reset: m,
        resetValidation: h,
        vm: Em(f),
        isValid: null,
        errorMessages: []
      });
    },
    unregister: (u) => {
      i.value = i.value.filter((c) => c.id !== u);
    },
    update: (u, c, f) => {
      const v = i.value.find((m) => m.id === u);
      v && (v.isValid = c, v.errorMessages = f);
    },
    isDisabled: n,
    isReadonly: a,
    isValidating: l,
    isValid: t,
    items: i,
    validateOn: R(() => e.validateOn)
  }), {
    errors: o,
    isDisabled: n,
    isReadonly: a,
    isValidating: l,
    isValid: t,
    items: i,
    validate: r,
    reset: s,
    resetValidation: d
  };
}
function yi(e) {
  const t = Me(my, null);
  return {
    ...t,
    isReadonly: x(() => !!((e == null ? void 0 : e.readonly) ?? (t == null ? void 0 : t.isReadonly.value))),
    isDisabled: x(() => !!((e == null ? void 0 : e.disabled) ?? (t == null ? void 0 : t.isDisabled.value)))
  };
}
const AV = Symbol.for("vuetify:rules");
function TV(e) {
  const t = Me(AV, null);
  if (!e) {
    if (!t)
      throw new Error("Could not find Vuetify rules injection");
    return t.aliases;
  }
  return (t == null ? void 0 : t.resolve(e)) ?? R(e);
}
const hy = z({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: {
    type: Boolean,
    default: null
  },
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...Eo()
}, "validation");
function gy(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ra(), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Yt();
  const a = Ee(e, "modelValue"), l = x(() => e.validationValue === void 0 ? a.value : e.validationValue), i = yi(e), o = TV(() => e.rules), r = Z([]), s = fe(!0), d = x(() => !!(ht(a.value === "" ? null : a.value).length || ht(l.value === "" ? null : l.value).length)), u = x(() => {
    var E;
    return (E = e.errorMessages) != null && E.length ? ht(e.errorMessages).concat(r.value).slice(0, Math.max(0, Number(e.maxErrors))) : r.value;
  }), c = x(() => {
    var P;
    let E = (e.validateOn ?? ((P = i.validateOn) == null ? void 0 : P.value)) || "input";
    E === "lazy" && (E = "input lazy"), E === "eager" && (E = "input eager");
    const k = new Set((E == null ? void 0 : E.split(" ")) ?? []);
    return {
      input: k.has("input"),
      blur: k.has("blur") || k.has("input") || k.has("invalid-input"),
      invalidInput: k.has("invalid-input"),
      lazy: k.has("lazy"),
      eager: k.has("eager")
    };
  }), f = x(() => {
    var E;
    return e.error || (E = e.errorMessages) != null && E.length ? !1 : e.rules.length ? s.value ? r.value.length || c.value.lazy ? null : !0 : !r.value.length : !0;
  }), v = fe(!1), m = x(() => ({
    [`${t}--error`]: f.value === !1,
    [`${t}--dirty`]: d.value,
    [`${t}--disabled`]: i.isDisabled.value,
    [`${t}--readonly`]: i.isReadonly.value
  })), h = St("validation"), g = x(() => e.name ?? bt(n));
  fi(() => {
    var E;
    (E = i.register) == null || E.call(i, {
      id: g.value,
      vm: h,
      validate: _,
      reset: p,
      resetValidation: y
    });
  }), Wt(() => {
    var E;
    (E = i.unregister) == null || E.call(i, g.value);
  }), At(async () => {
    var E;
    c.value.lazy || await _(!c.value.eager), (E = i.update) == null || E.call(i, g.value, f.value, u.value);
  }), Gt(() => c.value.input || c.value.invalidInput && f.value === !1, () => {
    me(l, () => {
      if (l.value != null)
        _();
      else if (e.focused) {
        const E = me(() => e.focused, (k) => {
          k || _(), E();
        });
      }
    });
  }), Gt(() => c.value.blur, () => {
    me(() => e.focused, (E) => {
      E || _();
    });
  }), me([f, u], () => {
    var E;
    (E = i.update) == null || E.call(i, g.value, f.value, u.value);
  });
  async function p() {
    a.value = null, await He(), await y();
  }
  async function y() {
    s.value = !0, c.value.lazy ? r.value = [] : await _(!c.value.eager);
  }
  async function _() {
    let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const k = [];
    v.value = !0;
    for (const P of o.value) {
      if (k.length >= Number(e.maxErrors ?? 1))
        break;
      const D = await (typeof P == "function" ? P : () => P)(l.value);
      if (D !== !0) {
        if (D !== !1 && typeof D != "string") {
          console.warn(`${D} is not a valid value. Rule functions must return boolean true or a string.`);
          continue;
        }
        k.push(D || "");
      }
    }
    return r.value = k, v.value = !1, s.value = E, r.value;
  }
  return {
    errorMessages: u,
    isDirty: d,
    isDisabled: i.isDisabled,
    isReadonly: i.isReadonly,
    isPristine: s,
    isValid: f,
    isValidating: v,
    reset: p,
    resetValidation: y,
    validate: _,
    validationClasses: m
  };
}
const Pa = z({
  id: String,
  appendIcon: Ve,
  baseColor: String,
  centerAffix: {
    type: Boolean,
    default: !0
  },
  color: String,
  glow: Boolean,
  iconColor: [Boolean, String],
  prependIcon: Ve,
  hideDetails: [Boolean, String],
  hideSpinButtons: Boolean,
  hint: String,
  persistentHint: Boolean,
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["horizontal", "vertical"].includes(e)
  },
  "onClick:prepend": zt(),
  "onClick:append": zt(),
  ...ke(),
  ...Tt(),
  ...mn(kt(), ["maxWidth", "minWidth", "width"]),
  ...We(),
  ...hy()
}, "VInput"), Kt = ne()({
  name: "VInput",
  props: {
    ...Pa()
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a,
      emit: l
    } = t;
    const {
      densityClasses: i
    } = tn(e), {
      dimensionStyles: o
    } = Ct(e), {
      themeClasses: r
    } = Ye(e), {
      rtlClasses: s
    } = Et(), {
      InputIcon: d
    } = fy(e), u = Yt(), c = x(() => e.id || `input-${u}`), {
      errorMessages: f,
      isDirty: v,
      isDisabled: m,
      isReadonly: h,
      isPristine: g,
      isValid: p,
      isValidating: y,
      reset: _,
      resetValidation: E,
      validate: k,
      validationClasses: P
    } = gy(e, "v-input", c), A = x(() => {
      var M;
      return (M = e.errorMessages) != null && M.length || !g.value && f.value.length ? f.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages;
    }), D = R(() => A.value.length > 0), N = R(() => !e.hideDetails || e.hideDetails === "auto" && (D.value || !!a.details)), V = x(() => N.value ? `${c.value}-messages` : void 0), I = x(() => ({
      id: c,
      messagesId: V,
      isDirty: v,
      isDisabled: m,
      isReadonly: h,
      isPristine: g,
      isValid: p,
      isValidating: y,
      hasDetails: N,
      reset: _,
      resetValidation: E,
      validate: k
    })), w = R(() => e.error || e.disabled ? void 0 : e.focused ? e.color : e.baseColor), T = R(() => {
      if (e.iconColor)
        return e.iconColor === !0 ? w.value : e.iconColor;
    });
    return re(() => {
      var J, ee, Y, L;
      const M = !!(a.prepend || e.prependIcon), W = !!(a.append || e.appendIcon);
      return S("div", {
        class: le(["v-input", `v-input--${e.direction}`, {
          "v-input--center-affix": e.centerAffix,
          "v-input--focused": e.focused,
          "v-input--glow": e.glow,
          "v-input--hide-spin-buttons": e.hideSpinButtons
        }, i.value, r.value, s.value, P.value, e.class]),
        style: he([o.value, e.style])
      }, [M && S("div", {
        key: "prepend",
        class: "v-input__prepend"
      }, [(J = a.prepend) == null ? void 0 : J.call(a, I.value), e.prependIcon && b(d, {
        key: "prepend-icon",
        name: "prepend",
        color: T.value
      }, null)]), a.default && S("div", {
        class: "v-input__control"
      }, [(ee = a.default) == null ? void 0 : ee.call(a, I.value)]), W && S("div", {
        key: "append",
        class: "v-input__append"
      }, [e.appendIcon && b(d, {
        key: "append-icon",
        name: "append",
        color: T.value
      }, null), (Y = a.append) == null ? void 0 : Y.call(a, I.value)]), N.value && S("div", {
        id: V.value,
        class: "v-input__details",
        role: "alert",
        "aria-live": "polite"
      }, [b(vy, {
        active: D.value,
        messages: A.value
      }, {
        message: a.message
      }), (L = a.details) == null ? void 0 : L.call(a, I.value)])]);
    }), {
      reset: _,
      resetValidation: E,
      validate: k,
      isValid: p,
      errorMessages: f
    };
  }
}), Os = Symbol("Forwarded refs");
function $s(e, t) {
  let n = e;
  for (; n; ) {
    const a = Reflect.getOwnPropertyDescriptor(n, t);
    if (a) return a;
    n = Object.getPrototypeOf(n);
  }
}
function Lt(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), a = 1; a < t; a++)
    n[a - 1] = arguments[a];
  return e[Os] = n, new Proxy(e, {
    get(l, i) {
      if (Reflect.has(l, i))
        return Reflect.get(l, i);
      if (!(typeof i == "symbol" || i.startsWith("$") || i.startsWith("__"))) {
        for (const o of n)
          if (o.value && Reflect.has(o.value, i)) {
            const r = Reflect.get(o.value, i);
            return typeof r == "function" ? r.bind(o.value) : r;
          }
      }
    },
    has(l, i) {
      if (Reflect.has(l, i))
        return !0;
      if (typeof i == "symbol" || i.startsWith("$") || i.startsWith("__")) return !1;
      for (const o of n)
        if (o.value && Reflect.has(o.value, i))
          return !0;
      return !1;
    },
    set(l, i, o) {
      if (Reflect.has(l, i))
        return Reflect.set(l, i, o);
      if (typeof i == "symbol" || i.startsWith("$") || i.startsWith("__")) return !1;
      for (const r of n)
        if (r.value && Reflect.has(r.value, i))
          return Reflect.set(r.value, i, o);
      return !1;
    },
    getOwnPropertyDescriptor(l, i) {
      var r;
      const o = Reflect.getOwnPropertyDescriptor(l, i);
      if (o) return o;
      if (!(typeof i == "symbol" || i.startsWith("$") || i.startsWith("__"))) {
        for (const s of n) {
          if (!s.value) continue;
          const d = $s(s.value, i) ?? ("_" in s.value ? $s((r = s.value._) == null ? void 0 : r.setupState, i) : void 0);
          if (d) return d;
        }
        for (const s of n) {
          const d = s.value && s.value[Os];
          if (!d) continue;
          const u = d.slice();
          for (; u.length; ) {
            const c = u.shift(), f = $s(c.value, i);
            if (f) return f;
            const v = c.value && c.value[Os];
            v && u.push(...v);
          }
        }
      }
    }
  });
}
const OV = z({
  ...Pa(),
  ...tt(dy(), ["inline"])
}, "VCheckbox"), $V = ne()({
  name: "VCheckbox",
  inheritAttrs: !1,
  props: OV(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:focused": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const l = Ee(e, "modelValue"), {
      isFocused: i,
      focus: o,
      blur: r
    } = Ea(e), s = Z(), d = Yt();
    return re(() => {
      const [u, c] = za(n), f = Kt.filterProps(e), v = ia.filterProps(e);
      return b(Kt, Q({
        ref: s,
        class: ["v-checkbox", e.class]
      }, u, f, {
        modelValue: l.value,
        "onUpdate:modelValue": (m) => l.value = m,
        id: e.id || `checkbox-${d}`,
        focused: i.value,
        style: e.style
      }), {
        ...a,
        default: (m) => {
          let {
            id: h,
            messagesId: g,
            isDisabled: p,
            isReadonly: y,
            isValid: _
          } = m;
          return b(ia, Q(v, {
            id: h.value,
            "aria-describedby": g.value,
            disabled: p.value,
            readonly: y.value
          }, c, {
            error: _.value === !1,
            modelValue: l.value,
            "onUpdate:modelValue": (E) => l.value = E,
            onFocus: o,
            onBlur: r
          }), a);
        }
      });
    }), Lt({}, s);
  }
});
function BV(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isRtl: a,
    isHorizontal: l
  } = e;
  const i = ao(l, n), o = yy(l, a, n), r = ao(l, t), s = by(l, t), d = r * 0.4;
  return o > s ? s - d : o + i < s + r ? s - i + r + d : o;
}
function MV(e) {
  let {
    selectedElement: t,
    containerElement: n,
    isHorizontal: a
  } = e;
  const l = ao(a, n), i = by(a, t), o = ao(a, t);
  return i - l / 2 + o / 2;
}
function Av(e, t) {
  const n = e ? "scrollWidth" : "scrollHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function RV(e, t) {
  const n = e ? "clientWidth" : "clientHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function yy(e, t, n) {
  if (!n)
    return 0;
  const {
    scrollLeft: a,
    offsetWidth: l,
    scrollWidth: i
  } = n;
  return e ? t ? i - l + a : a : n.scrollTop;
}
function ao(e, t) {
  const n = e ? "offsetWidth" : "offsetHeight";
  return (t == null ? void 0 : t[n]) || 0;
}
function by(e, t) {
  const n = e ? "offsetLeft" : "offsetTop";
  return (t == null ? void 0 : t[n]) || 0;
}
const py = Symbol.for("vuetify:v-slide-group"), qc = z({
  centerActive: Boolean,
  contentClass: null,
  direction: {
    type: String,
    default: "horizontal"
  },
  symbol: {
    type: null,
    default: py
  },
  nextIcon: {
    type: Ve,
    default: "$next"
  },
  prevIcon: {
    type: Ve,
    default: "$prev"
  },
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || ["always", "desktop", "mobile"].includes(e)
  },
  ...ke(),
  ...kl({
    mobile: null
  }),
  ...Oe(),
  ...Il({
    selectedClass: "v-slide-group-item--active"
  })
}, "VSlideGroup"), lo = ne()({
  name: "VSlideGroup",
  props: qc(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isRtl: a
    } = Et(), {
      displayClasses: l,
      mobile: i
    } = Vn(e), o = Wa(e, e.symbol), r = fe(!1), s = fe(0), d = fe(0), u = fe(0), c = x(() => e.direction === "horizontal"), {
      resizeRef: f,
      contentRect: v
    } = In(), {
      resizeRef: m,
      contentRect: h
    } = In(), g = uC(), p = x(() => ({
      container: f.el,
      duration: 200,
      easing: "easeOutQuart"
    })), y = x(() => o.selected.value.length ? o.items.value.findIndex((U) => U.id === o.selected.value[0]) : -1), _ = x(() => o.selected.value.length ? o.items.value.findIndex((U) => U.id === o.selected.value[o.selected.value.length - 1]) : -1);
    if (qe) {
      let U = -1;
      me(() => [o.selected.value, v.value, h.value, c.value], () => {
        cancelAnimationFrame(U), U = requestAnimationFrame(() => {
          if (v.value && h.value) {
            const F = c.value ? "width" : "height";
            d.value = v.value[F], u.value = h.value[F], r.value = d.value + 1 < u.value;
          }
          if (y.value >= 0 && m.el) {
            const F = m.el.children[_.value];
            k(F, e.centerActive);
          }
        });
      });
    }
    const E = fe(!1);
    function k(U, F) {
      let oe = 0;
      F ? oe = MV({
        containerElement: f.el,
        isHorizontal: c.value,
        selectedElement: U
      }) : oe = BV({
        containerElement: f.el,
        isHorizontal: c.value,
        isRtl: a.value,
        selectedElement: U
      }), P(oe);
    }
    function P(U) {
      if (!qe || !f.el) return;
      const F = ao(c.value, f.el), oe = yy(c.value, a.value, f.el);
      if (!(Av(c.value, f.el) <= F || // Prevent scrolling by only a couple of pixels, which doesn't look smooth
      Math.abs(U - oe) < 16)) {
        if (c.value && a.value && f.el) {
          const {
            scrollWidth: _e,
            offsetWidth: B
          } = f.el;
          U = _e - B - U;
        }
        c.value ? g.horizontal(U, p.value) : g(U, p.value);
      }
    }
    function A(U) {
      const {
        scrollTop: F,
        scrollLeft: oe
      } = U.target;
      s.value = c.value ? oe : F;
    }
    function D(U) {
      if (E.value = !0, !(!r.value || !m.el)) {
        for (const F of U.composedPath())
          for (const oe of m.el.children)
            if (oe === F) {
              k(oe);
              return;
            }
      }
    }
    function N(U) {
      E.value = !1;
    }
    let V = !1;
    function I(U) {
      var F;
      !V && !E.value && !(U.relatedTarget && ((F = m.el) != null && F.contains(U.relatedTarget))) && W(), V = !1;
    }
    function w() {
      V = !0;
    }
    function T(U) {
      if (!m.el) return;
      function F(oe) {
        U.preventDefault(), W(oe);
      }
      c.value ? U.key === "ArrowRight" ? F(a.value ? "prev" : "next") : U.key === "ArrowLeft" && F(a.value ? "next" : "prev") : U.key === "ArrowDown" ? F("next") : U.key === "ArrowUp" && F("prev"), U.key === "Home" ? F("first") : U.key === "End" && F("last");
    }
    function M(U, F) {
      if (!U) return;
      let oe = U;
      do
        oe = oe == null ? void 0 : oe[F === "next" ? "nextElementSibling" : "previousElementSibling"];
      while (oe != null && oe.hasAttribute("disabled"));
      return oe;
    }
    function W(U) {
      if (!m.el) return;
      let F;
      if (!U)
        F = Yi(m.el)[0];
      else if (U === "next") {
        if (F = M(m.el.querySelector(":focus"), U), !F) return W("first");
      } else if (U === "prev") {
        if (F = M(m.el.querySelector(":focus"), U), !F) return W("last");
      } else U === "first" ? (F = m.el.firstElementChild, F != null && F.hasAttribute("disabled") && (F = M(F, "next"))) : U === "last" && (F = m.el.lastElementChild, F != null && F.hasAttribute("disabled") && (F = M(F, "prev")));
      F && F.focus({
        preventScroll: !0
      });
    }
    function J(U) {
      const F = c.value && a.value ? -1 : 1, oe = (U === "prev" ? -F : F) * d.value;
      let ve = s.value + oe;
      if (c.value && a.value && f.el) {
        const {
          scrollWidth: _e,
          offsetWidth: B
        } = f.el;
        ve += _e - B;
      }
      P(ve);
    }
    const ee = x(() => ({
      next: o.next,
      prev: o.prev,
      select: o.select,
      isSelected: o.isSelected
    })), Y = x(() => r.value || Math.abs(s.value) > 0), L = x(() => {
      switch (e.showArrows) {
        case "always":
          return !0;
        case "desktop":
          return !i.value;
        case !0:
          return Y.value;
        case "mobile":
          return i.value || Y.value;
        default:
          return !i.value && Y.value;
      }
    }), H = x(() => Math.abs(s.value) > 1), j = x(() => {
      if (!f.value || !Y.value) return !1;
      const U = Av(c.value, f.el), F = RV(c.value, f.el);
      return U - F - Math.abs(s.value) > 1;
    });
    return re(() => b(e.tag, {
      class: le(["v-slide-group", {
        "v-slide-group--vertical": !c.value,
        "v-slide-group--has-affixes": L.value,
        "v-slide-group--is-overflowing": r.value
      }, l.value, e.class]),
      style: he(e.style),
      tabindex: E.value || o.selected.value.length ? -1 : 0,
      onFocus: I
    }, {
      default: () => {
        var U, F, oe;
        return [L.value && S("div", {
          key: "prev",
          class: le(["v-slide-group__prev", {
            "v-slide-group__prev--disabled": !H.value
          }]),
          onMousedown: w,
          onClick: () => H.value && J("prev")
        }, [((U = n.prev) == null ? void 0 : U.call(n, ee.value)) ?? b(eo, null, {
          default: () => [b(Ue, {
            icon: a.value ? e.nextIcon : e.prevIcon
          }, null)]
        })]), S("div", {
          key: "container",
          ref: f,
          class: le(["v-slide-group__container", e.contentClass]),
          onScroll: A
        }, [S("div", {
          ref: m,
          class: "v-slide-group__content",
          onFocusin: D,
          onFocusout: N,
          onKeydown: T
        }, [(F = n.default) == null ? void 0 : F.call(n, ee.value)])]), L.value && S("div", {
          key: "next",
          class: le(["v-slide-group__next", {
            "v-slide-group__next--disabled": !j.value
          }]),
          onMousedown: w,
          onClick: () => j.value && J("next")
        }, [((oe = n.next) == null ? void 0 : oe.call(n, ee.value)) ?? b(eo, null, {
          default: () => [b(Ue, {
            icon: a.value ? e.prevIcon : e.nextIcon
          }, null)]
        })])];
      }
    })), {
      selected: o.selected,
      scrollTo: J,
      scrollOffset: s,
      focus: W,
      hasPrev: H,
      hasNext: j
    };
  }
}), Sy = Symbol.for("vuetify:v-chip-group"), LV = z({
  baseColor: String,
  column: Boolean,
  filter: Boolean,
  valueComparator: {
    type: Function,
    default: Mt
  },
  ...qc(),
  ...ke(),
  ...Il({
    selectedClass: "v-chip--selected"
  }),
  ...Oe(),
  ...We(),
  ...Dn({
    variant: "tonal"
  })
}, "VChipGroup"), FV = ne()({
  name: "VChipGroup",
  props: LV(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      isSelected: l,
      select: i,
      next: o,
      prev: r,
      selected: s
    } = Wa(e, Sy);
    return gt({
      VChip: {
        baseColor: R(() => e.baseColor),
        color: R(() => e.color),
        disabled: R(() => e.disabled),
        filter: R(() => e.filter),
        variant: R(() => e.variant)
      }
    }), re(() => {
      const d = lo.filterProps(e);
      return b(lo, Q(d, {
        class: ["v-chip-group", {
          "v-chip-group--column": e.column
        }, a.value, e.class],
        style: e.style
      }), {
        default: () => {
          var u;
          return [(u = n.default) == null ? void 0 : u.call(n, {
            isSelected: l,
            select: i,
            next: o,
            prev: r,
            selected: s.value
          })];
        }
      });
    }), {};
  }
}), HV = z({
  activeClass: String,
  appendAvatar: String,
  appendIcon: Ve,
  baseColor: String,
  closable: Boolean,
  closeIcon: {
    type: Ve,
    default: "$delete"
  },
  closeLabel: {
    type: String,
    default: "$vuetify.close"
  },
  draggable: Boolean,
  filter: Boolean,
  filterIcon: {
    type: Ve,
    default: "$complete"
  },
  label: Boolean,
  link: {
    type: Boolean,
    default: void 0
  },
  pill: Boolean,
  prependAvatar: String,
  prependIcon: Ve,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  modelValue: {
    type: Boolean,
    default: !0
  },
  onClick: zt(),
  onClickOnce: zt(),
  ...cn(),
  ...ke(),
  ...Tt(),
  ...Pt(),
  ...Nl(),
  ...ft(),
  ...Vo(),
  ...sa(),
  ...Oe({
    tag: "span"
  }),
  ...We(),
  ...Dn({
    variant: "tonal"
  })
}, "VChip"), bi = ne()({
  name: "VChip",
  directives: {
    vRipple: en
  },
  props: HV(),
  emits: {
    "click:close": (e) => !0,
    "update:modelValue": (e) => !0,
    "group:selected": (e) => !0,
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: l
    } = t;
    const {
      t: i
    } = nt(), {
      borderClasses: o
    } = hn(e), {
      densityClasses: r
    } = tn(e), {
      elevationClasses: s
    } = Rt(e), {
      roundedClasses: d
    } = yt(e), {
      sizeClasses: u
    } = vi(e), {
      themeClasses: c
    } = Ye(e), f = Ee(e, "modelValue"), v = Dl(e, Sy, !1), m = Co(e, n), h = R(() => e.link !== !1 && m.isLink.value), g = x(() => !e.disabled && e.link !== !1 && (!!v || e.link || m.isClickable.value)), p = R(() => ({
      "aria-label": i(e.closeLabel),
      disabled: e.disabled,
      onClick(A) {
        A.preventDefault(), A.stopPropagation(), f.value = !1, a("click:close", A);
      }
    })), {
      colorClasses: y,
      colorStyles: _,
      variantClasses: E
    } = Pl(() => ({
      color: !v || v.isSelected.value ? e.color ?? e.baseColor : e.baseColor,
      variant: e.variant
    }));
    function k(A) {
      var D;
      a("click", A), g.value && ((D = m.navigate) == null || D.call(m, A), v == null || v.toggle());
    }
    function P(A) {
      (A.key === "Enter" || A.key === " ") && (A.preventDefault(), k(A));
    }
    return () => {
      var M;
      const A = m.isLink.value ? "a" : e.tag, D = !!(e.appendIcon || e.appendAvatar), N = !!(D || l.append), V = !!(l.close || e.closable), I = !!(l.filter || e.filter) && v, w = !!(e.prependIcon || e.prependAvatar), T = !!(w || l.prepend);
      return f.value && dt(b(A, Q(m.linkProps, {
        class: ["v-chip", {
          "v-chip--disabled": e.disabled,
          "v-chip--label": e.label,
          "v-chip--link": g.value,
          "v-chip--filter": I,
          "v-chip--pill": e.pill,
          [`${e.activeClass}`]: e.activeClass && ((M = m.isActive) == null ? void 0 : M.value)
        }, c.value, o.value, y.value, r.value, s.value, d.value, u.value, E.value, v == null ? void 0 : v.selectedClass.value, e.class],
        style: [_.value, e.style],
        disabled: e.disabled || void 0,
        draggable: e.draggable,
        tabindex: g.value ? 0 : void 0,
        onClick: k,
        onKeydown: g.value && !h.value && P
      }), {
        default: () => {
          var W;
          return [ja(g.value, "v-chip"), I && b(Uc, {
            key: "filter"
          }, {
            default: () => [dt(S("div", {
              class: "v-chip__filter"
            }, [l.filter ? b(Be, {
              key: "filter-defaults",
              disabled: !e.filterIcon,
              defaults: {
                VIcon: {
                  icon: e.filterIcon
                }
              }
            }, l.filter) : b(Ue, {
              key: "filter-icon",
              icon: e.filterIcon
            }, null)]), [[Nn, v.isSelected.value]])]
          }), T && S("div", {
            key: "prepend",
            class: "v-chip__prepend"
          }, [l.prepend ? b(Be, {
            key: "prepend-defaults",
            disabled: !w,
            defaults: {
              VAvatar: {
                image: e.prependAvatar,
                start: !0
              },
              VIcon: {
                icon: e.prependIcon,
                start: !0
              }
            }
          }, l.prepend) : S(ye, null, [e.prependIcon && b(Ue, {
            key: "prepend-icon",
            icon: e.prependIcon,
            start: !0
          }, null), e.prependAvatar && b(kn, {
            key: "prepend-avatar",
            image: e.prependAvatar,
            start: !0
          }, null)])]), S("div", {
            class: "v-chip__content",
            "data-no-activator": ""
          }, [((W = l.default) == null ? void 0 : W.call(l, {
            isSelected: v == null ? void 0 : v.isSelected.value,
            selectedClass: v == null ? void 0 : v.selectedClass.value,
            select: v == null ? void 0 : v.select,
            toggle: v == null ? void 0 : v.toggle,
            value: v == null ? void 0 : v.value.value,
            disabled: e.disabled
          })) ?? Re(e.text)]), N && S("div", {
            key: "append",
            class: "v-chip__append"
          }, [l.append ? b(Be, {
            key: "append-defaults",
            disabled: !D,
            defaults: {
              VAvatar: {
                end: !0,
                image: e.appendAvatar
              },
              VIcon: {
                end: !0,
                icon: e.appendIcon
              }
            }
          }, l.append) : S(ye, null, [e.appendIcon && b(Ue, {
            key: "append-icon",
            end: !0,
            icon: e.appendIcon
          }, null), e.appendAvatar && b(kn, {
            key: "append-avatar",
            end: !0,
            image: e.appendAvatar
          }, null)])]), V && S("button", Q({
            key: "close",
            class: "v-chip__close",
            type: "button",
            "data-testid": "close-chip"
          }, p.value), [l.close ? b(Be, {
            key: "close-defaults",
            defaults: {
              VIcon: {
                icon: e.closeIcon,
                size: "x-small"
              }
            }
          }, l.close) : b(Ue, {
            key: "close-icon",
            icon: e.closeIcon,
            size: "x-small"
          }, null)])];
        }
      }), [[en, g.value && e.ripple, null]]);
    };
  }
}), zV = z({
  color: String,
  inset: Boolean,
  length: [Number, String],
  opacity: [Number, String],
  thickness: [Number, String],
  vertical: Boolean,
  ...ke(),
  ...We()
}, "VDivider"), Sn = ne()({
  name: "VDivider",
  props: zV(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      themeClasses: l
    } = Ye(e), {
      textColorClasses: i,
      textColorStyles: o
    } = jt(() => e.color), r = x(() => {
      const s = {};
      return e.length && (s[e.vertical ? "height" : "width"] = pe(e.length)), e.thickness && (s[e.vertical ? "borderRightWidth" : "borderTopWidth"] = pe(e.thickness)), s;
    });
    return re(() => {
      const s = S("hr", {
        class: le([{
          "v-divider": !0,
          "v-divider--inset": e.inset,
          "v-divider--vertical": e.vertical
        }, l.value, i.value, e.class]),
        style: he([r.value, o.value, {
          "--v-border-opacity": e.opacity
        }, e.style]),
        "aria-orientation": !n.role || n.role === "separator" ? e.vertical ? "vertical" : "horizontal" : void 0,
        role: `${n.role || "separator"}`
      }, null);
      return a.default ? S("div", {
        class: le(["v-divider__wrapper", {
          "v-divider__wrapper--vertical": e.vertical,
          "v-divider__wrapper--inset": e.inset
        }])
      }, [s, S("div", {
        class: "v-divider__content"
      }, [a.default()]), s]) : s;
    }), {};
  }
}), Iu = Symbol.for("vuetify:list");
function wy() {
  let {
    filterable: e
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    filterable: !1
  };
  const t = Me(Iu, {
    filterable: !1,
    hasPrepend: fe(!1),
    updateHasPrepend: () => null
  }), n = {
    filterable: t.filterable || e,
    hasPrepend: fe(!1),
    updateHasPrepend: (a) => {
      a && (n.hasPrepend.value = a);
    }
  };
  return at(Iu, n), t;
}
function _y() {
  return Me(Iu, null);
}
const Xc = (e) => {
  const t = {
    activate: (n) => {
      let {
        id: a,
        value: l,
        activated: i
      } = n;
      return a = Pe(a), e && !l && i.size === 1 && i.has(a) || (l ? i.add(a) : i.delete(a)), i;
    },
    in: (n, a, l) => {
      let i = /* @__PURE__ */ new Set();
      if (n != null)
        for (const o of ht(n))
          i = t.activate({
            id: o,
            value: !0,
            activated: new Set(i),
            children: a,
            parents: l
          });
      return i;
    },
    out: (n) => Array.from(n)
  };
  return t;
}, xy = (e) => {
  const t = Xc(e);
  return {
    activate: (a) => {
      let {
        activated: l,
        id: i,
        ...o
      } = a;
      i = Pe(i);
      const r = l.has(i) ? /* @__PURE__ */ new Set([i]) : /* @__PURE__ */ new Set();
      return t.activate({
        ...o,
        id: i,
        activated: r
      });
    },
    in: (a, l, i) => {
      let o = /* @__PURE__ */ new Set();
      if (a != null) {
        const r = ht(a);
        r.length && (o = t.in(r.slice(0, 1), l, i));
      }
      return o;
    },
    out: (a, l, i) => t.out(a, l, i)
  };
}, jV = (e) => {
  const t = Xc(e);
  return {
    activate: (a) => {
      let {
        id: l,
        activated: i,
        children: o,
        ...r
      } = a;
      return l = Pe(l), o.has(l) ? i : t.activate({
        id: l,
        activated: i,
        children: o,
        ...r
      });
    },
    in: t.in,
    out: t.out
  };
}, WV = (e) => {
  const t = xy(e);
  return {
    activate: (a) => {
      let {
        id: l,
        activated: i,
        children: o,
        ...r
      } = a;
      return l = Pe(l), o.has(l) ? i : t.activate({
        id: l,
        activated: i,
        children: o,
        ...r
      });
    },
    in: t.in,
    out: t.out
  };
}, UV = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: a,
      parents: l
    } = e;
    if (n) {
      const i = /* @__PURE__ */ new Set();
      i.add(t);
      let o = l.get(t);
      for (; o != null; )
        i.add(o), o = l.get(o);
      return i;
    } else
      return a.delete(t), a;
  },
  select: () => null
}, ky = {
  open: (e) => {
    let {
      id: t,
      value: n,
      opened: a,
      parents: l
    } = e;
    if (n) {
      let i = l.get(t);
      for (a.add(t); i != null && i !== t; )
        a.add(i), i = l.get(i);
      return a;
    } else
      a.delete(t);
    return a;
  },
  select: () => null
}, GV = {
  open: ky.open,
  select: (e) => {
    let {
      id: t,
      value: n,
      opened: a,
      parents: l
    } = e;
    if (!n) return a;
    const i = [];
    let o = l.get(t);
    for (; o != null; )
      i.push(o), o = l.get(o);
    return new Set(i);
  }
}, Jc = (e) => {
  const t = {
    select: (n) => {
      let {
        id: a,
        value: l,
        selected: i
      } = n;
      if (a = Pe(a), e && !l) {
        const o = Array.from(i.entries()).reduce((r, s) => {
          let [d, u] = s;
          return u === "on" && r.push(d), r;
        }, []);
        if (o.length === 1 && o[0] === a) return i;
      }
      return i.set(a, l ? "on" : "off"), i;
    },
    in: (n, a, l, i) => {
      const o = /* @__PURE__ */ new Map();
      for (const r of n || [])
        t.select({
          id: r,
          value: !0,
          selected: o,
          children: a,
          parents: l,
          disabled: i
        });
      return o;
    },
    out: (n) => {
      const a = [];
      for (const [l, i] of n.entries())
        i === "on" && a.push(l);
      return a;
    }
  };
  return t;
}, Cy = (e) => {
  const t = Jc(e);
  return {
    select: (a) => {
      let {
        selected: l,
        id: i,
        ...o
      } = a;
      i = Pe(i);
      const r = l.has(i) ? /* @__PURE__ */ new Map([[i, l.get(i)]]) : /* @__PURE__ */ new Map();
      return t.select({
        ...o,
        id: i,
        selected: r
      });
    },
    in: (a, l, i, o) => a != null && a.length ? t.in(a.slice(0, 1), l, i, o) : /* @__PURE__ */ new Map(),
    out: (a, l, i) => t.out(a, l, i)
  };
}, KV = (e) => {
  const t = Jc(e);
  return {
    select: (a) => {
      let {
        id: l,
        selected: i,
        children: o,
        ...r
      } = a;
      return l = Pe(l), o.has(l) ? i : t.select({
        id: l,
        selected: i,
        children: o,
        ...r
      });
    },
    in: t.in,
    out: t.out
  };
}, YV = (e) => {
  const t = Cy(e);
  return {
    select: (a) => {
      let {
        id: l,
        selected: i,
        children: o,
        ...r
      } = a;
      return l = Pe(l), o.has(l) ? i : t.select({
        id: l,
        selected: i,
        children: o,
        ...r
      });
    },
    in: t.in,
    out: t.out
  };
}, Vy = (e) => {
  const t = {
    select: (n) => {
      let {
        id: a,
        value: l,
        selected: i,
        children: o,
        parents: r,
        disabled: s
      } = n;
      a = Pe(a);
      const d = new Map(i), u = [a];
      for (; u.length; ) {
        const f = u.shift();
        s.has(f) || i.set(Pe(f), l ? "on" : "off"), o.has(f) && u.push(...o.get(f));
      }
      let c = Pe(r.get(a));
      for (; c; ) {
        let f = !0, v = !0;
        for (const m of o.get(c)) {
          const h = Pe(m);
          if (!s.has(h) && (i.get(h) !== "on" && (f = !1), i.has(h) && i.get(h) !== "off" && (v = !1), !f && !v))
            break;
        }
        i.set(c, f ? "on" : v ? "off" : "indeterminate"), c = Pe(r.get(c));
      }
      return e && !l && Array.from(i.entries()).reduce((v, m) => {
        let [h, g] = m;
        return g === "on" && v.push(h), v;
      }, []).length === 0 ? d : i;
    },
    in: (n, a, l, i) => {
      let o = /* @__PURE__ */ new Map();
      for (const r of n || [])
        o = t.select({
          id: r,
          value: !0,
          selected: o,
          children: a,
          parents: l,
          disabled: i
        });
      return o;
    },
    out: (n, a) => {
      const l = [];
      for (const [i, o] of n.entries())
        o === "on" && !a.has(i) && l.push(i);
      return l;
    }
  };
  return t;
}, qV = (e) => {
  const t = Vy(e);
  return {
    select: t.select,
    in: t.in,
    out: (a, l, i) => {
      const o = [];
      for (const [r, s] of a.entries())
        if (s === "on") {
          if (i.has(r)) {
            const d = i.get(r);
            if (a.get(d) === "on") continue;
          }
          o.push(r);
        }
      return o;
    }
  };
}, io = Symbol.for("vuetify:nested"), Ey = {
  id: fe(),
  root: {
    register: () => null,
    unregister: () => null,
    children: Z(/* @__PURE__ */ new Map()),
    parents: Z(/* @__PURE__ */ new Map()),
    disabled: Z(/* @__PURE__ */ new Set()),
    open: () => null,
    openOnSelect: () => null,
    activate: () => null,
    select: () => null,
    activatable: Z(!1),
    selectable: Z(!1),
    opened: Z(/* @__PURE__ */ new Set()),
    activated: Z(/* @__PURE__ */ new Set()),
    selected: Z(/* @__PURE__ */ new Map()),
    selectedValues: Z([]),
    getPath: () => []
  }
}, XV = z({
  activatable: Boolean,
  selectable: Boolean,
  activeStrategy: [String, Function, Object],
  selectStrategy: [String, Function, Object],
  openStrategy: [String, Object],
  opened: null,
  activated: null,
  selected: null,
  mandatory: Boolean
}, "nested"), JV = (e) => {
  let t = !1;
  const n = fe(/* @__PURE__ */ new Map()), a = fe(/* @__PURE__ */ new Map()), l = fe(/* @__PURE__ */ new Set()), i = Ee(e, "opened", e.opened, (h) => new Set(Array.isArray(h) ? h.map((g) => Pe(g)) : h), (h) => [...h.values()]), o = x(() => {
    if (typeof e.activeStrategy == "object") return e.activeStrategy;
    if (typeof e.activeStrategy == "function") return e.activeStrategy(e.mandatory);
    switch (e.activeStrategy) {
      case "leaf":
        return jV(e.mandatory);
      case "single-leaf":
        return WV(e.mandatory);
      case "independent":
        return Xc(e.mandatory);
      case "single-independent":
      default:
        return xy(e.mandatory);
    }
  }), r = x(() => {
    if (typeof e.selectStrategy == "object") return e.selectStrategy;
    if (typeof e.selectStrategy == "function") return e.selectStrategy(e.mandatory);
    switch (e.selectStrategy) {
      case "single-leaf":
        return YV(e.mandatory);
      case "leaf":
        return KV(e.mandatory);
      case "independent":
        return Jc(e.mandatory);
      case "single-independent":
        return Cy(e.mandatory);
      case "trunk":
        return qV(e.mandatory);
      case "classic":
      default:
        return Vy(e.mandatory);
    }
  }), s = x(() => {
    if (typeof e.openStrategy == "object") return e.openStrategy;
    switch (e.openStrategy) {
      case "list":
        return GV;
      case "single":
        return UV;
      case "multiple":
      default:
        return ky;
    }
  }), d = Ee(e, "activated", e.activated, (h) => o.value.in(h, n.value, a.value), (h) => o.value.out(h, n.value, a.value)), u = Ee(e, "selected", e.selected, (h) => r.value.in(h, n.value, a.value, l.value), (h) => r.value.out(h, n.value, a.value));
  Wt(() => {
    t = !0;
  });
  function c(h) {
    const g = [];
    let p = Pe(h);
    for (; p !== void 0; )
      g.unshift(p), p = a.value.get(p);
    return g;
  }
  const f = St("nested"), v = /* @__PURE__ */ new Set(), m = {
    id: fe(),
    root: {
      opened: i,
      activatable: R(() => e.activatable),
      selectable: R(() => e.selectable),
      activated: d,
      selected: u,
      selectedValues: x(() => {
        const h = [];
        for (const [g, p] of u.value.entries())
          p === "on" && h.push(g);
        return h;
      }),
      register: (h, g, p, y) => {
        if (v.has(h)) {
          const _ = c(h).map(String).join(" -> "), E = c(g).concat(h).map(String).join(" -> ");
          li(`Multiple nodes with the same ID
	${_}
	${E}`);
          return;
        } else
          v.add(h);
        g && h !== g && a.value.set(h, g), p && l.value.add(h), y && n.value.set(h, []), g != null && n.value.set(g, [...n.value.get(g) || [], h]);
      },
      unregister: (h) => {
        if (t) return;
        v.delete(h), n.value.delete(h), l.value.delete(h);
        const g = a.value.get(h);
        if (g) {
          const p = n.value.get(g) ?? [];
          n.value.set(g, p.filter((y) => y !== h));
        }
        a.value.delete(h);
      },
      open: (h, g, p) => {
        f.emit("click:open", {
          id: h,
          value: g,
          path: c(h),
          event: p
        });
        const y = s.value.open({
          id: h,
          value: g,
          opened: new Set(i.value),
          children: n.value,
          parents: a.value,
          event: p
        });
        y && (i.value = y);
      },
      openOnSelect: (h, g, p) => {
        const y = s.value.select({
          id: h,
          value: g,
          selected: new Map(u.value),
          opened: new Set(i.value),
          children: n.value,
          parents: a.value,
          event: p
        });
        y && (i.value = y);
      },
      select: (h, g, p) => {
        f.emit("click:select", {
          id: h,
          value: g,
          path: c(h),
          event: p
        });
        const y = r.value.select({
          id: h,
          value: g,
          selected: new Map(u.value),
          children: n.value,
          parents: a.value,
          disabled: l.value,
          event: p
        });
        y && (u.value = y), m.root.openOnSelect(h, g, p);
      },
      activate: (h, g, p) => {
        if (!e.activatable)
          return m.root.select(h, !0, p);
        f.emit("click:activate", {
          id: h,
          value: g,
          path: c(h),
          event: p
        });
        const y = o.value.activate({
          id: h,
          value: g,
          activated: new Set(d.value),
          children: n.value,
          parents: a.value,
          event: p
        });
        if (y.size !== d.value.size)
          d.value = y;
        else {
          for (const _ of y)
            if (!d.value.has(_)) {
              d.value = y;
              return;
            }
          for (const _ of d.value)
            if (!y.has(_)) {
              d.value = y;
              return;
            }
        }
      },
      children: n,
      parents: a,
      disabled: l,
      getPath: c
    }
  };
  return at(io, m), m.root;
}, Py = (e, t, n) => {
  const a = Me(io, Ey), l = Symbol("nested item"), i = x(() => {
    const r = Pe(un(e));
    return r !== void 0 ? r : l;
  }), o = {
    ...a,
    id: i,
    open: (r, s) => a.root.open(i.value, r, s),
    openOnSelect: (r, s) => a.root.openOnSelect(i.value, r, s),
    isOpen: x(() => a.root.opened.value.has(i.value)),
    parent: x(() => a.root.parents.value.get(i.value)),
    activate: (r, s) => a.root.activate(i.value, r, s),
    isActivated: x(() => a.root.activated.value.has(i.value)),
    select: (r, s) => a.root.select(i.value, r, s),
    isSelected: x(() => a.root.selected.value.get(i.value) === "on"),
    isIndeterminate: x(() => a.root.selected.value.get(i.value) === "indeterminate"),
    isLeaf: x(() => !a.root.children.value.get(i.value)),
    isGroupActivator: a.isGroupActivator
  };
  return fi(() => {
    a.isGroupActivator || a.root.register(i.value, a.id.value, un(t), n);
  }), Wt(() => {
    a.isGroupActivator || a.root.unregister(i.value);
  }), n && at(io, o), o;
}, ZV = () => {
  const e = Me(io, Ey);
  at(io, {
    ...e,
    isGroupActivator: !0
  });
}, QV = Cn({
  name: "VListGroupActivator",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return ZV(), () => {
      var a;
      return (a = n.default) == null ? void 0 : a.call(n);
    };
  }
}), Iy = z({
  /* @deprecated */
  activeColor: String,
  baseColor: String,
  color: String,
  collapseIcon: {
    type: Ve,
    default: "$collapse"
  },
  disabled: Boolean,
  expandIcon: {
    type: Ve,
    default: "$expand"
  },
  rawId: [String, Number],
  prependIcon: Ve,
  appendIcon: Ve,
  fluid: Boolean,
  subgroup: Boolean,
  title: String,
  value: null,
  ...ke(),
  ...Oe()
}, "VListGroup"), oo = ne()({
  name: "VListGroup",
  props: Iy(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isOpen: a,
      open: l,
      id: i
    } = Py(() => e.value, () => e.disabled, !0), o = x(() => `v-list-group--id-${String(e.rawId ?? i.value)}`), r = _y(), {
      isBooted: s
    } = El();
    function d(v) {
      var m;
      ["INPUT", "TEXTAREA"].includes((m = v.target) == null ? void 0 : m.tagName) || l(!a.value, v);
    }
    const u = x(() => ({
      onClick: d,
      class: "v-list-group__header",
      id: o.value
    })), c = x(() => a.value ? e.collapseIcon : e.expandIcon), f = x(() => ({
      VListItem: {
        activeColor: e.activeColor,
        baseColor: e.baseColor,
        color: e.color,
        prependIcon: e.prependIcon || e.subgroup && c.value,
        appendIcon: e.appendIcon || !e.subgroup && c.value,
        title: e.title,
        value: e.value
      }
    }));
    return re(() => b(e.tag, {
      class: le(["v-list-group", {
        "v-list-group--prepend": r == null ? void 0 : r.hasPrepend.value,
        "v-list-group--fluid": e.fluid,
        "v-list-group--subgroup": e.subgroup,
        "v-list-group--open": a.value
      }, e.class]),
      style: he(e.style)
    }, {
      default: () => [n.activator && b(Be, {
        defaults: f.value
      }, {
        default: () => [b(QV, null, {
          default: () => [n.activator({
            props: u.value,
            isOpen: a.value
          })]
        })]
      }), b(Zt, {
        transition: {
          component: Wr
        },
        disabled: !s.value
      }, {
        default: () => {
          var v;
          return [dt(S("div", {
            class: "v-list-group__items",
            role: "group",
            "aria-labelledby": o.value
          }, [(v = n.default) == null ? void 0 : v.call(n)]), [[Nn, a.value]])];
        }
      })]
    })), {
      isOpen: a
    };
  }
}), e1 = z({
  opacity: [Number, String],
  ...ke(),
  ...Oe()
}, "VListItemSubtitle"), Ny = ne()({
  name: "VListItemSubtitle",
  props: e1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => b(e.tag, {
      class: le(["v-list-item-subtitle", e.class]),
      style: he([{
        "--v-list-item-subtitle-opacity": e.opacity
      }, e.style])
    }, n)), {};
  }
}), Dy = Ca("v-list-item-title"), Ay = z({
  active: {
    type: Boolean,
    default: void 0
  },
  activeClass: String,
  /* @deprecated */
  activeColor: String,
  appendAvatar: String,
  appendIcon: Ve,
  baseColor: String,
  disabled: Boolean,
  lines: [Boolean, String],
  link: {
    type: Boolean,
    default: void 0
  },
  nav: Boolean,
  prependAvatar: String,
  prependIcon: Ve,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  slim: Boolean,
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  value: null,
  onClick: zt(),
  onClickOnce: zt(),
  ...cn(),
  ...ke(),
  ...Tt(),
  ...kt(),
  ...Pt(),
  ...ft(),
  ...Vo(),
  ...Oe(),
  ...We(),
  ...Dn({
    variant: "text"
  })
}, "VListItem"), zn = ne()({
  name: "VListItem",
  directives: {
    vRipple: en
  },
  props: Ay(),
  emits: {
    click: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a,
      emit: l
    } = t;
    const i = Co(e, n), o = x(() => e.value === void 0 ? i.href.value : e.value), {
      activate: r,
      isActivated: s,
      select: d,
      isOpen: u,
      isSelected: c,
      isIndeterminate: f,
      isGroupActivator: v,
      root: m,
      parent: h,
      openOnSelect: g,
      id: p
    } = Py(o, () => e.disabled, !1), y = _y(), _ = x(() => {
      var B;
      return e.active !== !1 && (e.active || ((B = i.isActive) == null ? void 0 : B.value) || (m.activatable.value ? s.value : c.value));
    }), E = R(() => e.link !== !1 && i.isLink.value), k = x(() => !!y && (m.selectable.value || m.activatable.value || e.value != null)), P = x(() => !e.disabled && e.link !== !1 && (e.link || i.isClickable.value || k.value)), A = x(() => y ? k.value ? "option" : "listitem" : void 0), D = x(() => {
      if (k.value)
        return m.activatable.value ? s.value : m.selectable.value ? c.value : _.value;
    }), N = R(() => e.rounded || e.nav), V = R(() => e.color ?? e.activeColor), I = R(() => ({
      color: _.value ? V.value ?? e.baseColor : e.baseColor,
      variant: e.variant
    }));
    me(() => {
      var B;
      return (B = i.isActive) == null ? void 0 : B.value;
    }, (B) => {
      B && w();
    }), fi(() => {
      var B;
      (B = i.isActive) != null && B.value && w();
    });
    function w() {
      h.value != null && m.open(h.value, !0), g(!0);
    }
    const {
      themeClasses: T
    } = Ye(e), {
      borderClasses: M
    } = hn(e), {
      colorClasses: W,
      colorStyles: J,
      variantClasses: ee
    } = Pl(I), {
      densityClasses: Y
    } = tn(e), {
      dimensionStyles: L
    } = Ct(e), {
      elevationClasses: H
    } = Rt(e), {
      roundedClasses: j
    } = yt(N), U = R(() => e.lines ? `v-list-item--${e.lines}-line` : void 0), F = R(() => e.ripple !== void 0 && e.ripple && (y != null && y.filterable) ? {
      keys: ["Enter"]
    } : e.ripple), oe = x(() => ({
      isActive: _.value,
      select: d,
      isOpen: u.value,
      isSelected: c.value,
      isIndeterminate: f.value
    }));
    function ve(B) {
      var G, ie;
      l("click", B), !["INPUT", "TEXTAREA"].includes((G = B.target) == null ? void 0 : G.tagName) && P.value && ((ie = i.navigate) == null || ie.call(i, B), !v && (m.activatable.value ? r(!s.value, B) : (m.selectable.value || e.value != null && !E.value) && d(!c.value, B)));
    }
    function _e(B) {
      const G = B.target;
      ["INPUT", "TEXTAREA"].includes(G.tagName) || (B.key === "Enter" || B.key === " " && !(y != null && y.filterable)) && (B.preventDefault(), B.stopPropagation(), B.target.dispatchEvent(new MouseEvent("click", B)));
    }
    return re(() => {
      const B = E.value ? "a" : e.tag, G = a.title || e.title != null, ie = a.subtitle || e.subtitle != null, de = !!(e.appendAvatar || e.appendIcon), Se = !!(de || a.append), Ce = !!(e.prependAvatar || e.prependIcon), C = !!(Ce || a.prepend);
      return y == null || y.updateHasPrepend(C), e.activeColor && pg("active-color", ["color", "base-color"]), dt(b(B, Q(i.linkProps, {
        class: ["v-list-item", {
          "v-list-item--active": _.value,
          "v-list-item--disabled": e.disabled,
          "v-list-item--link": P.value,
          "v-list-item--nav": e.nav,
          "v-list-item--prepend": !C && (y == null ? void 0 : y.hasPrepend.value),
          "v-list-item--slim": e.slim,
          [`${e.activeClass}`]: e.activeClass && _.value
        }, T.value, M.value, W.value, Y.value, H.value, U.value, j.value, ee.value, e.class],
        style: [J.value, L.value, e.style],
        tabindex: P.value ? y ? -2 : 0 : void 0,
        "aria-selected": D.value,
        role: A.value,
        onClick: ve,
        onKeydown: P.value && !E.value && _e
      }), {
        default: () => {
          var O;
          return [ja(P.value || _.value, "v-list-item"), C && S("div", {
            key: "prepend",
            class: "v-list-item__prepend"
          }, [a.prepend ? b(Be, {
            key: "prepend-defaults",
            disabled: !Ce,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.prependAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.prependIcon
              },
              VListItemAction: {
                start: !0
              }
            }
          }, {
            default: () => {
              var $;
              return [($ = a.prepend) == null ? void 0 : $.call(a, oe.value)];
            }
          }) : S(ye, null, [e.prependAvatar && b(kn, {
            key: "prepend-avatar",
            density: e.density,
            image: e.prependAvatar
          }, null), e.prependIcon && b(Ue, {
            key: "prepend-icon",
            density: e.density,
            icon: e.prependIcon
          }, null)]), S("div", {
            class: "v-list-item__spacer"
          }, null)]), S("div", {
            class: "v-list-item__content",
            "data-no-activator": ""
          }, [G && b(Dy, {
            key: "title"
          }, {
            default: () => {
              var $;
              return [(($ = a.title) == null ? void 0 : $.call(a, {
                title: e.title
              })) ?? Re(e.title)];
            }
          }), ie && b(Ny, {
            key: "subtitle"
          }, {
            default: () => {
              var $;
              return [(($ = a.subtitle) == null ? void 0 : $.call(a, {
                subtitle: e.subtitle
              })) ?? Re(e.subtitle)];
            }
          }), (O = a.default) == null ? void 0 : O.call(a, oe.value)]), Se && S("div", {
            key: "append",
            class: "v-list-item__append"
          }, [a.append ? b(Be, {
            key: "append-defaults",
            disabled: !de,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.appendAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.appendIcon
              },
              VListItemAction: {
                end: !0
              }
            }
          }, {
            default: () => {
              var $;
              return [($ = a.append) == null ? void 0 : $.call(a, oe.value)];
            }
          }) : S(ye, null, [e.appendIcon && b(Ue, {
            key: "append-icon",
            density: e.density,
            icon: e.appendIcon
          }, null), e.appendAvatar && b(kn, {
            key: "append-avatar",
            density: e.density,
            image: e.appendAvatar
          }, null)]), S("div", {
            class: "v-list-item__spacer"
          }, null)])];
        }
      }), [[en, P.value && F.value]]);
    }), {
      activate: r,
      isActivated: s,
      isGroupActivator: v,
      isSelected: c,
      list: y,
      select: d,
      root: m,
      id: p,
      link: i
    };
  }
}), t1 = z({
  color: String,
  inset: Boolean,
  sticky: Boolean,
  title: String,
  ...ke(),
  ...Oe()
}, "VListSubheader"), pi = ne()({
  name: "VListSubheader",
  props: t1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: a,
      textColorStyles: l
    } = jt(() => e.color);
    return re(() => {
      const i = !!(n.default || e.title);
      return b(e.tag, {
        class: le(["v-list-subheader", {
          "v-list-subheader--inset": e.inset,
          "v-list-subheader--sticky": e.sticky
        }, a.value, e.class]),
        style: he([{
          textColorStyles: l
        }, e.style])
      }, {
        default: () => {
          var o;
          return [i && S("div", {
            class: "v-list-subheader__text"
          }, [((o = n.default) == null ? void 0 : o.call(n)) ?? e.title])];
        }
      });
    }), {};
  }
}), n1 = z({
  items: Array,
  returnObject: Boolean
}, "VListChildren"), Ty = ne()({
  name: "VListChildren",
  props: n1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return wy(), () => {
      var a, l;
      return ((a = n.default) == null ? void 0 : a.call(n)) ?? ((l = e.items) == null ? void 0 : l.map((i) => {
        var f, v;
        let {
          children: o,
          props: r,
          type: s,
          raw: d
        } = i;
        if (s === "divider")
          return ((f = n.divider) == null ? void 0 : f.call(n, {
            props: r
          })) ?? b(Sn, r, null);
        if (s === "subheader")
          return ((v = n.subheader) == null ? void 0 : v.call(n, {
            props: r
          })) ?? b(pi, r, null);
        const u = {
          subtitle: n.subtitle ? (m) => {
            var h;
            return (h = n.subtitle) == null ? void 0 : h.call(n, {
              ...m,
              item: d
            });
          } : void 0,
          prepend: n.prepend ? (m) => {
            var h;
            return (h = n.prepend) == null ? void 0 : h.call(n, {
              ...m,
              item: d
            });
          } : void 0,
          append: n.append ? (m) => {
            var h;
            return (h = n.append) == null ? void 0 : h.call(n, {
              ...m,
              item: d
            });
          } : void 0,
          title: n.title ? (m) => {
            var h;
            return (h = n.title) == null ? void 0 : h.call(n, {
              ...m,
              item: d
            });
          } : void 0
        }, c = oo.filterProps(r);
        return o ? b(oo, Q(c, {
          value: e.returnObject ? d : r == null ? void 0 : r.value,
          rawId: r == null ? void 0 : r.value
        }), {
          activator: (m) => {
            let {
              props: h
            } = m;
            const g = Q(r, h, {
              value: e.returnObject ? d : r.value
            });
            return n.header ? n.header({
              props: g
            }) : b(zn, g, u);
          },
          default: () => b(Ty, {
            items: o,
            returnObject: e.returnObject
          }, n)
        }) : n.item ? n.item({
          props: r
        }) : b(zn, Q(r, {
          value: e.returnObject ? d : r.value
        }), u);
      }));
    };
  }
}), Oy = z({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  itemType: {
    type: [Boolean, String, Array, Function],
    default: "type"
  },
  returnObject: Boolean,
  valueComparator: Function
}, "list-items"), a1 = /* @__PURE__ */ new Set(["item", "divider", "subheader"]);
function Tn(e, t) {
  const n = xt(t, e.itemTitle, t), a = xt(t, e.itemValue, n), l = xt(t, e.itemChildren), i = e.itemProps === !0 ? typeof t == "object" && t != null && !Array.isArray(t) ? "children" in t ? tt(t, ["children"]) : t : void 0 : xt(t, e.itemProps);
  let o = xt(t, e.itemType, "item");
  a1.has(o) || (o = "item");
  const r = {
    title: n,
    value: a,
    ...i
  };
  return {
    type: o,
    title: String(r.title ?? ""),
    value: r.value,
    props: r,
    children: o === "item" && Array.isArray(l) ? $y(e, l) : void 0,
    raw: t
  };
}
Tn.neededProps = ["itemTitle", "itemValue", "itemChildren", "itemProps", "itemType"];
function $y(e, t) {
  const n = mn(e, Tn.neededProps), a = [];
  for (const l of t)
    a.push(Tn(n, l));
  return a;
}
function Zc(e) {
  const t = x(() => $y(e, e.items)), n = x(() => t.value.some((r) => r.value === null)), a = fe(/* @__PURE__ */ new Map()), l = fe([]);
  ut(() => {
    const r = t.value, s = /* @__PURE__ */ new Map(), d = [];
    for (let u = 0; u < r.length; u++) {
      const c = r[u];
      if (hu(c.value) || c.value === null) {
        let f = s.get(c.value);
        f || (f = [], s.set(c.value, f)), f.push(c);
      } else
        d.push(c);
    }
    a.value = s, l.value = d;
  });
  function i(r) {
    const s = a.value, d = t.value, u = l.value, c = n.value, f = e.returnObject, v = !!e.valueComparator, m = e.valueComparator || Mt, h = mn(e, Tn.neededProps), g = [];
    e: for (const p of r) {
      if (!c && p === null) continue;
      if (f && typeof p == "string") {
        g.push(Tn(h, p));
        continue;
      }
      const y = s.get(p);
      if (v || !y) {
        for (const _ of v ? d : u)
          if (m(p, _.value)) {
            g.push(_);
            continue e;
          }
        g.push(Tn(h, p));
        continue;
      }
      g.push(...y);
    }
    return g;
  }
  function o(r) {
    return e.returnObject ? r.map((s) => {
      let {
        raw: d
      } = s;
      return d;
    }) : r.map((s) => {
      let {
        value: d
      } = s;
      return d;
    });
  }
  return {
    items: t,
    transformIn: i,
    transformOut: o
  };
}
const l1 = /* @__PURE__ */ new Set(["item", "divider", "subheader"]);
function i1(e, t) {
  const n = hu(t) ? t : xt(t, e.itemTitle), a = hu(t) ? t : xt(t, e.itemValue, void 0), l = xt(t, e.itemChildren), i = e.itemProps === !0 ? tt(t, ["children"]) : xt(t, e.itemProps);
  let o = xt(t, e.itemType, "item");
  l1.has(o) || (o = "item");
  const r = {
    title: n,
    value: a,
    ...i
  };
  return {
    type: o,
    title: r.title,
    value: r.value,
    props: r,
    children: o === "item" && l ? By(e, l) : void 0,
    raw: t
  };
}
function By(e, t) {
  const n = [];
  for (const a of t)
    n.push(i1(e, a));
  return n;
}
function My(e) {
  return {
    items: x(() => By(e, e.items))
  };
}
const Ry = z({
  baseColor: String,
  /* @deprecated */
  activeColor: String,
  activeClass: String,
  bgColor: String,
  disabled: Boolean,
  filterable: Boolean,
  expandIcon: Ve,
  collapseIcon: Ve,
  lines: {
    type: [Boolean, String],
    default: "one"
  },
  slim: Boolean,
  nav: Boolean,
  "onClick:open": zt(),
  "onClick:select": zt(),
  "onUpdate:opened": zt(),
  ...XV({
    selectStrategy: "single-leaf",
    openStrategy: "list"
  }),
  ...cn(),
  ...ke(),
  ...Tt(),
  ...kt(),
  ...Pt(),
  ...Oy(),
  ...ft(),
  ...Oe(),
  ...We(),
  ...Dn({
    variant: "text"
  })
}, "VList"), ri = ne()({
  name: "VList",
  props: Ry(),
  emits: {
    "update:selected": (e) => !0,
    "update:activated": (e) => !0,
    "update:opened": (e) => !0,
    "click:open": (e) => !0,
    "click:activate": (e) => !0,
    "click:select": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: a
    } = My(e), {
      themeClasses: l
    } = Ye(e), {
      backgroundColorClasses: i,
      backgroundColorStyles: o
    } = Xe(() => e.bgColor), {
      borderClasses: r
    } = hn(e), {
      densityClasses: s
    } = tn(e), {
      dimensionStyles: d
    } = Ct(e), {
      elevationClasses: u
    } = Rt(e), {
      roundedClasses: c
    } = yt(e), {
      children: f,
      open: v,
      parents: m,
      select: h,
      getPath: g
    } = JV(e), p = R(() => e.lines ? `v-list--${e.lines}-line` : void 0), y = R(() => e.activeColor), _ = R(() => e.baseColor), E = R(() => e.color), k = R(() => e.selectable || e.activatable);
    wy({
      filterable: e.filterable
    }), gt({
      VListGroup: {
        activeColor: y,
        baseColor: _,
        color: E,
        expandIcon: R(() => e.expandIcon),
        collapseIcon: R(() => e.collapseIcon)
      },
      VListItem: {
        activeClass: R(() => e.activeClass),
        activeColor: y,
        baseColor: _,
        color: E,
        density: R(() => e.density),
        disabled: R(() => e.disabled),
        lines: R(() => e.lines),
        nav: R(() => e.nav),
        slim: R(() => e.slim),
        variant: R(() => e.variant)
      }
    });
    const P = fe(!1), A = Z();
    function D(M) {
      P.value = !0;
    }
    function N(M) {
      P.value = !1;
    }
    function V(M) {
      var W;
      !P.value && !(M.relatedTarget && ((W = A.value) != null && W.contains(M.relatedTarget))) && T();
    }
    function I(M) {
      const W = M.target;
      if (!(!A.value || W.tagName === "INPUT" && ["Home", "End"].includes(M.key) || W.tagName === "TEXTAREA")) {
        if (M.key === "ArrowDown")
          T("next");
        else if (M.key === "ArrowUp")
          T("prev");
        else if (M.key === "Home")
          T("first");
        else if (M.key === "End")
          T("last");
        else
          return;
        M.preventDefault();
      }
    }
    function w(M) {
      P.value = !0;
    }
    function T(M) {
      if (A.value)
        return cl(A.value, M);
    }
    return re(() => b(e.tag, {
      ref: A,
      class: le(["v-list", {
        "v-list--disabled": e.disabled,
        "v-list--nav": e.nav,
        "v-list--slim": e.slim
      }, l.value, i.value, r.value, s.value, u.value, p.value, c.value, e.class]),
      style: he([o.value, d.value, e.style]),
      tabindex: e.disabled ? -1 : 0,
      role: k.value ? "listbox" : "list",
      "aria-activedescendant": void 0,
      onFocusin: D,
      onFocusout: N,
      onFocus: V,
      onKeydown: I,
      onMousedown: w
    }, {
      default: () => [b(Ty, {
        items: a.value,
        returnObject: e.returnObject
      }, n)]
    })), {
      open: v,
      select: h,
      focus: T,
      children: f,
      parents: m,
      getPath: g
    };
  }
}), o1 = Ca("v-list-img"), r1 = z({
  start: Boolean,
  end: Boolean,
  ...ke(),
  ...Oe()
}, "VListItemAction"), Qc = ne()({
  name: "VListItemAction",
  props: r1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => b(e.tag, {
      class: le(["v-list-item-action", {
        "v-list-item-action--start": e.start,
        "v-list-item-action--end": e.end
      }, e.class]),
      style: he(e.style)
    }, n)), {};
  }
}), s1 = z({
  start: Boolean,
  end: Boolean,
  ...ke(),
  ...Oe()
}, "VListItemMedia"), u1 = ne()({
  name: "VListItemMedia",
  props: s1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => b(e.tag, {
      class: le(["v-list-item-media", {
        "v-list-item-media--start": e.start,
        "v-list-item-media--end": e.end
      }, e.class]),
      style: he(e.style)
    }, n)), {};
  }
});
function Bs(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}
function c1(e, t) {
  return {
    x: e.x - t.x,
    y: e.y - t.y
  };
}
function Tv(e, t) {
  if (e.side === "top" || e.side === "bottom") {
    const {
      side: n,
      align: a
    } = e, l = a === "left" ? 0 : a === "center" ? t.width / 2 : a === "right" ? t.width : a, i = n === "top" ? 0 : n === "bottom" ? t.height : n;
    return Bs({
      x: l,
      y: i
    }, t);
  } else if (e.side === "left" || e.side === "right") {
    const {
      side: n,
      align: a
    } = e, l = n === "left" ? 0 : n === "right" ? t.width : n, i = a === "top" ? 0 : a === "center" ? t.height / 2 : a === "bottom" ? t.height : a;
    return Bs({
      x: l,
      y: i
    }, t);
  }
  return Bs({
    x: t.width / 2,
    y: t.height / 2
  }, t);
}
const Ly = {
  static: v1,
  // specific viewport position, usually centered
  connected: h1
  // connected to a certain element
}, d1 = z({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (e) => typeof e == "function" || e in Ly
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array],
  stickToTarget: Boolean
}, "VOverlay-location-strategies");
function f1(e, t) {
  const n = Z({}), a = Z();
  qe && Gt(() => !!(t.isActive.value && e.locationStrategy), (r) => {
    var s, d;
    me(() => e.locationStrategy, r), Dt(() => {
      window.removeEventListener("resize", l), visualViewport == null || visualViewport.removeEventListener("resize", i), visualViewport == null || visualViewport.removeEventListener("scroll", o), a.value = void 0;
    }), window.addEventListener("resize", l, {
      passive: !0
    }), visualViewport == null || visualViewport.addEventListener("resize", i, {
      passive: !0
    }), visualViewport == null || visualViewport.addEventListener("scroll", o, {
      passive: !0
    }), typeof e.locationStrategy == "function" ? a.value = (s = e.locationStrategy(t, e, n)) == null ? void 0 : s.updateLocation : a.value = (d = Ly[e.locationStrategy](t, e, n)) == null ? void 0 : d.updateLocation;
  });
  function l(r) {
    var s;
    (s = a.value) == null || s.call(a, r);
  }
  function i(r) {
    var s;
    (s = a.value) == null || s.call(a, r);
  }
  function o(r) {
    var s;
    (s = a.value) == null || s.call(a, r);
  }
  return {
    contentStyles: n,
    updateLocation: a
  };
}
function v1() {
}
function m1(e, t) {
  const n = Nc(e);
  return t ? n.x += parseFloat(e.style.right || 0) : n.x -= parseFloat(e.style.left || 0), n.y -= parseFloat(e.style.top || 0), n;
}
function h1(e, t, n) {
  (Array.isArray(e.target.value) || fk(e.target.value)) && Object.assign(n.value, {
    position: "fixed",
    top: 0,
    [e.isRtl.value ? "right" : "left"]: 0
  });
  const {
    preferredAnchor: l,
    preferredOrigin: i
  } = Ic(() => {
    const p = gu(t.location, e.isRtl.value), y = t.origin === "overlap" ? p : t.origin === "auto" ? Ps(p) : gu(t.origin, e.isRtl.value);
    return p.side === y.side && p.align === Is(y).align ? {
      preferredAnchor: Jf(p),
      preferredOrigin: Jf(y)
    } : {
      preferredAnchor: p,
      preferredOrigin: y
    };
  }), [o, r, s, d] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((p) => x(() => {
    const y = parseFloat(t[p]);
    return isNaN(y) ? 1 / 0 : y;
  })), u = x(() => {
    if (Array.isArray(t.offset))
      return t.offset;
    if (typeof t.offset == "string") {
      const p = t.offset.split(" ").map(parseFloat);
      return p.length < 2 && p.push(0), p;
    }
    return typeof t.offset == "number" ? [t.offset, 0] : [0, 0];
  });
  let c = !1, f = -1;
  const v = new vg(4), m = new ResizeObserver(() => {
    if (!c) return;
    if (requestAnimationFrame((y) => {
      y !== f && v.clear(), requestAnimationFrame((_) => {
        f = _;
      });
    }), v.isFull) {
      const y = v.values();
      if (Mt(y.at(-1), y.at(-3)) && !Mt(y.at(-1), y.at(-2)))
        return;
    }
    const p = g();
    p && v.push(p.flipped);
  });
  let h = new ta({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });
  me(e.target, (p, y) => {
    y && !Array.isArray(y) && m.unobserve(y), Array.isArray(p) ? Mt(p, y) || g() : p && m.observe(p);
  }, {
    immediate: !0
  }), me(e.contentEl, (p, y) => {
    y && m.unobserve(y), p && m.observe(p);
  }, {
    immediate: !0
  }), Dt(() => {
    m.disconnect();
  });
  function g() {
    if (c = !1, requestAnimationFrame(() => c = !0), !e.target.value || !e.contentEl.value) return;
    (Array.isArray(e.target.value) || e.target.value.offsetParent || e.target.value.getClientRects().length) && (h = bg(e.target.value));
    const p = m1(e.contentEl.value, e.isRtl.value), y = pr(e.contentEl.value), _ = 12;
    y.length || (y.push(document.documentElement), e.contentEl.value.style.top && e.contentEl.value.style.left || (p.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0), p.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
    const E = y.reduce((T, M) => {
      const W = $x(M);
      return T ? new ta({
        x: Math.max(T.left, W.left),
        y: Math.max(T.top, W.top),
        width: Math.min(T.right, W.right) - Math.max(T.left, W.left),
        height: Math.min(T.bottom, W.bottom) - Math.max(T.top, W.top)
      }) : W;
    }, void 0);
    E.x += _, E.y += _, E.width -= _ * 2, E.height -= _ * 2;
    let k = {
      anchor: l.value,
      origin: i.value
    };
    function P(T) {
      const M = new ta(p), W = Tv(T.anchor, h), J = Tv(T.origin, M);
      let {
        x: ee,
        y: Y
      } = c1(W, J);
      switch (T.anchor.side) {
        case "top":
          Y -= u.value[0];
          break;
        case "bottom":
          Y += u.value[0];
          break;
        case "left":
          ee -= u.value[0];
          break;
        case "right":
          ee += u.value[0];
          break;
      }
      switch (T.anchor.align) {
        case "top":
          Y -= u.value[1];
          break;
        case "bottom":
          Y += u.value[1];
          break;
        case "left":
          ee -= u.value[1];
          break;
        case "right":
          ee += u.value[1];
          break;
      }
      return M.x += ee, M.y += Y, M.width = Math.min(M.width, s.value), M.height = Math.min(M.height, d.value), {
        overflows: Qf(M, E),
        x: ee,
        y: Y
      };
    }
    let A = 0, D = 0;
    const N = {
      x: 0,
      y: 0
    }, V = {
      x: !1,
      y: !1
    };
    let I = -1;
    for (; ; ) {
      if (I++ > 10) {
        li("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: T,
        y: M,
        overflows: W
      } = P(k);
      A += T, D += M, p.x += T, p.y += M;
      {
        const J = Zf(k.anchor), ee = W.x.before || W.x.after, Y = W.y.before || W.y.after;
        let L = !1;
        if (["x", "y"].forEach((H) => {
          if (H === "x" && ee && !V.x || H === "y" && Y && !V.y) {
            const j = {
              anchor: {
                ...k.anchor
              },
              origin: {
                ...k.origin
              }
            }, U = H === "x" ? J === "y" ? Is : Ps : J === "y" ? Ps : Is;
            j.anchor = U(j.anchor), j.origin = U(j.origin);
            const {
              overflows: F
            } = P(j);
            (F[H].before <= W[H].before && F[H].after <= W[H].after || F[H].before + F[H].after < (W[H].before + W[H].after) / 2) && (k = j, L = V[H] = !0);
          }
        }), L) continue;
      }
      W.x.before && (t.stickToTarget || (A += W.x.before), p.x += W.x.before), W.x.after && (t.stickToTarget || (A -= W.x.after), p.x -= W.x.after), W.y.before && (t.stickToTarget || (D += W.y.before), p.y += W.y.before), W.y.after && (t.stickToTarget || (D -= W.y.after), p.y -= W.y.after);
      {
        const J = Qf(p, E);
        N.x = E.width - J.x.before - J.x.after, N.y = E.height - J.y.before - J.y.after, t.stickToTarget || (A += J.x.before), p.x += J.x.before, t.stickToTarget || (D += J.y.before), p.y += J.y.before;
      }
      break;
    }
    const w = Zf(k.anchor);
    return Object.assign(n.value, {
      "--v-overlay-anchor-origin": `${k.anchor.side} ${k.anchor.align}`,
      transformOrigin: `${k.origin.side} ${k.origin.align}`,
      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,
      top: pe(Ms(D)),
      left: e.isRtl.value ? void 0 : pe(Ms(A)),
      right: e.isRtl.value ? pe(Ms(-A)) : void 0,
      minWidth: pe(w === "y" ? Math.min(o.value, h.width) : o.value),
      maxWidth: pe(Ov(ot(N.x, o.value === 1 / 0 ? 0 : o.value, s.value))),
      maxHeight: pe(Ov(ot(N.y, r.value === 1 / 0 ? 0 : r.value, d.value)))
    }), {
      available: N,
      contentBox: p,
      flipped: V
    };
  }
  return me(() => [l.value, i.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight], () => g()), He(() => {
    const p = g();
    if (!p) return;
    const {
      available: y,
      contentBox: _
    } = p;
    _.height > y.y && requestAnimationFrame(() => {
      g(), requestAnimationFrame(() => {
        g();
      });
    });
  }), {
    updateLocation: g
  };
}
function Ms(e) {
  return Math.round(e * devicePixelRatio) / devicePixelRatio;
}
function Ov(e) {
  return Math.ceil(e * devicePixelRatio) / devicePixelRatio;
}
let Nu = !0;
const kr = [];
function g1(e) {
  !Nu || kr.length ? (kr.push(e), Du()) : (Nu = !1, e(), Du());
}
let $v = -1;
function Du() {
  cancelAnimationFrame($v), $v = requestAnimationFrame(() => {
    const e = kr.shift();
    e && e(), kr.length ? Du() : Nu = !0;
  });
}
const Jo = {
  none: null,
  close: p1,
  block: S1,
  reposition: w1
}, y1 = z({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (e) => typeof e == "function" || e in Jo
  }
}, "VOverlay-scroll-strategies");
function b1(e, t) {
  if (!qe) return;
  let n;
  ut(async () => {
    n == null || n.stop(), t.isActive.value && e.scrollStrategy && (n = Jl(), await new Promise((a) => setTimeout(a)), n.active && n.run(() => {
      var a;
      typeof e.scrollStrategy == "function" ? e.scrollStrategy(t, e, n) : (a = Jo[e.scrollStrategy]) == null || a.call(Jo, t, e, n);
    }));
  }), Dt(() => {
    n == null || n.stop();
  });
}
function p1(e) {
  function t(n) {
    e.isActive.value = !1;
  }
  Fy(ed(e.target.value, e.contentEl.value), t);
}
function S1(e, t) {
  var r;
  const n = (r = e.root.value) == null ? void 0 : r.offsetParent, a = ed(e.target.value, e.contentEl.value), l = [.../* @__PURE__ */ new Set([...pr(a, t.contained ? n : void 0), ...pr(e.contentEl.value, t.contained ? n : void 0)])].filter((s) => !s.classList.contains("v-overlay-scroll-blocked")), i = window.innerWidth - document.documentElement.offsetWidth, o = ((s) => $c(s) && s)(n || document.documentElement);
  o && e.root.value.classList.add("v-overlay--scroll-blocked"), l.forEach((s, d) => {
    s.style.setProperty("--v-body-scroll-x", pe(-s.scrollLeft)), s.style.setProperty("--v-body-scroll-y", pe(-s.scrollTop)), s !== document.documentElement && s.style.setProperty("--v-scrollbar-offset", pe(i)), s.classList.add("v-overlay-scroll-blocked");
  }), Dt(() => {
    l.forEach((s, d) => {
      const u = parseFloat(s.style.getPropertyValue("--v-body-scroll-x")), c = parseFloat(s.style.getPropertyValue("--v-body-scroll-y")), f = s.style.scrollBehavior;
      s.style.scrollBehavior = "auto", s.style.removeProperty("--v-body-scroll-x"), s.style.removeProperty("--v-body-scroll-y"), s.style.removeProperty("--v-scrollbar-offset"), s.classList.remove("v-overlay-scroll-blocked"), s.scrollLeft = -u, s.scrollTop = -c, s.style.scrollBehavior = f;
    }), o && e.root.value.classList.remove("v-overlay--scroll-blocked");
  });
}
function w1(e, t, n) {
  let a = !1, l = -1, i = -1;
  function o(r) {
    g1(() => {
      var u, c;
      const s = performance.now();
      (c = (u = e.updateLocation).value) == null || c.call(u, r), a = (performance.now() - s) / (1e3 / 60) > 2;
    });
  }
  i = (typeof requestIdleCallback > "u" ? (r) => r() : requestIdleCallback)(() => {
    n.run(() => {
      Fy(ed(e.target.value, e.contentEl.value), (r) => {
        a ? (cancelAnimationFrame(l), l = requestAnimationFrame(() => {
          l = requestAnimationFrame(() => {
            o(r);
          });
        })) : o(r);
      });
    });
  }), Dt(() => {
    typeof cancelIdleCallback < "u" && cancelIdleCallback(i), cancelAnimationFrame(l);
  });
}
function ed(e, t) {
  return Array.isArray(e) ? document.elementsFromPoint(...e).find((n) => !(t != null && t.contains(n))) : e ?? t;
}
function Fy(e, t) {
  const n = [document, ...pr(e)];
  n.forEach((a) => {
    a.addEventListener("scroll", t, {
      passive: !0
    });
  }), Dt(() => {
    n.forEach((a) => {
      a.removeEventListener("scroll", t);
    });
  });
}
const Au = Symbol.for("vuetify:v-menu"), td = z({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function nd(e, t) {
  let n = () => {
  };
  function a(o) {
    n == null || n();
    const r = Number(o ? e.openDelay : e.closeDelay);
    return new Promise((s) => {
      n = Ix(r, () => {
        t == null || t(o), s(o);
      });
    });
  }
  function l() {
    return a(!0);
  }
  function i() {
    return a(!1);
  }
  return {
    clearDelay: n,
    runOpenDelay: l,
    runCloseDelay: i
  };
}
const _1 = z({
  target: [String, Object],
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...td()
}, "VOverlay-activator");
function x1(e, t) {
  let {
    isActive: n,
    isTop: a,
    contentEl: l
  } = t;
  const i = St("useActivator"), o = Z();
  let r = !1, s = !1, d = !0;
  const u = x(() => e.openOnFocus || e.openOnFocus == null && e.openOnHover), c = x(() => e.openOnClick || e.openOnClick == null && !e.openOnHover && !u.value), {
    runOpenDelay: f,
    runCloseDelay: v
  } = nd(e, (D) => {
    D === (e.openOnHover && r || u.value && s) && !(e.openOnHover && n.value && !a.value) && (n.value !== D && (d = !0), n.value = D);
  }), m = Z(), h = {
    onClick: (D) => {
      D.stopPropagation(), o.value = D.currentTarget || D.target, n.value || (m.value = [D.clientX, D.clientY]), n.value = !n.value;
    },
    onMouseenter: (D) => {
      var N;
      (N = D.sourceCapabilities) != null && N.firesTouchEvents || (r = !0, o.value = D.currentTarget || D.target, f());
    },
    onMouseleave: (D) => {
      r = !1, v();
    },
    onFocus: (D) => {
      ni(D.target, ":focus-visible") !== !1 && (s = !0, D.stopPropagation(), o.value = D.currentTarget || D.target, f());
    },
    onBlur: (D) => {
      s = !1, D.stopPropagation(), v();
    }
  }, g = x(() => {
    const D = {};
    return c.value && (D.onClick = h.onClick), e.openOnHover && (D.onMouseenter = h.onMouseenter, D.onMouseleave = h.onMouseleave), u.value && (D.onFocus = h.onFocus, D.onBlur = h.onBlur), D;
  }), p = x(() => {
    const D = {};
    if (e.openOnHover && (D.onMouseenter = () => {
      r = !0, f();
    }, D.onMouseleave = () => {
      r = !1, v();
    }), u.value && (D.onFocusin = () => {
      s = !0, f();
    }, D.onFocusout = () => {
      s = !1, v();
    }), e.closeOnContentClick) {
      const N = Me(Au, null);
      D.onClick = () => {
        n.value = !1, N == null || N.closeParents();
      };
    }
    return D;
  }), y = x(() => {
    const D = {};
    return e.openOnHover && (D.onMouseenter = () => {
      d && (r = !0, d = !1, f());
    }, D.onMouseleave = () => {
      r = !1, v();
    }), D;
  });
  me(a, (D) => {
    var N;
    D && (e.openOnHover && !r && (!u.value || !s) || u.value && !s && (!e.openOnHover || !r)) && !((N = l.value) != null && N.contains(document.activeElement)) && (n.value = !1);
  }), me(n, (D) => {
    D || setTimeout(() => {
      m.value = void 0;
    });
  }, {
    flush: "post"
  });
  const _ = gr();
  ut(() => {
    _.value && He(() => {
      o.value = _.el;
    });
  });
  const E = gr(), k = x(() => e.target === "cursor" && m.value ? m.value : E.value ? E.el : Hy(e.target, i) || o.value), P = x(() => Array.isArray(k.value) ? void 0 : k.value);
  let A;
  return me(() => !!e.activator, (D) => {
    D && qe ? (A = Jl(), A.run(() => {
      k1(e, i, {
        activatorEl: o,
        activatorEvents: g
      });
    })) : A && A.stop();
  }, {
    flush: "post",
    immediate: !0
  }), Dt(() => {
    A == null || A.stop();
  }), {
    activatorEl: o,
    activatorRef: _,
    target: k,
    targetEl: P,
    targetRef: E,
    activatorEvents: g,
    contentEvents: p,
    scrimEvents: y
  };
}
function k1(e, t, n) {
  let {
    activatorEl: a,
    activatorEvents: l
  } = n;
  me(() => e.activator, (s, d) => {
    if (d && s !== d) {
      const u = r(d);
      u && o(u);
    }
    s && He(() => i());
  }, {
    immediate: !0
  }), me(() => e.activatorProps, () => {
    i();
  }), Dt(() => {
    o();
  });
  function i() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : r(), d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    s && Bx(s, Q(l.value, d));
  }
  function o() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : r(), d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.activatorProps;
    s && Mx(s, Q(l.value, d));
  }
  function r() {
    let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activator;
    const d = Hy(s, t);
    return a.value = (d == null ? void 0 : d.nodeType) === Node.ELEMENT_NODE ? d : void 0, a.value;
  }
}
function Hy(e, t) {
  var a, l;
  if (!e) return;
  let n;
  if (e === "parent") {
    let i = (l = (a = t == null ? void 0 : t.proxy) == null ? void 0 : a.$el) == null ? void 0 : l.parentNode;
    for (; i != null && i.hasAttribute("data-no-activator"); )
      i = i.parentNode;
    n = i;
  } else typeof e == "string" ? n = document.querySelector(e) : "$el" in e ? n = e.$el : n = e;
  return n;
}
function zy() {
  if (!qe) return fe(!1);
  const {
    ssr: e
  } = Vn();
  if (e) {
    const t = fe(!1);
    return At(() => {
      t.value = !0;
    }), t;
  } else
    return fe(!0);
}
const ad = z({
  eager: Boolean
}, "lazy");
function ld(e, t) {
  const n = fe(!1), a = R(() => n.value || e.eager || t.value);
  me(t, () => n.value = !0);
  function l() {
    e.eager || (n.value = !1);
  }
  return {
    isBooted: n,
    hasContent: a,
    onAfterLeave: l
  };
}
function Tl() {
  const t = St("useScopeId").vnode.scopeId;
  return {
    scopeId: t ? {
      [t]: ""
    } : void 0
  };
}
const Bv = Symbol.for("vuetify:stack"), Ii = It([]);
function C1(e, t, n) {
  const a = St("useStack"), l = !n, i = Me(Bv, void 0), o = It({
    activeChildren: /* @__PURE__ */ new Set()
  });
  at(Bv, o);
  const r = fe(Number(un(t)));
  Gt(e, () => {
    var c;
    const u = (c = Ii.at(-1)) == null ? void 0 : c[1];
    r.value = u ? u + 10 : Number(un(t)), l && Ii.push([a.uid, r.value]), i == null || i.activeChildren.add(a.uid), Dt(() => {
      if (l) {
        const f = Pe(Ii).findIndex((v) => v[0] === a.uid);
        Ii.splice(f, 1);
      }
      i == null || i.activeChildren.delete(a.uid);
    });
  });
  const s = fe(!0);
  l && ut(() => {
    var c;
    const u = ((c = Ii.at(-1)) == null ? void 0 : c[0]) === a.uid;
    setTimeout(() => s.value = u);
  });
  const d = R(() => !o.activeChildren.size);
  return {
    globalTop: vl(s),
    localTop: d,
    stackStyles: R(() => ({
      zIndex: r.value
    }))
  };
}
function V1(e) {
  return {
    teleportTarget: x(() => {
      const n = e();
      if (n === !0 || !qe) return;
      const a = n === !1 ? document.body : typeof n == "string" ? document.querySelector(n) : n;
      if (a == null) {
        fn(`Unable to locate target ${n}`);
        return;
      }
      let l = [...a.children].find((i) => i.matches(".v-overlay-container"));
      return l || (l = document.createElement("div"), l.className = "v-overlay-container", a.appendChild(l)), l;
    })
  };
}
function E1() {
  return !0;
}
function jy(e, t, n) {
  if (!e || Wy(e, n) === !1) return !1;
  const a = Ig(t);
  if (typeof ShadowRoot < "u" && a instanceof ShadowRoot && a.host === e.target) return !1;
  const l = (typeof n.value == "object" && n.value.include || (() => []))();
  return l.push(t), !l.some((i) => i == null ? void 0 : i.contains(e.target));
}
function Wy(e, t) {
  return (typeof t.value == "object" && t.value.closeConditional || E1)(e);
}
function P1(e, t, n) {
  const a = typeof n.value == "function" ? n.value : n.value.handler;
  e.shadowTarget = e.target, t._clickOutside.lastMousedownWasOutside && jy(e, t, n) && setTimeout(() => {
    Wy(e, n) && a && a(e);
  }, 0);
}
function Mv(e, t) {
  const n = Ig(e);
  t(document), typeof ShadowRoot < "u" && n instanceof ShadowRoot && t(n);
}
const Tu = {
  // [data-app] may not be found
  // if using bind, inserted makes
  // sure that the root element is
  // available, iOS does not support
  // clicks on body
  mounted(e, t) {
    const n = (l) => P1(l, e, t), a = (l) => {
      e._clickOutside.lastMousedownWasOutside = jy(l, e, t);
    };
    Mv(e, (l) => {
      l.addEventListener("click", n, !0), l.addEventListener("mousedown", a, !0);
    }), e._clickOutside || (e._clickOutside = {
      lastMousedownWasOutside: !1
    }), e._clickOutside[t.instance.$.uid] = {
      onClick: n,
      onMousedown: a
    };
  },
  beforeUnmount(e, t) {
    e._clickOutside && (Mv(e, (n) => {
      var i;
      if (!n || !((i = e._clickOutside) != null && i[t.instance.$.uid])) return;
      const {
        onClick: a,
        onMousedown: l
      } = e._clickOutside[t.instance.$.uid];
      n.removeEventListener("click", a, !0), n.removeEventListener("mousedown", l, !0);
    }), delete e._clickOutside[t.instance.$.uid]);
  }
};
function I1(e) {
  const {
    modelValue: t,
    color: n,
    ...a
  } = e;
  return b(Ma, {
    name: "fade-transition",
    appear: !0
  }, {
    default: () => [e.modelValue && S("div", Q({
      class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
      style: e.color.backgroundColorStyles.value
    }, a), null)]
  });
}
const Po = z({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: !0
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  opacity: [Number, String],
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ..._1(),
  ...ke(),
  ...kt(),
  ...ad(),
  ...d1(),
  ...y1(),
  ...We(),
  ...Wn()
}, "VOverlay"), oa = ne()({
  name: "VOverlay",
  directives: {
    vClickOutside: Tu
  },
  inheritAttrs: !1,
  props: {
    _disableGlobalStack: Boolean,
    ...Po()
  },
  emits: {
    "click:outside": (e) => !0,
    "update:modelValue": (e) => !0,
    keydown: (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: a,
      emit: l
    } = t;
    const i = St("VOverlay"), o = Z(), r = Z(), s = Z(), d = Ee(e, "modelValue"), u = x({
      get: () => d.value,
      set: (B) => {
        B && e.disabled || (d.value = B);
      }
    }), {
      themeClasses: c
    } = Ye(e), {
      rtlClasses: f,
      isRtl: v
    } = Et(), {
      hasContent: m,
      onAfterLeave: h
    } = ld(e, u), g = Xe(() => typeof e.scrim == "string" ? e.scrim : null), {
      globalTop: p,
      localTop: y,
      stackStyles: _
    } = C1(u, () => e.zIndex, e._disableGlobalStack), {
      activatorEl: E,
      activatorRef: k,
      target: P,
      targetEl: A,
      targetRef: D,
      activatorEvents: N,
      contentEvents: V,
      scrimEvents: I
    } = x1(e, {
      isActive: u,
      isTop: y,
      contentEl: s
    }), {
      teleportTarget: w
    } = V1(() => {
      var ie, de, Se;
      const B = e.attach || e.contained;
      if (B) return B;
      const G = ((ie = E == null ? void 0 : E.value) == null ? void 0 : ie.getRootNode()) || ((Se = (de = i.proxy) == null ? void 0 : de.$el) == null ? void 0 : Se.getRootNode());
      return G instanceof ShadowRoot ? G : !1;
    }), {
      dimensionStyles: T
    } = Ct(e), M = zy(), {
      scopeId: W
    } = Tl();
    me(() => e.disabled, (B) => {
      B && (u.value = !1);
    });
    const {
      contentStyles: J,
      updateLocation: ee
    } = f1(e, {
      isRtl: v,
      contentEl: s,
      target: P,
      isActive: u
    });
    b1(e, {
      root: o,
      contentEl: s,
      targetEl: A,
      target: P,
      isActive: u,
      updateLocation: ee
    });
    function Y(B) {
      l("click:outside", B), e.persistent ? oe() : u.value = !1;
    }
    function L(B) {
      return u.value && p.value && // If using scrim, only close if clicking on it rather than anything opened on top
      (!e.scrim || B.target === r.value || B instanceof MouseEvent && B.shadowTarget === r.value);
    }
    qe && me(u, (B) => {
      B ? window.addEventListener("keydown", H) : window.removeEventListener("keydown", H);
    }, {
      immediate: !0
    }), Wt(() => {
      qe && window.removeEventListener("keydown", H);
    });
    function H(B) {
      var G, ie, de;
      B.key === "Escape" && p.value && ((G = s.value) != null && G.contains(document.activeElement) || l("keydown", B), e.persistent ? oe() : (u.value = !1, (ie = s.value) != null && ie.contains(document.activeElement) && ((de = E.value) == null || de.focus())));
    }
    function j(B) {
      B.key === "Escape" && !p.value || l("keydown", B);
    }
    const U = ey();
    Gt(() => e.closeOnBack, () => {
      cV(U, (B) => {
        p.value && u.value ? (B(!1), e.persistent ? oe() : u.value = !1) : B();
      });
    });
    const F = Z();
    me(() => u.value && (e.absolute || e.contained) && w.value == null, (B) => {
      if (B) {
        const G = Oc(o.value);
        G && G !== document.scrollingElement && (F.value = G.scrollTop);
      }
    });
    function oe() {
      e.noClickAnimation || s.value && ga(s.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: qi
      });
    }
    function ve() {
      l("afterEnter");
    }
    function _e() {
      h(), l("afterLeave");
    }
    return re(() => {
      var B;
      return S(ye, null, [(B = n.activator) == null ? void 0 : B.call(n, {
        isActive: u.value,
        targetRef: D,
        props: Q({
          ref: k
        }, N.value, e.activatorProps)
      }), M.value && m.value && b(JS, {
        disabled: !w.value,
        to: w.value
      }, {
        default: () => [S("div", Q({
          class: ["v-overlay", {
            "v-overlay--absolute": e.absolute || e.contained,
            "v-overlay--active": u.value,
            "v-overlay--contained": e.contained
          }, c.value, f.value, e.class],
          style: [_.value, {
            "--v-overlay-opacity": e.opacity,
            top: pe(F.value)
          }, e.style],
          ref: o,
          onKeydown: j
        }, W, a), [b(I1, Q({
          color: g,
          modelValue: u.value && !!e.scrim,
          ref: r
        }, I.value), null), b(Zt, {
          appear: !0,
          persisted: !0,
          transition: e.transition,
          target: P.value,
          onAfterEnter: ve,
          onAfterLeave: _e
        }, {
          default: () => {
            var G;
            return [dt(S("div", Q({
              ref: s,
              class: ["v-overlay__content", e.contentClass],
              style: [T.value, J.value]
            }, V.value, e.contentProps), [(G = n.default) == null ? void 0 : G.call(n, {
              isActive: u
            })]), [[Nn, u.value], [Tu, {
              handler: Y,
              closeConditional: L,
              include: () => [E.value]
            }]])];
          }
        })])]
      })]);
    }), {
      activatorEl: E,
      scrimEl: r,
      target: P,
      animateClick: oe,
      contentEl: s,
      globalTop: p,
      localTop: y,
      updateLocation: ee
    };
  }
}), Uy = z({
  // TODO
  // disableKeys: Boolean,
  id: String,
  submenu: Boolean,
  disableInitialFocus: Boolean,
  ...tt(Po({
    closeDelay: 250,
    closeOnContentClick: !0,
    locationStrategy: "connected",
    location: void 0,
    openDelay: 300,
    scrim: !1,
    scrollStrategy: "reposition",
    transition: {
      component: jr
    }
  }), ["absolute"])
}, "VMenu"), si = ne()({
  name: "VMenu",
  props: Uy(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue"), {
      scopeId: l
    } = Tl(), {
      isRtl: i
    } = Et(), o = Yt(), r = R(() => e.id || `v-menu-${o}`), s = Z(), d = Me(Au, null), u = fe(/* @__PURE__ */ new Set());
    at(Au, {
      register() {
        u.value.add(o);
      },
      unregister() {
        u.value.delete(o);
      },
      closeParents(g) {
        setTimeout(() => {
          var p;
          !u.value.size && !e.persistent && (g == null || (p = s.value) != null && p.contentEl && !Nx(g, s.value.contentEl)) && (a.value = !1, d == null || d.closeParents());
        }, 40);
      }
    }), Wt(() => {
      d == null || d.unregister(), document.removeEventListener("focusin", c);
    }), vc(() => a.value = !1);
    async function c(g) {
      var _, E, k;
      const p = g.relatedTarget, y = g.target;
      await He(), a.value && p !== y && ((_ = s.value) != null && _.contentEl) && // We're the topmost menu
      ((E = s.value) != null && E.globalTop) && // It isn't the document or the menu body
      ![document, s.value.contentEl].includes(y) && // It isn't inside the menu body
      !s.value.contentEl.contains(y) && ((k = Yi(s.value.contentEl)[0]) == null || k.focus());
    }
    me(a, (g) => {
      g ? (d == null || d.register(), qe && !e.disableInitialFocus && document.addEventListener("focusin", c, {
        once: !0
      })) : (d == null || d.unregister(), qe && document.removeEventListener("focusin", c));
    }, {
      immediate: !0
    });
    function f(g) {
      d == null || d.closeParents(g);
    }
    function v(g) {
      var p, y, _, E, k;
      if (!e.disabled)
        if (g.key === "Tab" || g.key === "Enter" && !e.closeOnContentClick) {
          if (g.key === "Enter" && (g.target instanceof HTMLTextAreaElement || g.target instanceof HTMLInputElement && g.target.closest("form"))) return;
          g.key === "Enter" && g.preventDefault(), hg(Yi((p = s.value) == null ? void 0 : p.contentEl, !1), g.shiftKey ? "prev" : "next", (A) => A.tabIndex >= 0) || (a.value = !1, (_ = (y = s.value) == null ? void 0 : y.activatorEl) == null || _.focus());
        } else e.submenu && g.key === (i.value ? "ArrowRight" : "ArrowLeft") && (a.value = !1, (k = (E = s.value) == null ? void 0 : E.activatorEl) == null || k.focus());
    }
    function m(g) {
      var y;
      if (e.disabled) return;
      const p = (y = s.value) == null ? void 0 : y.contentEl;
      p && a.value ? g.key === "ArrowDown" ? (g.preventDefault(), g.stopImmediatePropagation(), cl(p, "next")) : g.key === "ArrowUp" ? (g.preventDefault(), g.stopImmediatePropagation(), cl(p, "prev")) : e.submenu && (g.key === (i.value ? "ArrowRight" : "ArrowLeft") ? a.value = !1 : g.key === (i.value ? "ArrowLeft" : "ArrowRight") && (g.preventDefault(), cl(p, "first"))) : (e.submenu ? g.key === (i.value ? "ArrowLeft" : "ArrowRight") : ["ArrowDown", "ArrowUp"].includes(g.key)) && (a.value = !0, g.preventDefault(), setTimeout(() => setTimeout(() => m(g))));
    }
    const h = x(() => Q({
      "aria-haspopup": "menu",
      "aria-expanded": String(a.value),
      "aria-controls": r.value,
      onKeydown: m
    }, e.activatorProps));
    return re(() => {
      const g = oa.filterProps(e);
      return b(oa, Q({
        ref: s,
        id: r.value,
        class: ["v-menu", e.class],
        style: e.style
      }, g, {
        modelValue: a.value,
        "onUpdate:modelValue": (p) => a.value = p,
        absolute: !0,
        activatorProps: h.value,
        location: e.location ?? (e.submenu ? "end" : "bottom"),
        "onClick:outside": f,
        onKeydown: v
      }, l), {
        activator: n.activator,
        default: function() {
          for (var p = arguments.length, y = new Array(p), _ = 0; _ < p; _++)
            y[_] = arguments[_];
          return b(Be, {
            root: "VMenu"
          }, {
            default: () => {
              var E;
              return [(E = n.default) == null ? void 0 : E.call(n, ...y)];
            }
          });
        }
      });
    }), Lt({
      id: r,
      openChildren: u
    }, s);
  }
}), N1 = z({
  active: Boolean,
  disabled: Boolean,
  max: [Number, String],
  value: {
    type: [Number, String],
    default: 0
  },
  ...ke(),
  ...Wn({
    transition: {
      component: Wc
    }
  })
}, "VCounter"), qr = ne()({
  name: "VCounter",
  functional: !0,
  props: N1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = R(() => e.max ? `${e.value} / ${e.max}` : String(e.value));
    return re(() => b(Zt, {
      transition: e.transition
    }, {
      default: () => [dt(S("div", {
        class: le(["v-counter", {
          "text-error": e.max && !e.disabled && parseFloat(e.value) > parseFloat(e.max)
        }, e.class]),
        style: he(e.style)
      }, [n.default ? n.default({
        counter: a.value,
        max: e.max,
        value: e.value
      }) : a.value]), [[Nn, e.active]])]
    })), {};
  }
}), D1 = z({
  floating: Boolean,
  ...ke()
}, "VFieldLabel"), Ai = ne()({
  name: "VFieldLabel",
  props: D1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => b(gi, {
      class: le(["v-field-label", {
        "v-field-label--floating": e.floating
      }, e.class]),
      style: he(e.style)
    }, n)), {};
  }
}), A1 = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"], Io = z({
  appendInnerIcon: Ve,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: Ve,
    default: "$clear"
  },
  active: Boolean,
  centerAffix: {
    type: Boolean,
    default: void 0
  },
  color: String,
  baseColor: String,
  details: Boolean,
  dirty: Boolean,
  disabled: {
    type: Boolean,
    default: null
  },
  glow: Boolean,
  error: Boolean,
  flat: Boolean,
  iconColor: [Boolean, String],
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: Ve,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (e) => A1.includes(e)
  },
  "onClick:clear": zt(),
  "onClick:appendInner": zt(),
  "onClick:prependInner": zt(),
  ...ke(),
  ...Gr(),
  ...ft(),
  ...We()
}, "VField"), Fa = ne()({
  name: "VField",
  inheritAttrs: !1,
  props: {
    id: String,
    ...Eo(),
    ...Io()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: l
    } = t;
    const {
      themeClasses: i
    } = Ye(e), {
      loaderClasses: o
    } = xo(e), {
      focusClasses: r,
      isFocused: s,
      focus: d,
      blur: u
    } = Ea(e), {
      InputIcon: c
    } = fy(e), {
      roundedClasses: f
    } = yt(e), {
      rtlClasses: v
    } = Et(), m = R(() => e.dirty || e.active), h = R(() => !!(e.label || l.label)), g = R(() => !e.singleLine && h.value), p = Yt(), y = x(() => e.id || `input-${p}`), _ = R(() => e.details ? `${y.value}-messages` : void 0), E = Z(), k = Z(), P = Z(), A = x(() => ["plain", "underlined"].includes(e.variant)), D = x(() => e.error || e.disabled ? void 0 : m.value && s.value ? e.color : e.baseColor), N = x(() => {
      if (!(!e.iconColor || e.glow && !s.value))
        return e.iconColor === !0 ? D.value : e.iconColor;
    }), {
      backgroundColorClasses: V,
      backgroundColorStyles: I
    } = Xe(() => e.bgColor), {
      textColorClasses: w,
      textColorStyles: T
    } = jt(D);
    me(m, (J) => {
      if (g.value && !aa()) {
        const ee = E.value.$el, Y = k.value.$el;
        requestAnimationFrame(() => {
          const L = Nc(ee), H = Y.getBoundingClientRect(), j = H.x - L.x, U = H.y - L.y - (L.height / 2 - H.height / 2), F = H.width / 0.75, oe = Math.abs(F - L.width) > 1 ? {
            maxWidth: pe(F)
          } : void 0, ve = getComputedStyle(ee), _e = getComputedStyle(Y), B = parseFloat(ve.transitionDuration) * 1e3 || 150, G = parseFloat(_e.getPropertyValue("--v-field-label-scale")), ie = _e.getPropertyValue("color");
          ee.style.visibility = "visible", Y.style.visibility = "hidden", ga(ee, {
            transform: `translate(${j}px, ${U}px) scale(${G})`,
            color: ie,
            ...oe
          }, {
            duration: B,
            easing: qi,
            direction: J ? "normal" : "reverse"
          }).finished.then(() => {
            ee.style.removeProperty("visibility"), Y.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const M = x(() => ({
      isActive: m,
      isFocused: s,
      controlRef: P,
      blur: u,
      focus: d
    }));
    function W(J) {
      J.target !== document.activeElement && J.preventDefault();
    }
    return re(() => {
      var j, U, F;
      const J = e.variant === "outlined", ee = !!(l["prepend-inner"] || e.prependInnerIcon), Y = !!(e.clearable || l.clear) && !e.disabled, L = !!(l["append-inner"] || e.appendInnerIcon || Y), H = () => l.label ? l.label({
        ...M.value,
        label: e.label,
        props: {
          for: y.value
        }
      }) : e.label;
      return S("div", Q({
        class: ["v-field", {
          "v-field--active": m.value,
          "v-field--appended": L,
          "v-field--center-affix": e.centerAffix ?? !A.value,
          "v-field--disabled": e.disabled,
          "v-field--dirty": e.dirty,
          "v-field--error": e.error,
          "v-field--glow": e.glow,
          "v-field--flat": e.flat,
          "v-field--has-background": !!e.bgColor,
          "v-field--persistent-clear": e.persistentClear,
          "v-field--prepended": ee,
          "v-field--reverse": e.reverse,
          "v-field--single-line": e.singleLine,
          "v-field--no-label": !H(),
          [`v-field--variant-${e.variant}`]: !0
        }, i.value, V.value, r.value, o.value, f.value, v.value, e.class],
        style: [I.value, e.style],
        onClick: W
      }, n), [S("div", {
        class: "v-field__overlay"
      }, null), b(ko, {
        name: "v-field",
        active: !!e.loading,
        color: e.error ? "error" : typeof e.loading == "string" ? e.loading : e.color
      }, {
        default: l.loader
      }), ee && S("div", {
        key: "prepend",
        class: "v-field__prepend-inner"
      }, [e.prependInnerIcon && b(c, {
        key: "prepend-icon",
        name: "prependInner",
        color: N.value
      }, null), (j = l["prepend-inner"]) == null ? void 0 : j.call(l, M.value)]), S("div", {
        class: "v-field__field",
        "data-no-activator": ""
      }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && g.value && b(Ai, {
        key: "floating-label",
        ref: k,
        class: le([w.value]),
        floating: !0,
        for: y.value,
        "aria-hidden": !m.value,
        style: he(T.value)
      }, {
        default: () => [H()]
      }), h.value && b(Ai, {
        key: "label",
        ref: E,
        for: y.value
      }, {
        default: () => [H()]
      }), ((U = l.default) == null ? void 0 : U.call(l, {
        ...M.value,
        props: {
          id: y.value,
          class: "v-field__input",
          "aria-describedby": _.value
        },
        focus: d,
        blur: u
      })) ?? S("div", {
        id: y.value,
        class: "v-field__input",
        "aria-describedby": _.value
      }, null)]), Y && b(Uc, {
        key: "clear"
      }, {
        default: () => [dt(S("div", {
          class: "v-field__clearable",
          onMousedown: (oe) => {
            oe.preventDefault(), oe.stopPropagation();
          }
        }, [b(Be, {
          defaults: {
            VIcon: {
              icon: e.clearIcon
            }
          }
        }, {
          default: () => [l.clear ? l.clear({
            ...M.value,
            props: {
              onFocus: d,
              onBlur: u,
              onClick: e["onClick:clear"],
              tabindex: -1
            }
          }) : b(c, {
            name: "clear",
            onFocus: d,
            onBlur: u,
            tabindex: -1
          }, null)]
        })]), [[Nn, e.dirty]])]
      }), L && S("div", {
        key: "append",
        class: "v-field__append-inner"
      }, [(F = l["append-inner"]) == null ? void 0 : F.call(l, M.value), e.appendInnerIcon && b(c, {
        key: "append-icon",
        name: "appendInner",
        color: N.value
      }, null)]), S("div", {
        class: le(["v-field__outline", w.value]),
        style: he(T.value)
      }, [J && S(ye, null, [S("div", {
        class: "v-field__outline__start"
      }, null), g.value && S("div", {
        class: "v-field__outline__notch"
      }, [b(Ai, {
        ref: k,
        floating: !0,
        for: y.value,
        "aria-hidden": !m.value
      }, {
        default: () => [H()]
      })]), S("div", {
        class: "v-field__outline__end"
      }, null)]), A.value && g.value && b(Ai, {
        ref: k,
        floating: !0,
        for: y.value,
        "aria-hidden": !m.value
      }, {
        default: () => [H()]
      })])]);
    }), {
      controlRef: P,
      fieldIconColor: N
    };
  }
}), Gy = z({
  autocomplete: String
}, "autocomplete");
function Ky(e) {
  const t = Yt(), n = fe(0), a = R(() => e.autocomplete === "suppress"), l = R(() => a.value ? `${e.name}-${t}-${n.value}` : e.name), i = R(() => a.value ? "off" : e.autocomplete);
  return {
    isSuppressing: a,
    fieldAutocomplete: i,
    fieldName: l,
    update: () => n.value = (/* @__PURE__ */ new Date()).getTime()
  };
}
function Yy(e) {
  function t(n, a) {
    var l, i;
    !e.autofocus || !n || (i = (l = a[0].target) == null ? void 0 : l.focus) == null || i.call(l);
  }
  return {
    onIntersect: t
  };
}
const T1 = ["color", "file", "time", "date", "datetime-local", "week", "month"], No = z({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: [Number, Function],
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  role: String,
  type: {
    type: String,
    default: "text"
  },
  modelModifiers: Object,
  ...Gy(),
  ...Pa(),
  ...Io()
}, "VTextField"), wa = ne()({
  name: "VTextField",
  directives: {
    vIntersect: Hn
  },
  inheritAttrs: !1,
  props: No(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: l
    } = t;
    const i = Ee(e, "modelValue"), {
      isFocused: o,
      focus: r,
      blur: s
    } = Ea(e), {
      onIntersect: d
    } = Yy(e), u = x(() => typeof e.counterValue == "function" ? e.counterValue(i.value) : typeof e.counterValue == "number" ? e.counterValue : (i.value ?? "").toString().length), c = x(() => {
      if (n.maxlength) return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    }), f = x(() => ["plain", "underlined"].includes(e.variant)), v = Z(), m = Z(), h = Z(), g = Ky(e), p = x(() => T1.includes(e.type) || e.persistentPlaceholder || o.value || e.active);
    function y() {
      g.isSuppressing.value && g.update(), o.value || r(), He(() => {
        var A;
        h.value !== document.activeElement && ((A = h.value) == null || A.focus());
      });
    }
    function _(A) {
      a("mousedown:control", A), A.target !== h.value && (y(), A.preventDefault());
    }
    function E(A) {
      a("click:control", A);
    }
    function k(A, D) {
      A.stopPropagation(), y(), He(() => {
        i.value = null, D(), bo(e["onClick:clear"], A);
      });
    }
    function P(A) {
      var N;
      const D = A.target;
      if (i.value = D.value, (N = e.modelModifiers) != null && N.trim && ["text", "search", "password", "tel", "url"].includes(e.type)) {
        const V = [D.selectionStart, D.selectionEnd];
        He(() => {
          D.selectionStart = V[0], D.selectionEnd = V[1];
        });
      }
    }
    return re(() => {
      const A = !!(l.counter || e.counter !== !1 && e.counter != null), D = !!(A || l.details), [N, V] = za(n), {
        modelValue: I,
        ...w
      } = Kt.filterProps(e), T = Fa.filterProps(e);
      return b(Kt, Q({
        ref: v,
        modelValue: i.value,
        "onUpdate:modelValue": (M) => i.value = M,
        class: ["v-text-field", {
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-input--plain-underlined": f.value
        }, e.class],
        style: e.style
      }, N, w, {
        centerAffix: !f.value,
        focused: o.value
      }), {
        ...l,
        default: (M) => {
          let {
            id: W,
            isDisabled: J,
            isDirty: ee,
            isReadonly: Y,
            isValid: L,
            hasDetails: H,
            reset: j
          } = M;
          return b(Fa, Q({
            ref: m,
            onMousedown: _,
            onClick: E,
            "onClick:clear": (U) => k(U, j),
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"],
            role: e.role
          }, tt(T, ["onClick:clear"]), {
            id: W.value,
            active: p.value || ee.value,
            dirty: ee.value || e.dirty,
            disabled: J.value,
            focused: o.value,
            details: H.value,
            error: L.value === !1
          }), {
            ...l,
            default: (U) => {
              let {
                props: {
                  class: F,
                  ...oe
                }
              } = U;
              const ve = dt(S("input", Q({
                ref: h,
                value: i.value,
                onInput: P,
                autofocus: e.autofocus,
                readonly: Y.value,
                disabled: J.value,
                name: g.fieldName.value,
                autocomplete: g.fieldAutocomplete.value,
                placeholder: e.placeholder,
                size: 1,
                role: e.role,
                type: e.type,
                onFocus: r,
                onBlur: s
              }, oe, V), null), [[Hn, {
                handler: d
              }, null, {
                once: !0
              }]]);
              return S(ye, null, [e.prefix && S("span", {
                class: "v-text-field__prefix"
              }, [S("span", {
                class: "v-text-field__prefix__text"
              }, [e.prefix])]), l.default ? S("div", {
                class: le(F),
                "data-no-activator": ""
              }, [l.default(), ve]) : Ln(ve, {
                class: F
              }), e.suffix && S("span", {
                class: "v-text-field__suffix"
              }, [S("span", {
                class: "v-text-field__suffix__text"
              }, [e.suffix])])]);
            }
          });
        },
        details: D ? (M) => {
          var W;
          return S(ye, null, [(W = l.details) == null ? void 0 : W.call(l, M), A && S(ye, null, [S("span", null, null), b(qr, {
            active: e.persistentCounter || o.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, l.counter)])]);
        } : void 0
      });
    }), Lt({}, v, m, h);
  }
}), O1 = z({
  renderless: Boolean,
  ...ke()
}, "VVirtualScrollItem"), qy = ne()({
  name: "VVirtualScrollItem",
  inheritAttrs: !1,
  props: O1(),
  emits: {
    "update:height": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: l
    } = t;
    const {
      resizeRef: i,
      contentRect: o
    } = In(void 0, "border");
    me(() => {
      var r;
      return (r = o.value) == null ? void 0 : r.height;
    }, (r) => {
      r != null && a("update:height", r);
    }), re(() => {
      var r, s;
      return e.renderless ? S(ye, null, [(r = l.default) == null ? void 0 : r.call(l, {
        itemRef: i
      })]) : S("div", Q({
        ref: i,
        class: ["v-virtual-scroll__item", e.class],
        style: e.style
      }, n), [(s = l.default) == null ? void 0 : s.call(l)]);
    });
  }
}), $1 = -1, B1 = 1, Rs = 100, Xy = z({
  itemHeight: {
    type: [Number, String],
    default: null
  },
  itemKey: {
    type: [String, Array, Function],
    default: null
  },
  height: [Number, String]
}, "virtual");
function Jy(e, t) {
  const n = Vn(), a = fe(0);
  ut(() => {
    a.value = parseFloat(e.itemHeight || 0);
  });
  const l = fe(0), i = fe(Math.ceil(
    // Assume 16px items filling the entire screen height if
    // not provided. This is probably incorrect but it minimises
    // the chance of ending up with empty space at the bottom.
    // The default value is set here to avoid poisoning getSize()
    (parseInt(e.height) || n.height.value) / (a.value || 16)
  ) || 1), o = fe(0), r = fe(0), s = Z(), d = Z();
  let u = 0;
  const {
    resizeRef: c,
    contentRect: f
  } = In();
  ut(() => {
    c.value = s.value;
  });
  const v = x(() => {
    var H;
    return s.value === document.documentElement ? n.height.value : ((H = f.value) == null ? void 0 : H.height) || parseInt(e.height) || 0;
  }), m = x(() => !!(s.value && d.value && v.value && a.value));
  let h = Array.from({
    length: t.value.length
  }), g = Array.from({
    length: t.value.length
  });
  const p = fe(0);
  let y = -1;
  function _(H) {
    return h[H] || a.value;
  }
  const E = dg(() => {
    const H = performance.now();
    g[0] = 0;
    const j = t.value.length;
    for (let U = 1; U <= j - 1; U++)
      g[U] = (g[U - 1] || 0) + _(U - 1);
    p.value = Math.max(p.value, performance.now() - H);
  }, p), k = me(m, (H) => {
    H && (k(), u = d.value.offsetTop, E.immediate(), J(), ~y && He(() => {
      qe && window.requestAnimationFrame(() => {
        Y(y), y = -1;
      });
    }));
  });
  Dt(() => {
    E.clear();
  });
  function P(H, j) {
    const U = h[H], F = a.value;
    a.value = F ? Math.min(a.value, j) : j, (U !== j || F !== a.value) && (h[H] = j, E());
  }
  function A(H) {
    H = ot(H, 0, t.value.length - 1);
    const j = Math.floor(H), U = H % 1, F = j + 1, oe = g[j] || 0, ve = g[F] || oe;
    return oe + (ve - oe) * U;
  }
  function D(H) {
    return M1(g, H);
  }
  let N = 0, V = 0, I = 0;
  me(v, (H, j) => {
    j && (J(), H < j && requestAnimationFrame(() => {
      V = 0, J();
    }));
  });
  let w = -1;
  function T() {
    if (!s.value || !d.value) return;
    const H = s.value.scrollTop, j = performance.now();
    j - I > 500 ? (V = Math.sign(H - N), u = d.value.offsetTop) : V = H - N, N = H, I = j, window.clearTimeout(w), w = window.setTimeout(M, 500), J();
  }
  function M() {
    !s.value || !d.value || (V = 0, I = 0, window.clearTimeout(w), J());
  }
  let W = -1;
  function J() {
    cancelAnimationFrame(W), W = requestAnimationFrame(ee);
  }
  function ee() {
    if (!s.value || !v.value || !a.value) return;
    const H = N - u, j = Math.sign(V), U = Math.max(0, H - Rs), F = ot(D(U), 0, t.value.length), oe = H + v.value + Rs, ve = ot(D(oe) + 1, F + 1, t.value.length);
    if (
      // Only update the side we're scrolling towards,
      // the other side will be updated incidentally
      (j !== $1 || F < l.value) && (j !== B1 || ve > i.value)
    ) {
      const _e = A(l.value) - A(F), B = A(ve) - A(i.value);
      Math.max(_e, B) > Rs ? (l.value = F, i.value = ve) : (F <= 0 && (l.value = F), ve >= t.value.length && (i.value = ve));
    }
    o.value = A(l.value), r.value = A(t.value.length) - A(i.value);
  }
  function Y(H) {
    const j = A(H);
    !s.value || H && !j ? y = H : s.value.scrollTop = j;
  }
  const L = x(() => t.value.slice(l.value, i.value).map((H, j) => {
    const U = j + l.value;
    return {
      raw: H,
      index: U,
      key: xt(H, e.itemKey, U)
    };
  }));
  return me(t, () => {
    h = Array.from({
      length: t.value.length
    }), g = Array.from({
      length: t.value.length
    }), E.immediate(), J();
  }, {
    deep: 1
  }), {
    calculateVisibleItems: J,
    containerRef: s,
    markerRef: d,
    computedItems: L,
    paddingTop: o,
    paddingBottom: r,
    scrollToIndex: Y,
    handleScroll: T,
    handleScrollend: M,
    handleItemResize: P
  };
}
function M1(e, t) {
  let n = e.length - 1, a = 0, l = 0, i = null, o = -1;
  if (e[n] < t)
    return n;
  for (; a <= n; )
    if (l = a + n >> 1, i = e[l], i > t)
      n = l - 1;
    else if (i < t)
      o = l, a = l + 1;
    else return i === t ? l : a;
  return o;
}
const R1 = z({
  items: {
    type: Array,
    default: () => []
  },
  renderless: Boolean,
  ...Xy(),
  ...ke(),
  ...kt()
}, "VVirtualScroll"), Xr = ne()({
  name: "VVirtualScroll",
  props: R1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = St("VVirtualScroll"), {
      dimensionStyles: l
    } = Ct(e), {
      calculateVisibleItems: i,
      containerRef: o,
      markerRef: r,
      handleScroll: s,
      handleScrollend: d,
      handleItemResize: u,
      scrollToIndex: c,
      paddingTop: f,
      paddingBottom: v,
      computedItems: m
    } = Jy(e, R(() => e.items));
    return Gt(() => e.renderless, () => {
      function h() {
        var y, _;
        const p = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) ? "addEventListener" : "removeEventListener";
        o.value === document.documentElement ? (document[p]("scroll", s, {
          passive: !0
        }), document[p]("scrollend", d)) : ((y = o.value) == null || y[p]("scroll", s, {
          passive: !0
        }), (_ = o.value) == null || _[p]("scrollend", d));
      }
      At(() => {
        o.value = Oc(a.vnode.el, !0), h(!0);
      }), Dt(h);
    }), re(() => {
      const h = m.value.map((g) => b(qy, {
        key: g.key,
        renderless: e.renderless,
        "onUpdate:height": (p) => u(g.index, p)
      }, {
        default: (p) => {
          var y;
          return (y = n.default) == null ? void 0 : y.call(n, {
            item: g.raw,
            index: g.index,
            ...p
          });
        }
      }));
      return e.renderless ? S(ye, null, [S("div", {
        ref: r,
        class: "v-virtual-scroll__spacer",
        style: {
          paddingTop: pe(f.value)
        }
      }, null), h, S("div", {
        class: "v-virtual-scroll__spacer",
        style: {
          paddingBottom: pe(v.value)
        }
      }, null)]) : S("div", {
        ref: o,
        class: le(["v-virtual-scroll", e.class]),
        onScrollPassive: s,
        onScrollend: d,
        style: he([l.value, e.style])
      }, [S("div", {
        ref: r,
        class: "v-virtual-scroll__container",
        style: {
          paddingTop: pe(f.value),
          paddingBottom: pe(v.value)
        }
      }, [h])]);
    }), {
      calculateVisibleItems: i,
      scrollToIndex: c
    };
  }
});
function id(e, t) {
  const n = fe(!1);
  let a;
  function l(r) {
    cancelAnimationFrame(a), n.value = !0, a = requestAnimationFrame(() => {
      a = requestAnimationFrame(() => {
        n.value = !1;
      });
    });
  }
  async function i() {
    await new Promise((r) => requestAnimationFrame(r)), await new Promise((r) => requestAnimationFrame(r)), await new Promise((r) => requestAnimationFrame(r)), await new Promise((r) => {
      if (n.value) {
        const s = me(n, () => {
          s(), r();
        });
      } else r();
    });
  }
  async function o(r) {
    var u, c;
    if (r.key === "Tab" && ((u = t.value) == null || u.focus()), !["PageDown", "PageUp", "Home", "End"].includes(r.key)) return;
    const s = (c = e.value) == null ? void 0 : c.$el;
    if (!s) return;
    (r.key === "Home" || r.key === "End") && s.scrollTo({
      top: r.key === "Home" ? 0 : s.scrollHeight,
      behavior: "smooth"
    }), await i();
    const d = s.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
    if (r.key === "PageDown" || r.key === "Home") {
      const f = s.getBoundingClientRect().top;
      for (const v of d)
        if (v.getBoundingClientRect().top >= f) {
          v.focus();
          break;
        }
    } else {
      const f = s.getBoundingClientRect().bottom;
      for (const v of [...d].reverse())
        if (v.getBoundingClientRect().bottom <= f) {
          v.focus();
          break;
        }
    }
  }
  return {
    onScrollPassive: l,
    onKeydown: o
  };
}
const L1 = z({
  closeText: {
    type: String,
    default: "$vuetify.close"
  },
  openText: {
    type: String,
    default: "$vuetify.open"
  }
}, "autocomplete");
function od(e, t) {
  const {
    t: n
  } = nt(), a = Yt(), l = x(() => `menu-${a}`), i = R(() => un(t)), o = R(() => l.value), r = R(() => n(un(t) ? e.closeText : e.openText));
  return {
    menuId: l,
    ariaExpanded: i,
    ariaControls: o,
    ariaLabel: r
  };
}
const rd = z({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  listProps: {
    type: Object
  },
  menu: Boolean,
  menuIcon: {
    type: Ve,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  itemColor: String,
  noAutoScroll: Boolean,
  ...L1(),
  ...Oy({
    itemChildren: !1
  })
}, "Select"), F1 = z({
  ...rd(),
  ...tt(No({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Wn({
    transition: {
      component: jr
    }
  })
}, "VSelect"), sd = ne()({
  name: "VSelect",
  props: F1(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = nt(), l = Z(), i = Z(), o = Z(), {
      items: r,
      transformIn: s,
      transformOut: d
    } = Zc(e), u = Ee(e, "modelValue", [], (F) => s(F === null ? [null] : ht(F)), (F) => {
      const oe = d(F);
      return e.multiple ? oe : oe[0] ?? null;
    }), c = x(() => typeof e.counterValue == "function" ? e.counterValue(u.value) : typeof e.counterValue == "number" ? e.counterValue : u.value.length), f = yi(e), v = x(() => u.value.map((F) => F.value)), m = fe(!1);
    let h = "", g = -1, p;
    const y = x(() => e.hideSelected ? r.value.filter((F) => !u.value.some((oe) => (e.valueComparator || Mt)(oe, F))) : r.value), _ = x(() => e.hideNoData && !y.value.length || f.isReadonly.value || f.isDisabled.value), E = Ee(e, "menu"), k = x({
      get: () => E.value,
      set: (F) => {
        var oe;
        E.value && !F && ((oe = i.value) != null && oe.openChildren.size) || F && _.value || (E.value = F);
      }
    }), {
      menuId: P,
      ariaExpanded: A,
      ariaControls: D,
      ariaLabel: N
    } = od(e, k), V = x(() => {
      var F;
      return {
        ...e.menuProps,
        activatorProps: {
          ...((F = e.menuProps) == null ? void 0 : F.activatorProps) || {},
          "aria-haspopup": "listbox"
          // Set aria-haspopup to 'listbox'
        }
      };
    }), I = Z(), w = id(I, l);
    function T(F) {
      e.openOnClear && (k.value = !0);
    }
    function M() {
      _.value || (k.value = !k.value);
    }
    function W(F) {
      ai(F) && J(F);
    }
    function J(F) {
      var Ce, C, O;
      if (!F.key || f.isReadonly.value) return;
      ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(F.key) && F.preventDefault(), ["Enter", "ArrowDown", " "].includes(F.key) && (k.value = !0), ["Escape", "Tab"].includes(F.key) && (k.value = !1), F.key === "Home" ? (Ce = I.value) == null || Ce.focus("first") : F.key === "End" && ((C = I.value) == null || C.focus("last"));
      const oe = 1e3;
      if (!ai(F)) return;
      const ve = performance.now();
      ve - p > oe && (h = "", g = -1), h += F.key.toLowerCase(), p = ve;
      const _e = y.value;
      function B() {
        let $ = G();
        return $ || h.at(-1) === h.at(-2) && (h = h.slice(0, -1), $ = G(), $) || (g = -1, $ = G(), $) ? $ : (h = F.key.toLowerCase(), G());
      }
      function G() {
        for (let $ = g + 1; $ < _e.length; $++) {
          const K = _e[$];
          if (K.title.toLowerCase().startsWith(h))
            return [K, $];
        }
      }
      const ie = B();
      if (!ie) return;
      const [de, Se] = ie;
      g = Se, (O = I.value) == null || O.focus(Se), e.multiple || (u.value = [de]);
    }
    function ee(F) {
      let oe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!F.props.disabled)
        if (e.multiple) {
          const ve = u.value.findIndex((B) => (e.valueComparator || Mt)(B.value, F.value)), _e = oe ?? !~ve;
          if (~ve) {
            const B = _e ? [...u.value, F] : [...u.value];
            B.splice(ve, 1), u.value = B;
          } else _e && (u.value = [...u.value, F]);
        } else {
          const ve = oe !== !1;
          u.value = ve ? [F] : [], He(() => {
            k.value = !1;
          });
        }
    }
    function Y(F) {
      var oe;
      (oe = I.value) != null && oe.$el.contains(F.relatedTarget) || (k.value = !1);
    }
    function L() {
      var F;
      e.eager && ((F = o.value) == null || F.calculateVisibleItems());
    }
    function H() {
      var F;
      m.value && ((F = l.value) == null || F.focus());
    }
    function j(F) {
      m.value = !0;
    }
    function U(F) {
      if (F == null) u.value = [];
      else if (ni(l.value, ":autofill") || ni(l.value, ":-webkit-autofill")) {
        const oe = r.value.find((ve) => ve.title === F);
        oe && ee(oe);
      } else l.value && (l.value.value = "");
    }
    return me(k, () => {
      if (!e.hideSelected && k.value && u.value.length) {
        const F = y.value.findIndex((oe) => u.value.some((ve) => (e.valueComparator || Mt)(ve.value, oe.value)));
        qe && !e.noAutoScroll && window.requestAnimationFrame(() => {
          var oe;
          F >= 0 && ((oe = o.value) == null || oe.scrollToIndex(F));
        });
      }
    }), me(r, (F, oe) => {
      k.value || m.value && e.hideNoData && !oe.length && F.length && (k.value = !0);
    }), re(() => {
      const F = !!(e.chips || n.chip), oe = !!(!e.hideNoData || y.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), ve = u.value.length > 0, _e = wa.filterProps(e), B = ve || !m.value && e.label && !e.persistentPlaceholder ? void 0 : e.placeholder;
      return b(wa, Q({
        ref: l
      }, _e, {
        modelValue: u.value.map((G) => G.props.value).join(", "),
        "onUpdate:modelValue": U,
        focused: m.value,
        "onUpdate:focused": (G) => m.value = G,
        validationValue: u.externalValue,
        counterValue: c.value,
        dirty: ve,
        class: ["v-select", {
          "v-select--active-menu": k.value,
          "v-select--chips": !!e.chips,
          [`v-select--${e.multiple ? "multiple" : "single"}`]: !0,
          "v-select--selected": u.value.length,
          "v-select--selection-slot": !!n.selection
        }, e.class],
        style: e.style,
        inputmode: "none",
        placeholder: B,
        "onClick:clear": T,
        "onMousedown:control": M,
        onBlur: Y,
        onKeydown: J,
        "aria-expanded": A.value,
        "aria-controls": D.value,
        "aria-label": N.value,
        title: N.value
      }), {
        ...n,
        default: () => S(ye, null, [b(si, Q({
          id: P.value,
          ref: i,
          modelValue: k.value,
          "onUpdate:modelValue": (G) => k.value = G,
          activator: "parent",
          contentClass: "v-select__content",
          disabled: _.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: L,
          onAfterLeave: H
        }, V.value), {
          default: () => [oe && b(ri, Q({
            ref: I,
            selected: v.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (G) => G.preventDefault(),
            onKeydown: W,
            onFocusin: j,
            tabindex: "-1",
            selectable: !0,
            "aria-live": "polite",
            "aria-label": `${e.label}-list`,
            color: e.itemColor ?? e.color
          }, w, e.listProps), {
            default: () => {
              var G, ie, de;
              return [(G = n["prepend-item"]) == null ? void 0 : G.call(n), !y.value.length && !e.hideNoData && (((ie = n["no-data"]) == null ? void 0 : ie.call(n)) ?? b(zn, {
                key: "no-data",
                title: a(e.noDataText)
              }, null)), b(Xr, {
                ref: o,
                renderless: !0,
                items: y.value,
                itemKey: "value"
              }, {
                default: (Se) => {
                  var X, te, ue;
                  let {
                    item: Ce,
                    index: C,
                    itemRef: O
                  } = Se;
                  const $ = Ax(Ce.props), K = Q(Ce.props, {
                    ref: O,
                    key: Ce.value,
                    onClick: () => ee(Ce, null)
                  });
                  return Ce.type === "divider" ? ((X = n.divider) == null ? void 0 : X.call(n, {
                    props: Ce.raw,
                    index: C
                  })) ?? b(Sn, Q(Ce.props, {
                    key: `divider-${C}`
                  }), null) : Ce.type === "subheader" ? ((te = n.subheader) == null ? void 0 : te.call(n, {
                    props: Ce.raw,
                    index: C
                  })) ?? b(pi, Q(Ce.props, {
                    key: `subheader-${C}`
                  }), null) : ((ue = n.item) == null ? void 0 : ue.call(n, {
                    item: Ce,
                    index: C,
                    props: K
                  })) ?? b(zn, Q(K, {
                    role: "option"
                  }), {
                    prepend: (se) => {
                      let {
                        isSelected: ce
                      } = se;
                      return S(ye, null, [e.multiple && !e.hideSelected ? b(ia, {
                        key: Ce.value,
                        modelValue: ce,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, $.prependAvatar && b(kn, {
                        image: $.prependAvatar
                      }, null), $.prependIcon && b(Ue, {
                        icon: $.prependIcon
                      }, null)]);
                    }
                  });
                }
              }), (de = n["append-item"]) == null ? void 0 : de.call(n)];
            }
          })]
        }), u.value.map((G, ie) => {
          function de(O) {
            O.stopPropagation(), O.preventDefault(), ee(G, !1);
          }
          const Se = {
            "onClick:close": de,
            onKeydown(O) {
              O.key !== "Enter" && O.key !== " " || (O.preventDefault(), O.stopPropagation(), de(O));
            },
            onMousedown(O) {
              O.preventDefault(), O.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, Ce = F ? !!n.chip : !!n.selection, C = Ce ? Fr(F ? n.chip({
            item: G,
            index: ie,
            props: Se
          }) : n.selection({
            item: G,
            index: ie
          })) : void 0;
          if (!(Ce && !C))
            return S("div", {
              key: G.value,
              class: "v-select__selection"
            }, [F ? n.chip ? b(Be, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: G.title
                }
              }
            }, {
              default: () => [C]
            }) : b(bi, Q({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: G.title,
              disabled: G.props.disabled
            }, Se), null) : C ?? S("span", {
              class: "v-select__selection-text"
            }, [G.title, e.multiple && ie < u.value.length - 1 && S("span", {
              class: "v-select__selection-comma"
            }, [ze(",")])])]);
        })]),
        "append-inner": function() {
          var Se, Ce;
          for (var G = arguments.length, ie = new Array(G), de = 0; de < G; de++)
            ie[de] = arguments[de];
          return S(ye, null, [(Se = n["append-inner"]) == null ? void 0 : Se.call(n, ...ie), e.menuIcon ? b(Ue, {
            class: "v-select__menu-icon",
            color: (Ce = l.value) == null ? void 0 : Ce.fieldIconColor,
            icon: e.menuIcon
          }, null) : void 0]);
        }
      });
    }), Lt({
      isFocused: m,
      menu: k,
      select: ee
    }, l);
  }
}), H1 = (e, t, n) => {
  if (e == null || t == null) return -1;
  if (!t.length) return 0;
  e = e.toString().toLocaleLowerCase(), t = t.toString().toLocaleLowerCase();
  const a = [];
  let l = e.indexOf(t);
  for (; ~l; )
    a.push([l, l + t.length]), l = e.indexOf(t, l + t.length);
  return a.length ? a : -1;
};
function Ls(e, t) {
  if (!(e == null || typeof e == "boolean" || e === -1))
    return typeof e == "number" ? [[e, e + t.length]] : Array.isArray(e[0]) ? e : [e];
}
const Si = z({
  customFilter: Function,
  customKeyFilter: Object,
  filterKeys: [Array, String],
  filterMode: {
    type: String,
    default: "intersection"
  },
  noFilter: Boolean
}, "filter");
function z1(e, t, n) {
  var s;
  const a = [], l = (n == null ? void 0 : n.default) ?? H1, i = n != null && n.filterKeys ? ht(n.filterKeys) : !1, o = Object.keys((n == null ? void 0 : n.customKeyFilter) ?? {}).length;
  if (!(e != null && e.length)) return a;
  let r = null;
  e: for (let d = 0; d < e.length; d++) {
    const [u, c = u] = ht(e[d]), f = {}, v = {};
    let m = -1;
    if ((t || o > 0) && !(n != null && n.noFilter)) {
      let h = !1;
      if (typeof u == "object") {
        if (u.type === "divider" || u.type === "subheader") {
          (r == null ? void 0 : r.type) === "divider" && u.type === "subheader" && a.push(r), r = {
            index: d,
            matches: {},
            type: u.type
          };
          continue;
        }
        const y = i || Object.keys(c);
        h = y.length === o;
        for (const _ of y) {
          const E = xt(c, _), k = (s = n == null ? void 0 : n.customKeyFilter) == null ? void 0 : s[_];
          if (m = k ? k(E, t, u) : l(E, t, u), m !== -1 && m !== !1)
            k ? f[_] = Ls(m, t) : v[_] = Ls(m, t);
          else if ((n == null ? void 0 : n.filterMode) === "every")
            continue e;
        }
      } else
        m = l(u, t, u), m !== -1 && m !== !1 && (v.title = Ls(m, t));
      const g = Object.keys(v).length, p = Object.keys(f).length;
      if (!g && !p || (n == null ? void 0 : n.filterMode) === "union" && p !== o && !g || (n == null ? void 0 : n.filterMode) === "intersection" && (p !== o || !g && o > 0 && !h)) continue;
    }
    r && (a.push(r), r = null), a.push({
      index: d,
      matches: {
        ...v,
        ...f
      }
    });
  }
  return a;
}
function wi(e, t, n, a) {
  const l = fe([]), i = fe(/* @__PURE__ */ new Map()), o = x(() => a != null && a.transform ? bt(t).map((s) => [s, a.transform(s)]) : bt(t));
  ut(() => {
    const s = typeof n == "function" ? n() : bt(n), d = typeof s != "string" && typeof s != "number" ? "" : String(s), u = z1(o.value, d, {
      customKeyFilter: {
        ...e.customKeyFilter,
        ...bt(a == null ? void 0 : a.customKeyFilter)
      },
      default: e.customFilter,
      filterKeys: e.filterKeys,
      filterMode: e.filterMode,
      noFilter: e.noFilter
    }), c = bt(t), f = [], v = /* @__PURE__ */ new Map();
    u.forEach((m) => {
      let {
        index: h,
        matches: g
      } = m;
      const p = c[h];
      f.push(p), v.set(p.value, g);
    }), l.value = f, i.value = v;
  });
  function r(s) {
    return i.value.get(s.value);
  }
  return {
    filteredItems: l,
    filteredMatches: i,
    getMatches: r
  };
}
function Zy(e, t, n) {
  return n == null || !n.length ? t : n.map((a, l) => {
    const i = l === 0 ? 0 : n[l - 1][1], o = [S("span", {
      class: le(`${e}__unmask`)
    }, [t.slice(i, a[0])]), S("span", {
      class: le(`${e}__mask`)
    }, [t.slice(a[0], a[1])])];
    return l === n.length - 1 && o.push(S("span", {
      class: le(`${e}__unmask`)
    }, [t.slice(a[1])])), S(ye, null, [o]);
  });
}
const j1 = z({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: Boolean,
  search: String,
  ...Si({
    filterKeys: ["title"]
  }),
  ...rd(),
  ...tt(No({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Wn({
    transition: !1
  })
}, "VAutocomplete"), W1 = ne()({
  name: "VAutocomplete",
  props: j1(),
  emits: {
    "update:focused": (e) => !0,
    "update:search": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = nt(), l = Z(), i = fe(!1), o = fe(!0), r = fe(!1), s = Z(), d = Z(), u = fe(-1), {
      items: c,
      transformIn: f,
      transformOut: v
    } = Zc(e), {
      textColorClasses: m,
      textColorStyles: h
    } = jt(() => {
      var C;
      return (C = l.value) == null ? void 0 : C.color;
    }), g = Ee(e, "search", ""), p = Ee(e, "modelValue", [], (C) => f(C === null ? [null] : ht(C)), (C) => {
      const O = v(C);
      return e.multiple ? O : O[0] ?? null;
    }), y = x(() => typeof e.counterValue == "function" ? e.counterValue(p.value) : typeof e.counterValue == "number" ? e.counterValue : p.value.length), _ = yi(e), {
      filteredItems: E,
      getMatches: k
    } = wi(e, c, () => o.value ? "" : g.value), P = x(() => e.hideSelected ? E.value.filter((C) => !p.value.some((O) => O.value === C.value)) : E.value), A = x(() => !!(e.chips || n.chip)), D = x(() => A.value || !!n.selection), N = x(() => p.value.map((C) => C.props.value)), V = x(() => {
      var O;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && g.value === ((O = P.value[0]) == null ? void 0 : O.title)) && P.value.length > 0 && !o.value && !r.value;
    }), I = x(() => e.hideNoData && !P.value.length || _.isReadonly.value || _.isDisabled.value), w = Ee(e, "menu"), T = x({
      get: () => w.value,
      set: (C) => {
        var O;
        w.value && !C && ((O = s.value) != null && O.openChildren.size) || C && I.value || (w.value = C);
      }
    }), {
      menuId: M,
      ariaExpanded: W,
      ariaControls: J,
      ariaLabel: ee
    } = od(e, T), Y = Z(), L = id(Y, l);
    function H(C) {
      e.openOnClear && (T.value = !0), g.value = "";
    }
    function j() {
      I.value || (T.value = !0);
    }
    function U(C) {
      I.value || (i.value && (C.preventDefault(), C.stopPropagation()), T.value = !T.value);
    }
    function F(C) {
      var O;
      (ai(C) || C.key === "Backspace") && ((O = l.value) == null || O.focus());
    }
    function oe(C) {
      var K, X, te, ue, se;
      if (_.isReadonly.value) return;
      const O = (K = l.value) == null ? void 0 : K.selectionStart, $ = p.value.length;
      if (["Enter", "ArrowDown", "ArrowUp"].includes(C.key) && C.preventDefault(), ["Enter", "ArrowDown"].includes(C.key) && (T.value = !0), ["Escape"].includes(C.key) && (T.value = !1), V.value && ["Enter", "Tab"].includes(C.key) && !p.value.some((ce) => {
        let {
          value: ae
        } = ce;
        return ae === P.value[0].value;
      }) && Ce(P.value[0]), C.key === "ArrowDown" && V.value && ((X = Y.value) == null || X.focus("next")), ["Backspace", "Delete"].includes(C.key)) {
        if (!e.multiple && D.value && p.value.length > 0 && !g.value) return Ce(p.value[0], !1);
        if (~u.value) {
          C.preventDefault();
          const ce = u.value;
          Ce(p.value[u.value], !1), u.value = ce >= $ - 1 ? $ - 2 : ce;
        } else C.key === "Backspace" && !g.value && (u.value = $ - 1);
        return;
      }
      if (e.multiple)
        if (C.key === "ArrowLeft") {
          if (u.value < 0 && O && O > 0) return;
          const ce = u.value > -1 ? u.value - 1 : $ - 1;
          if (p.value[ce])
            u.value = ce;
          else {
            const ae = ((te = g.value) == null ? void 0 : te.length) ?? null;
            u.value = -1, (ue = l.value) == null || ue.setSelectionRange(ae, ae);
          }
        } else if (C.key === "ArrowRight") {
          if (u.value < 0) return;
          const ce = u.value + 1;
          p.value[ce] ? u.value = ce : (u.value = -1, (se = l.value) == null || se.setSelectionRange(0, 0));
        } else ~u.value && ai(C) && (u.value = -1);
    }
    function ve(C) {
      if (ni(l.value, ":autofill") || ni(l.value, ":-webkit-autofill")) {
        const O = c.value.find(($) => $.title === C.target.value);
        O && Ce(O);
      }
    }
    function _e() {
      var C;
      e.eager && ((C = d.value) == null || C.calculateVisibleItems());
    }
    function B() {
      var C;
      i.value && (o.value = !0, (C = l.value) == null || C.focus());
    }
    function G(C) {
      i.value = !0, setTimeout(() => {
        r.value = !0;
      });
    }
    function ie(C) {
      r.value = !1;
    }
    function de(C) {
      (C == null || C === "" && !e.multiple && !D.value) && (p.value = []);
    }
    const Se = fe(!1);
    function Ce(C) {
      let O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!C || C.props.disabled))
        if (e.multiple) {
          const $ = p.value.findIndex((X) => (e.valueComparator || Mt)(X.value, C.value)), K = O ?? !~$;
          if (~$) {
            const X = K ? [...p.value, C] : [...p.value];
            X.splice($, 1), p.value = X;
          } else K && (p.value = [...p.value, C]);
          e.clearOnSelect && (g.value = "");
        } else {
          const $ = O !== !1;
          p.value = $ ? [C] : [], g.value = $ && !D.value ? C.title : "", He(() => {
            T.value = !1, o.value = !0;
          });
        }
    }
    return me(i, (C, O) => {
      var $;
      C !== O && (C ? (Se.value = !0, g.value = e.multiple || D.value ? "" : String((($ = p.value.at(-1)) == null ? void 0 : $.props.title) ?? ""), o.value = !0, He(() => Se.value = !1)) : (!e.multiple && g.value == null && (p.value = []), T.value = !1, g.value = "", u.value = -1));
    }), me(g, (C) => {
      !i.value || Se.value || (C && (T.value = !0), o.value = !C);
    }), me(T, () => {
      if (!e.hideSelected && T.value && p.value.length) {
        const C = P.value.findIndex((O) => p.value.some(($) => O.value === $.value));
        qe && window.requestAnimationFrame(() => {
          var O;
          C >= 0 && ((O = d.value) == null || O.scrollToIndex(C));
        });
      }
    }), me(c, (C, O) => {
      T.value || i.value && !O.length && C.length && (T.value = !0);
    }), re(() => {
      const C = !!(!e.hideNoData || P.value.length || n["prepend-item"] || n["append-item"] || n["no-data"]), O = p.value.length > 0, $ = wa.filterProps(e);
      return b(wa, Q({
        ref: l
      }, $, {
        modelValue: g.value,
        "onUpdate:modelValue": [(K) => g.value = K, de],
        focused: i.value,
        "onUpdate:focused": (K) => i.value = K,
        validationValue: p.externalValue,
        counterValue: y.value,
        dirty: O,
        onChange: ve,
        class: ["v-autocomplete", `v-autocomplete--${e.multiple ? "multiple" : "single"}`, {
          "v-autocomplete--active-menu": T.value,
          "v-autocomplete--chips": !!e.chips,
          "v-autocomplete--selection-slot": !!D.value,
          "v-autocomplete--selecting-index": u.value > -1
        }, e.class],
        style: e.style,
        readonly: _.isReadonly.value,
        placeholder: O ? void 0 : e.placeholder,
        "onClick:clear": H,
        "onMousedown:control": j,
        onKeydown: oe,
        "aria-expanded": W.value,
        "aria-controls": J.value
      }), {
        ...n,
        default: () => S(ye, null, [b(si, Q({
          id: M.value,
          ref: s,
          modelValue: T.value,
          "onUpdate:modelValue": (K) => T.value = K,
          activator: "parent",
          contentClass: "v-autocomplete__content",
          disabled: I.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: _e,
          onAfterLeave: B
        }, e.menuProps), {
          default: () => [C && b(ri, Q({
            ref: Y,
            filterable: !0,
            selected: N.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (K) => K.preventDefault(),
            onKeydown: F,
            onFocusin: G,
            onFocusout: ie,
            tabindex: "-1",
            selectable: !0,
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, L, e.listProps), {
            default: () => {
              var K, X, te;
              return [(K = n["prepend-item"]) == null ? void 0 : K.call(n), !P.value.length && !e.hideNoData && (((X = n["no-data"]) == null ? void 0 : X.call(n)) ?? b(zn, {
                key: "no-data",
                title: a(e.noDataText)
              }, null)), b(Xr, {
                ref: d,
                renderless: !0,
                items: P.value,
                itemKey: "value"
              }, {
                default: (ue) => {
                  var we, Ne, $e;
                  let {
                    item: se,
                    index: ce,
                    itemRef: ae
                  } = ue;
                  const Ie = Q(se.props, {
                    ref: ae,
                    key: se.value,
                    active: V.value && ce === 0 ? !0 : void 0,
                    onClick: () => Ce(se, null)
                  });
                  return se.type === "divider" ? ((we = n.divider) == null ? void 0 : we.call(n, {
                    props: se.raw,
                    index: ce
                  })) ?? b(Sn, Q(se.props, {
                    key: `divider-${ce}`
                  }), null) : se.type === "subheader" ? ((Ne = n.subheader) == null ? void 0 : Ne.call(n, {
                    props: se.raw,
                    index: ce
                  })) ?? b(pi, Q(se.props, {
                    key: `subheader-${ce}`
                  }), null) : (($e = n.item) == null ? void 0 : $e.call(n, {
                    item: se,
                    index: ce,
                    props: Ie
                  })) ?? b(zn, Q(Ie, {
                    role: "option"
                  }), {
                    prepend: (Fe) => {
                      let {
                        isSelected: Je
                      } = Fe;
                      return S(ye, null, [e.multiple && !e.hideSelected ? b(ia, {
                        key: se.value,
                        modelValue: Je,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, se.props.prependAvatar && b(kn, {
                        image: se.props.prependAvatar
                      }, null), se.props.prependIcon && b(Ue, {
                        icon: se.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var Fe;
                      return o.value ? se.title : Zy("v-autocomplete", se.title, (Fe = k(se)) == null ? void 0 : Fe.title);
                    }
                  });
                }
              }), (te = n["append-item"]) == null ? void 0 : te.call(n)];
            }
          })]
        }), p.value.map((K, X) => {
          function te(ae) {
            ae.stopPropagation(), ae.preventDefault(), Ce(K, !1);
          }
          const ue = {
            "onClick:close": te,
            onKeydown(ae) {
              ae.key !== "Enter" && ae.key !== " " || (ae.preventDefault(), ae.stopPropagation(), te(ae));
            },
            onMousedown(ae) {
              ae.preventDefault(), ae.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, se = A.value ? !!n.chip : !!n.selection, ce = se ? Fr(A.value ? n.chip({
            item: K,
            index: X,
            props: ue
          }) : n.selection({
            item: K,
            index: X
          })) : void 0;
          if (!(se && !ce))
            return S("div", {
              key: K.value,
              class: le(["v-autocomplete__selection", X === u.value && ["v-autocomplete__selection--selected", m.value]]),
              style: he(X === u.value ? h.value : {})
            }, [A.value ? n.chip ? b(Be, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: K.title
                }
              }
            }, {
              default: () => [ce]
            }) : b(bi, Q({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: K.title,
              disabled: K.props.disabled
            }, ue), null) : ce ?? S("span", {
              class: "v-autocomplete__selection-text"
            }, [K.title, e.multiple && X < p.value.length - 1 && S("span", {
              class: "v-autocomplete__selection-comma"
            }, [ze(",")])])]);
        })]),
        "append-inner": function() {
          var ue, se;
          for (var K = arguments.length, X = new Array(K), te = 0; te < K; te++)
            X[te] = arguments[te];
          return S(ye, null, [(ue = n["append-inner"]) == null ? void 0 : ue.call(n, ...X), e.menuIcon ? b(Ue, {
            class: "v-autocomplete__menu-icon",
            color: (se = l.value) == null ? void 0 : se.fieldIconColor,
            icon: e.menuIcon,
            onMousedown: U,
            onClick: gg,
            "aria-label": ee.value,
            title: ee.value,
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Lt({
      isFocused: i,
      isPristine: o,
      menu: T,
      search: g,
      filteredItems: E,
      select: Ce
    }, l);
  }
}), U1 = z({
  bordered: Boolean,
  color: String,
  content: [Number, String],
  dot: Boolean,
  floating: Boolean,
  icon: Ve,
  inline: Boolean,
  label: {
    type: String,
    default: "$vuetify.badge"
  },
  max: [Number, String],
  modelValue: {
    type: Boolean,
    default: !0
  },
  offsetX: [Number, String],
  offsetY: [Number, String],
  textColor: String,
  ...ke(),
  ...Va({
    location: "top end"
  }),
  ...ft(),
  ...Oe(),
  ...We(),
  ...Wn({
    transition: "scale-rotate-transition"
  }),
  ...kt()
}, "VBadge"), G1 = ne()({
  name: "VBadge",
  inheritAttrs: !1,
  props: U1(),
  setup(e, t) {
    const {
      backgroundColorClasses: n,
      backgroundColorStyles: a
    } = Xe(() => e.color), {
      roundedClasses: l
    } = yt(e), {
      t: i
    } = nt(), {
      textColorClasses: o,
      textColorStyles: r
    } = jt(() => e.textColor), {
      themeClasses: s
    } = Hc(), {
      locationStyles: d
    } = Al(e, !0, (c) => (e.floating ? e.dot ? 2 : 4 : e.dot ? 8 : 12) + (["top", "bottom"].includes(c) ? Number(e.offsetY ?? 0) : ["left", "right"].includes(c) ? Number(e.offsetX ?? 0) : 0)), {
      dimensionStyles: u
    } = Ct(e);
    return re(() => {
      const c = Number(e.content), f = !e.max || isNaN(c) ? e.content : c <= Number(e.max) ? c : `${e.max}+`, [v, m] = mu(t.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
      return b(e.tag, Q({
        class: ["v-badge", {
          "v-badge--bordered": e.bordered,
          "v-badge--dot": e.dot,
          "v-badge--floating": e.floating,
          "v-badge--inline": e.inline
        }, e.class]
      }, m, {
        style: e.style
      }), {
        default: () => {
          var h, g;
          return [S("div", {
            class: "v-badge__wrapper"
          }, [(g = (h = t.slots).default) == null ? void 0 : g.call(h), b(Zt, {
            transition: e.transition
          }, {
            default: () => {
              var p, y;
              return [dt(S("span", Q({
                class: ["v-badge__badge", s.value, n.value, l.value, o.value],
                style: [a.value, r.value, u.value, e.inline ? {} : d.value],
                "aria-atomic": "true",
                "aria-label": i(e.label, c),
                "aria-live": "polite",
                role: "status"
              }, v), [e.dot ? void 0 : t.slots.badge ? (y = (p = t.slots).badge) == null ? void 0 : y.call(p) : e.icon ? b(Ue, {
                icon: e.icon
              }, null) : f]), [[Nn, e.modelValue]])];
            }
          })])];
        }
      });
    }), {};
  }
}), K1 = z({
  color: String,
  density: String,
  ...ke()
}, "VBannerActions"), Qy = ne()({
  name: "VBannerActions",
  props: K1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return gt({
      VBtn: {
        color: e.color,
        density: e.density,
        slim: !0,
        variant: "text"
      }
    }), re(() => {
      var a;
      return S("div", {
        class: le(["v-banner-actions", e.class]),
        style: he(e.style)
      }, [(a = n.default) == null ? void 0 : a.call(n)]);
    }), {};
  }
}), eb = Ca("v-banner-text"), Y1 = z({
  avatar: String,
  bgColor: String,
  color: String,
  icon: Ve,
  lines: String,
  stacked: Boolean,
  sticky: Boolean,
  text: String,
  ...cn(),
  ...ke(),
  ...Tt(),
  ...kt(),
  ...kl({
    mobile: null
  }),
  ...Pt(),
  ...Va(),
  ...mi(),
  ...ft(),
  ...Oe(),
  ...We()
}, "VBanner"), q1 = ne()({
  name: "VBanner",
  props: Y1(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: l
    } = Xe(() => e.bgColor), {
      borderClasses: i
    } = hn(e), {
      densityClasses: o
    } = tn(e), {
      displayClasses: r,
      mobile: s
    } = Vn(e), {
      dimensionStyles: d
    } = Ct(e), {
      elevationClasses: u
    } = Rt(e), {
      locationStyles: c
    } = Al(e), {
      positionClasses: f
    } = hi(e), {
      roundedClasses: v
    } = yt(e), {
      themeClasses: m
    } = Ye(e), h = R(() => e.color), g = R(() => e.density);
    gt({
      VBannerActions: {
        color: h,
        density: g
      }
    }), re(() => {
      const p = !!(e.text || n.text), y = !!(e.avatar || e.icon), _ = !!(y || n.prepend);
      return b(e.tag, {
        class: le(["v-banner", {
          "v-banner--stacked": e.stacked || s.value,
          "v-banner--sticky": e.sticky,
          [`v-banner--${e.lines}-line`]: !!e.lines
        }, m.value, a.value, i.value, o.value, r.value, u.value, f.value, v.value, e.class]),
        style: he([l.value, d.value, c.value, e.style]),
        role: "banner"
      }, {
        default: () => {
          var E;
          return [_ && S("div", {
            key: "prepend",
            class: "v-banner__prepend"
          }, [n.prepend ? b(Be, {
            key: "prepend-defaults",
            disabled: !y,
            defaults: {
              VAvatar: {
                color: h.value,
                density: g.value,
                icon: e.icon,
                image: e.avatar
              }
            }
          }, n.prepend) : b(kn, {
            key: "prepend-avatar",
            color: h.value,
            density: g.value,
            icon: e.icon,
            image: e.avatar
          }, null)]), S("div", {
            class: "v-banner__content"
          }, [p && b(eb, {
            key: "text"
          }, {
            default: () => {
              var k;
              return [((k = n.text) == null ? void 0 : k.call(n)) ?? e.text];
            }
          }), (E = n.default) == null ? void 0 : E.call(n)]), n.actions && b(Qy, {
            key: "actions"
          }, n.actions)];
        }
      });
    });
  }
}), X1 = z({
  baseColor: String,
  bgColor: String,
  color: String,
  grow: Boolean,
  mode: {
    type: String,
    validator: (e) => !e || ["horizontal", "shift"].includes(e)
  },
  height: {
    type: [Number, String],
    default: 56
  },
  active: {
    type: Boolean,
    default: !0
  },
  ...cn(),
  ...ke(),
  ...Tt(),
  ...Pt(),
  ...ft(),
  ...Cl({
    name: "bottom-navigation"
  }),
  ...Oe({
    tag: "header"
  }),
  ...Il({
    selectedClass: "v-btn--selected"
  }),
  ...We()
}, "VBottomNavigation"), J1 = ne()({
  name: "VBottomNavigation",
  props: X1(),
  emits: {
    "update:active": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Hc(), {
      borderClasses: l
    } = hn(e), {
      backgroundColorClasses: i,
      backgroundColorStyles: o
    } = Xe(() => e.bgColor), {
      densityClasses: r
    } = tn(e), {
      elevationClasses: s
    } = Rt(e), {
      roundedClasses: d
    } = yt(e), {
      ssrBootStyles: u
    } = El(), c = x(() => Number(e.height) - (e.density === "comfortable" ? 8 : 0) - (e.density === "compact" ? 16 : 0)), f = Ee(e, "active", e.active), {
      layoutItemStyles: v
    } = Vl({
      id: e.name,
      order: x(() => parseInt(e.order, 10)),
      position: R(() => "bottom"),
      layoutSize: R(() => f.value ? c.value : 0),
      elementSize: c,
      active: f,
      absolute: R(() => e.absolute)
    });
    return Wa(e, Kc), gt({
      VBtn: {
        baseColor: R(() => e.baseColor),
        color: R(() => e.color),
        density: R(() => e.density),
        stacked: R(() => e.mode !== "horizontal"),
        variant: "text"
      }
    }, {
      scoped: !0
    }), re(() => b(e.tag, {
      class: le(["v-bottom-navigation", {
        "v-bottom-navigation--active": f.value,
        "v-bottom-navigation--grow": e.grow,
        "v-bottom-navigation--shift": e.mode === "shift"
      }, a.value, i.value, l.value, r.value, s.value, d.value, e.class]),
      style: he([o.value, v.value, {
        height: pe(c.value)
      }, u.value, e.style])
    }, {
      default: () => [n.default && S("div", {
        class: "v-bottom-navigation__content"
      }, [n.default()])]
    })), {};
  }
}), tb = z({
  fullscreen: Boolean,
  retainFocus: {
    type: Boolean,
    default: !0
  },
  scrollable: Boolean,
  ...Po({
    origin: "center center",
    scrollStrategy: "block",
    transition: {
      component: jr
    },
    zIndex: 2400
  })
}, "VDialog"), Ou = ne()({
  name: "VDialog",
  props: tb(),
  emits: {
    "update:modelValue": (e) => !0,
    afterEnter: () => !0,
    afterLeave: () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const l = Ee(e, "modelValue"), {
      scopeId: i
    } = Tl(), o = Z();
    function r(u) {
      var v, m;
      const c = u.relatedTarget, f = u.target;
      if (c !== f && ((v = o.value) != null && v.contentEl) && // We're the topmost dialog
      ((m = o.value) != null && m.globalTop) && // It isn't the document or the dialog body
      ![document, o.value.contentEl].includes(f) && // It isn't inside the dialog body
      !o.value.contentEl.contains(f)) {
        const h = Yi(o.value.contentEl);
        if (!h.length) return;
        const g = h[0], p = h[h.length - 1];
        c === g ? p.focus() : g.focus();
      }
    }
    Wt(() => {
      document.removeEventListener("focusin", r);
    }), qe && me(() => l.value && e.retainFocus, (u) => {
      u ? document.addEventListener("focusin", r) : document.removeEventListener("focusin", r);
    }, {
      immediate: !0
    });
    function s() {
      var u;
      n("afterEnter"), (e.scrim || e.retainFocus) && ((u = o.value) != null && u.contentEl) && !o.value.contentEl.contains(document.activeElement) && o.value.contentEl.focus({
        preventScroll: !0
      });
    }
    function d() {
      n("afterLeave");
    }
    return me(l, async (u) => {
      var c;
      u || (await He(), (c = o.value.activatorEl) == null || c.focus({
        preventScroll: !0
      }));
    }), re(() => {
      const u = oa.filterProps(e), c = Q({
        "aria-haspopup": "dialog"
      }, e.activatorProps), f = Q({
        tabindex: -1
      }, e.contentProps);
      return b(oa, Q({
        ref: o,
        class: ["v-dialog", {
          "v-dialog--fullscreen": e.fullscreen,
          "v-dialog--scrollable": e.scrollable
        }, e.class],
        style: e.style
      }, u, {
        modelValue: l.value,
        "onUpdate:modelValue": (v) => l.value = v,
        "aria-modal": "true",
        activatorProps: c,
        contentProps: f,
        height: e.fullscreen ? void 0 : e.height,
        width: e.fullscreen ? void 0 : e.width,
        maxHeight: e.fullscreen ? void 0 : e.maxHeight,
        maxWidth: e.fullscreen ? void 0 : e.maxWidth,
        role: "dialog",
        onAfterEnter: s,
        onAfterLeave: d
      }, i), {
        activator: a.activator,
        default: function() {
          for (var v = arguments.length, m = new Array(v), h = 0; h < v; h++)
            m[h] = arguments[h];
          return b(Be, {
            root: "VDialog"
          }, {
            default: () => {
              var g;
              return [(g = a.default) == null ? void 0 : g.call(a, ...m)];
            }
          });
        }
      });
    }), Lt({}, o);
  }
}), Z1 = z({
  inset: Boolean,
  ...tb({
    transition: "bottom-sheet-transition"
  })
}, "VBottomSheet"), Q1 = ne()({
  name: "VBottomSheet",
  props: Z1(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue");
    return re(() => {
      const l = Ou.filterProps(e);
      return b(Ou, Q(l, {
        contentClass: ["v-bottom-sheet__content", e.contentClass],
        modelValue: a.value,
        "onUpdate:modelValue": (i) => a.value = i,
        class: ["v-bottom-sheet", {
          "v-bottom-sheet--inset": e.inset
        }, e.class],
        style: e.style
      }), n);
    }), {};
  }
}), eE = z({
  divider: [Number, String],
  ...ke()
}, "VBreadcrumbsDivider"), nb = ne()({
  name: "VBreadcrumbsDivider",
  props: eE(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      var a;
      return S("li", {
        "aria-hidden": "true",
        class: le(["v-breadcrumbs-divider", e.class]),
        style: he(e.style)
      }, [((a = n == null ? void 0 : n.default) == null ? void 0 : a.call(n)) ?? e.divider]);
    }), {};
  }
}), tE = z({
  active: Boolean,
  activeClass: String,
  activeColor: String,
  color: String,
  disabled: Boolean,
  title: String,
  ...ke(),
  ...Vo(),
  ...Oe({
    tag: "li"
  })
}, "VBreadcrumbsItem"), ab = ne()({
  name: "VBreadcrumbsItem",
  props: tE(),
  setup(e, t) {
    let {
      slots: n,
      attrs: a
    } = t;
    const l = Co(e, a), i = x(() => {
      var s;
      return e.active || ((s = l.isActive) == null ? void 0 : s.value);
    }), {
      textColorClasses: o,
      textColorStyles: r
    } = jt(() => i.value ? e.activeColor : e.color);
    return re(() => b(e.tag, {
      class: le(["v-breadcrumbs-item", {
        "v-breadcrumbs-item--active": i.value,
        "v-breadcrumbs-item--disabled": e.disabled,
        [`${e.activeClass}`]: i.value && e.activeClass
      }, o.value, e.class]),
      style: he([r.value, e.style]),
      "aria-current": i.value ? "page" : void 0
    }, {
      default: () => {
        var s, d;
        return [l.isLink.value ? S("a", Q({
          class: "v-breadcrumbs-item--link",
          onClick: l.navigate
        }, l.linkProps), [((d = n.default) == null ? void 0 : d.call(n)) ?? e.title]) : ((s = n.default) == null ? void 0 : s.call(n)) ?? e.title];
      }
    })), {};
  }
}), nE = z({
  activeClass: String,
  activeColor: String,
  bgColor: String,
  color: String,
  disabled: Boolean,
  divider: {
    type: String,
    default: "/"
  },
  icon: Ve,
  items: {
    type: Array,
    default: () => []
  },
  ...ke(),
  ...Tt(),
  ...ft(),
  ...Oe({
    tag: "ul"
  })
}, "VBreadcrumbs"), aE = ne()({
  name: "VBreadcrumbs",
  props: nE(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: l
    } = Xe(() => e.bgColor), {
      densityClasses: i
    } = tn(e), {
      roundedClasses: o
    } = yt(e);
    gt({
      VBreadcrumbsDivider: {
        divider: R(() => e.divider)
      },
      VBreadcrumbsItem: {
        activeClass: R(() => e.activeClass),
        activeColor: R(() => e.activeColor),
        color: R(() => e.color),
        disabled: R(() => e.disabled)
      }
    });
    const r = x(() => e.items.map((s) => typeof s == "string" ? {
      item: {
        title: s
      },
      raw: s
    } : {
      item: s,
      raw: s
    }));
    return re(() => {
      const s = !!(n.prepend || e.icon);
      return b(e.tag, {
        class: le(["v-breadcrumbs", a.value, i.value, o.value, e.class]),
        style: he([l.value, e.style])
      }, {
        default: () => {
          var d;
          return [s && S("li", {
            key: "prepend",
            class: "v-breadcrumbs__prepend"
          }, [n.prepend ? b(Be, {
            key: "prepend-defaults",
            disabled: !e.icon,
            defaults: {
              VIcon: {
                icon: e.icon,
                start: !0
              }
            }
          }, n.prepend) : b(Ue, {
            key: "prepend-icon",
            start: !0,
            icon: e.icon
          }, null)]), r.value.map((u, c, f) => {
            var h;
            let {
              item: v,
              raw: m
            } = u;
            return S(ye, null, [((h = n.item) == null ? void 0 : h.call(n, {
              item: v,
              index: c
            })) ?? b(ab, Q({
              key: c,
              disabled: c >= f.length - 1
            }, typeof v == "string" ? {
              title: v
            } : v), {
              default: n.title ? () => {
                var g;
                return (g = n.title) == null ? void 0 : g.call(n, {
                  item: v,
                  index: c
                });
              } : void 0
            }), c < f.length - 1 && b(nb, null, {
              default: n.divider ? () => {
                var g;
                return (g = n.divider) == null ? void 0 : g.call(n, {
                  item: m,
                  index: c
                });
              } : void 0
            })]);
          }), (d = n.default) == null ? void 0 : d.call(n)];
        }
      });
    }), {};
  }
}), lE = z({
  ...ke(),
  ...Oe()
}, "VCardActions"), lb = ne()({
  name: "VCardActions",
  props: lE(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return gt({
      VBtn: {
        slim: !0,
        variant: "text"
      }
    }), re(() => b(e.tag, {
      class: le(["v-card-actions", e.class]),
      style: he(e.style)
    }, n)), {};
  }
}), iE = z({
  opacity: [Number, String],
  ...ke(),
  ...Oe()
}, "VCardSubtitle"), ib = ne()({
  name: "VCardSubtitle",
  props: iE(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => b(e.tag, {
      class: le(["v-card-subtitle", e.class]),
      style: he([{
        "--v-card-subtitle-opacity": e.opacity
      }, e.style])
    }, n)), {};
  }
}), ob = Ca("v-card-title"), oE = z({
  appendAvatar: String,
  appendIcon: Ve,
  prependAvatar: String,
  prependIcon: Ve,
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...ke(),
  ...Tt(),
  ...Oe()
}, "VCardItem"), rb = ne()({
  name: "VCardItem",
  props: oE(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      const a = !!(e.prependAvatar || e.prependIcon), l = !!(a || n.prepend), i = !!(e.appendAvatar || e.appendIcon), o = !!(i || n.append), r = !!(e.title != null || n.title), s = !!(e.subtitle != null || n.subtitle);
      return b(e.tag, {
        class: le(["v-card-item", e.class]),
        style: he(e.style)
      }, {
        default: () => {
          var d;
          return [l && S("div", {
            key: "prepend",
            class: "v-card-item__prepend"
          }, [n.prepend ? b(Be, {
            key: "prepend-defaults",
            disabled: !a,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.prependAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.prependIcon
              }
            }
          }, n.prepend) : S(ye, null, [e.prependAvatar && b(kn, {
            key: "prepend-avatar",
            density: e.density,
            image: e.prependAvatar
          }, null), e.prependIcon && b(Ue, {
            key: "prepend-icon",
            density: e.density,
            icon: e.prependIcon
          }, null)])]), S("div", {
            class: "v-card-item__content"
          }, [r && b(ob, {
            key: "title"
          }, {
            default: () => {
              var u;
              return [((u = n.title) == null ? void 0 : u.call(n)) ?? Re(e.title)];
            }
          }), s && b(ib, {
            key: "subtitle"
          }, {
            default: () => {
              var u;
              return [((u = n.subtitle) == null ? void 0 : u.call(n)) ?? Re(e.subtitle)];
            }
          }), (d = n.default) == null ? void 0 : d.call(n)]), o && S("div", {
            key: "append",
            class: "v-card-item__append"
          }, [n.append ? b(Be, {
            key: "append-defaults",
            disabled: !i,
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.appendAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.appendIcon
              }
            }
          }, n.append) : S(ye, null, [e.appendIcon && b(Ue, {
            key: "append-icon",
            density: e.density,
            icon: e.appendIcon
          }, null), e.appendAvatar && b(kn, {
            key: "append-avatar",
            density: e.density,
            image: e.appendAvatar
          }, null)])])];
        }
      });
    }), {};
  }
}), rE = z({
  opacity: [Number, String],
  ...ke(),
  ...Oe()
}, "VCardText"), sb = ne()({
  name: "VCardText",
  props: rE(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => b(e.tag, {
      class: le(["v-card-text", e.class]),
      style: he([{
        "--v-card-text-opacity": e.opacity
      }, e.style])
    }, n)), {};
  }
}), sE = z({
  appendAvatar: String,
  appendIcon: Ve,
  disabled: Boolean,
  flat: Boolean,
  hover: Boolean,
  image: String,
  link: {
    type: Boolean,
    default: void 0
  },
  prependAvatar: String,
  prependIcon: Ve,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  subtitle: {
    type: [String, Number, Boolean],
    default: void 0
  },
  text: {
    type: [String, Number, Boolean],
    default: void 0
  },
  title: {
    type: [String, Number, Boolean],
    default: void 0
  },
  ...cn(),
  ...ke(),
  ...Tt(),
  ...kt(),
  ...Pt(),
  ...Gr(),
  ...Va(),
  ...mi(),
  ...ft(),
  ...Vo(),
  ...Oe(),
  ...We(),
  ...Dn({
    variant: "elevated"
  })
}, "VCard"), uE = ne()({
  name: "VCard",
  directives: {
    vRipple: en
  },
  props: sE(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      themeClasses: l
    } = Ye(e), {
      borderClasses: i
    } = hn(e), {
      colorClasses: o,
      colorStyles: r,
      variantClasses: s
    } = Pl(e), {
      densityClasses: d
    } = tn(e), {
      dimensionStyles: u
    } = Ct(e), {
      elevationClasses: c
    } = Rt(e), {
      loaderClasses: f
    } = xo(e), {
      locationStyles: v
    } = Al(e), {
      positionClasses: m
    } = hi(e), {
      roundedClasses: h
    } = yt(e), g = Co(e, n);
    return re(() => {
      const p = e.link !== !1 && g.isLink.value, y = !e.disabled && e.link !== !1 && (e.link || g.isClickable.value), _ = p ? "a" : e.tag, E = !!(a.title || e.title != null), k = !!(a.subtitle || e.subtitle != null), P = E || k, A = !!(a.append || e.appendAvatar || e.appendIcon), D = !!(a.prepend || e.prependAvatar || e.prependIcon), N = !!(a.image || e.image), V = P || D || A, I = !!(a.text || e.text != null);
      return dt(b(_, Q(g.linkProps, {
        class: ["v-card", {
          "v-card--disabled": e.disabled,
          "v-card--flat": e.flat,
          "v-card--hover": e.hover && !(e.disabled || e.flat),
          "v-card--link": y
        }, l.value, i.value, o.value, d.value, c.value, f.value, m.value, h.value, s.value, e.class],
        style: [r.value, u.value, v.value, e.style],
        onClick: y && g.navigate,
        tabindex: e.disabled ? -1 : void 0
      }), {
        default: () => {
          var w;
          return [N && S("div", {
            key: "image",
            class: "v-card__image"
          }, [a.image ? b(Be, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                cover: !0,
                src: e.image
              }
            }
          }, a.image) : b(Sa, {
            key: "image-img",
            cover: !0,
            src: e.image
          }, null)]), b(ko, {
            name: "v-card",
            active: !!e.loading,
            color: typeof e.loading == "boolean" ? void 0 : e.loading
          }, {
            default: a.loader
          }), V && b(rb, {
            key: "item",
            prependAvatar: e.prependAvatar,
            prependIcon: e.prependIcon,
            title: e.title,
            subtitle: e.subtitle,
            appendAvatar: e.appendAvatar,
            appendIcon: e.appendIcon
          }, {
            default: a.item,
            prepend: a.prepend,
            title: a.title,
            subtitle: a.subtitle,
            append: a.append
          }), I && b(sb, {
            key: "text"
          }, {
            default: () => {
              var T;
              return [((T = a.text) == null ? void 0 : T.call(a)) ?? e.text];
            }
          }), (w = a.default) == null ? void 0 : w.call(a), a.actions && b(lb, null, {
            default: a.actions
          }), ja(y, "v-card")];
        }
      }), [[en, y && e.ripple]]);
    }), {};
  }
}), cE = (e) => {
  const {
    touchstartX: t,
    touchendX: n,
    touchstartY: a,
    touchendY: l
  } = e, i = 0.5, o = 16;
  e.offsetX = n - t, e.offsetY = l - a, Math.abs(e.offsetY) < i * Math.abs(e.offsetX) && (e.left && n < t - o && e.left(e), e.right && n > t + o && e.right(e)), Math.abs(e.offsetX) < i * Math.abs(e.offsetY) && (e.up && l < a - o && e.up(e), e.down && l > a + o && e.down(e));
};
function dE(e, t) {
  var a;
  const n = e.changedTouches[0];
  t.touchstartX = n.clientX, t.touchstartY = n.clientY, (a = t.start) == null || a.call(t, {
    originalEvent: e,
    ...t
  });
}
function fE(e, t) {
  var a;
  const n = e.changedTouches[0];
  t.touchendX = n.clientX, t.touchendY = n.clientY, (a = t.end) == null || a.call(t, {
    originalEvent: e,
    ...t
  }), cE(t);
}
function vE(e, t) {
  var a;
  const n = e.changedTouches[0];
  t.touchmoveX = n.clientX, t.touchmoveY = n.clientY, (a = t.move) == null || a.call(t, {
    originalEvent: e,
    ...t
  });
}
function mE() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const t = {
    touchstartX: 0,
    touchstartY: 0,
    touchendX: 0,
    touchendY: 0,
    touchmoveX: 0,
    touchmoveY: 0,
    offsetX: 0,
    offsetY: 0,
    left: e.left,
    right: e.right,
    up: e.up,
    down: e.down,
    start: e.start,
    move: e.move,
    end: e.end
  };
  return {
    touchstart: (n) => dE(n, t),
    touchend: (n) => fE(n, t),
    touchmove: (n) => vE(n, t)
  };
}
function hE(e, t) {
  var r;
  const n = t.value, a = n != null && n.parent ? e.parentElement : e, l = (n == null ? void 0 : n.options) ?? {
    passive: !0
  }, i = (r = t.instance) == null ? void 0 : r.$.uid;
  if (!a || i === void 0) return;
  const o = mE(t.value);
  a._touchHandlers = a._touchHandlers ?? /* @__PURE__ */ Object.create(null), a._touchHandlers[i] = o, ug(o).forEach((s) => {
    a.addEventListener(s, o[s], l);
  });
}
function gE(e, t) {
  var i, o;
  const n = (i = t.value) != null && i.parent ? e.parentElement : e, a = (o = t.instance) == null ? void 0 : o.$.uid;
  if (!(n != null && n._touchHandlers) || a === void 0) return;
  const l = n._touchHandlers[a];
  ug(l).forEach((r) => {
    n.removeEventListener(r, l[r]);
  }), delete n._touchHandlers[a];
}
const Cr = {
  mounted: hE,
  unmounted: gE
}, ub = Symbol.for("vuetify:v-window"), cb = Symbol.for("vuetify:v-window-group"), Jr = z({
  continuous: Boolean,
  nextIcon: {
    type: [Boolean, String, Function, Object],
    default: "$next"
  },
  prevIcon: {
    type: [Boolean, String, Function, Object],
    default: "$prev"
  },
  reverse: Boolean,
  showArrows: {
    type: [Boolean, String],
    validator: (e) => typeof e == "boolean" || e === "hover"
  },
  verticalArrows: [Boolean, String],
  touch: {
    type: [Object, Boolean],
    default: void 0
  },
  direction: {
    type: String,
    default: "horizontal"
  },
  modelValue: null,
  disabled: Boolean,
  selectedClass: {
    type: String,
    default: "v-window-item--active"
  },
  // TODO: mandatory should probably not be exposed but do this for now
  mandatory: {
    type: [Boolean, String],
    default: "force"
  },
  crossfade: Boolean,
  transitionDuration: Number,
  ...ke(),
  ...Oe(),
  ...We()
}, "VWindow"), bl = ne()({
  name: "VWindow",
  directives: {
    vTouch: Cr
  },
  props: Jr(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      isRtl: l
    } = Et(), {
      t: i
    } = nt(), o = Wa(e, cb), r = Z(), s = x(() => l.value ? !e.reverse : e.reverse), d = fe(!1), u = x(() => {
      if (e.crossfade)
        return "v-window-crossfade-transition";
      const E = e.direction === "vertical" ? "y" : "x", P = (s.value ? !d.value : d.value) ? "-reverse" : "";
      return `v-window-${E}${P}-transition`;
    }), c = fe(0), f = Z(void 0), v = x(() => o.items.value.findIndex((E) => o.selected.value.includes(E.id)));
    me(v, (E, k) => {
      const P = o.items.value.length, A = P - 1;
      P <= 2 ? d.value = E < k : E === A && k === 0 ? d.value = !0 : E === 0 && k === A ? d.value = !1 : d.value = E < k;
    }), at(ub, {
      transition: u,
      isReversed: d,
      transitionCount: c,
      transitionHeight: f,
      rootRef: r
    });
    const m = R(() => e.continuous || v.value !== 0), h = R(() => e.continuous || v.value !== o.items.value.length - 1);
    function g() {
      m.value && o.prev();
    }
    function p() {
      h.value && o.next();
    }
    const y = x(() => {
      const E = [], k = {
        icon: l.value ? e.nextIcon : e.prevIcon,
        class: `v-window__${s.value ? "right" : "left"}`,
        onClick: o.prev,
        "aria-label": i("$vuetify.carousel.prev")
      };
      E.push(m.value ? n.prev ? n.prev({
        props: k
      }) : b(Le, k, null) : S("div", null, null));
      const P = {
        icon: l.value ? e.prevIcon : e.nextIcon,
        class: `v-window__${s.value ? "left" : "right"}`,
        onClick: o.next,
        "aria-label": i("$vuetify.carousel.next")
      };
      return E.push(h.value ? n.next ? n.next({
        props: P
      }) : b(Le, P, null) : S("div", null, null)), E;
    }), _ = x(() => e.touch === !1 ? e.touch : {
      ...{
        left: () => {
          s.value ? g() : p();
        },
        right: () => {
          s.value ? p() : g();
        },
        start: (k) => {
          let {
            originalEvent: P
          } = k;
          P.stopPropagation();
        }
      },
      ...e.touch === !0 ? {} : e.touch
    });
    return re(() => dt(b(e.tag, {
      ref: r,
      class: le(["v-window", {
        "v-window--show-arrows-on-hover": e.showArrows === "hover",
        "v-window--vertical-arrows": !!e.verticalArrows,
        "v-window--crossfade": !!e.crossfade
      }, a.value, e.class]),
      style: he([e.style, e.transitionDuration && !aa ? {
        "--v-window-transition-duration": pe(e.transitionDuration, "ms")
      } : void 0])
    }, {
      default: () => {
        var E, k;
        return [S("div", {
          class: "v-window__container",
          style: {
            height: f.value
          }
        }, [(E = n.default) == null ? void 0 : E.call(n, {
          group: o
        }), e.showArrows !== !1 && S("div", {
          class: le(["v-window__controls", {
            "v-window__controls--left": e.verticalArrows === "left" || e.verticalArrows === !0
          }, {
            "v-window__controls--right": e.verticalArrows === "right"
          }])
        }, [y.value])]), (k = n.additional) == null ? void 0 : k.call(n, {
          group: o
        })];
      }
    }), [[Cr, _.value]])), {
      group: o
    };
  }
}), yE = z({
  color: String,
  cycle: Boolean,
  delimiterIcon: {
    type: Ve,
    default: "$delimiter"
  },
  height: {
    type: [Number, String],
    default: 500
  },
  hideDelimiters: Boolean,
  hideDelimiterBackground: Boolean,
  interval: {
    type: [Number, String],
    default: 6e3,
    validator: (e) => Number(e) > 0
  },
  progress: [Boolean, String],
  verticalDelimiters: [Boolean, String],
  ...Jr({
    continuous: !0,
    mandatory: "force",
    showArrows: !0
  })
}, "VCarousel"), bE = ne()({
  name: "VCarousel",
  props: yE(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue"), {
      t: l
    } = nt(), i = Z();
    let o = -1;
    me(a, s), me(() => e.interval, s), me(() => e.cycle, (d) => {
      d ? s() : window.clearTimeout(o);
    }), At(r);
    function r() {
      !e.cycle || !i.value || (o = window.setTimeout(i.value.group.next, Number(e.interval) > 0 ? Number(e.interval) : 6e3));
    }
    function s() {
      window.clearTimeout(o), window.requestAnimationFrame(r);
    }
    return re(() => {
      const d = bl.filterProps(e);
      return b(bl, Q({
        ref: i
      }, d, {
        modelValue: a.value,
        "onUpdate:modelValue": (u) => a.value = u,
        class: ["v-carousel", {
          "v-carousel--hide-delimiter-background": e.hideDelimiterBackground,
          "v-carousel--vertical-delimiters": e.verticalDelimiters
        }, e.class],
        style: [{
          height: pe(e.height)
        }, e.style]
      }), {
        default: n.default,
        additional: (u) => {
          let {
            group: c
          } = u;
          return S(ye, null, [!e.hideDelimiters && S("div", {
            class: "v-carousel__controls",
            style: {
              left: e.verticalDelimiters === "left" && e.verticalDelimiters ? 0 : "auto",
              right: e.verticalDelimiters === "right" ? 0 : "auto"
            }
          }, [c.items.value.length > 0 && b(Be, {
            defaults: {
              VBtn: {
                color: e.color,
                icon: e.delimiterIcon,
                size: "x-small",
                variant: "text"
              }
            },
            scoped: !0
          }, {
            default: () => [c.items.value.map((f, v) => {
              const m = {
                id: `carousel-item-${f.id}`,
                "aria-label": l("$vuetify.carousel.ariaLabel.delimiter", v + 1, c.items.value.length),
                class: ["v-carousel__controls__item", c.isSelected(f.id) && "v-btn--active"],
                onClick: () => c.select(f.id, !0)
              };
              return n.item ? n.item({
                props: m,
                item: f
              }) : b(Le, Q(f, m), null);
            })]
          })]), e.progress && b(Ur, {
            absolute: !0,
            class: "v-carousel__progress",
            color: typeof e.progress == "string" ? e.progress : void 0,
            modelValue: (c.getItemIndex(a.value) + 1) / c.items.value.length * 100
          }, null)]);
        },
        prev: n.prev,
        next: n.next
      });
    }), {};
  }
}), Zr = z({
  reverseTransition: {
    type: [Boolean, String],
    default: void 0
  },
  transition: {
    type: [Boolean, String],
    default: void 0
  },
  ...ke(),
  ...Nl(),
  ...ad()
}, "VWindowItem"), pl = ne()({
  name: "VWindowItem",
  directives: {
    vTouch: Cr
  },
  props: Zr(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Me(ub), l = Dl(e, cb), {
      isBooted: i
    } = El();
    if (!a || !l) throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
    const o = fe(!1), r = x(() => i.value && (a.isReversed.value ? e.reverseTransition !== !1 : e.transition !== !1));
    function s() {
      !o.value || !a || (o.value = !1, a.transitionCount.value > 0 && (a.transitionCount.value -= 1, a.transitionCount.value === 0 && (a.transitionHeight.value = void 0)));
    }
    function d() {
      var m;
      o.value || !a || (o.value = !0, a.transitionCount.value === 0 && (a.transitionHeight.value = pe((m = a.rootRef.value) == null ? void 0 : m.clientHeight)), a.transitionCount.value += 1);
    }
    function u() {
      s();
    }
    function c(m) {
      o.value && He(() => {
        !r.value || !o.value || !a || (a.transitionHeight.value = pe(m.clientHeight));
      });
    }
    const f = x(() => {
      const m = a.isReversed.value ? e.reverseTransition : e.transition;
      return r.value ? {
        name: typeof m != "string" ? a.transition.value : m,
        onBeforeEnter: d,
        onAfterEnter: s,
        onEnterCancelled: u,
        onBeforeLeave: d,
        onAfterLeave: s,
        onLeaveCancelled: u,
        onEnter: c
      } : !1;
    }), {
      hasContent: v
    } = ld(e, l.isSelected);
    return re(() => b(Zt, {
      transition: f.value,
      disabled: !i.value
    }, {
      default: () => {
        var m;
        return [dt(S("div", {
          class: le(["v-window-item", l.selectedClass.value, e.class]),
          style: he(e.style)
        }, [v.value && ((m = n.default) == null ? void 0 : m.call(n))]), [[Nn, l.isSelected.value]])];
      }
    })), {
      groupItem: l
    };
  }
}), pE = z({
  ...Xg(),
  ...Zr()
}, "VCarouselItem"), SE = ne()({
  name: "VCarouselItem",
  inheritAttrs: !1,
  props: pE(),
  setup(e, t) {
    let {
      slots: n,
      attrs: a
    } = t;
    re(() => {
      const l = Sa.filterProps(e), i = pl.filterProps(e);
      return b(pl, Q({
        class: ["v-carousel-item", e.class]
      }, i), {
        default: () => [b(Sa, Q(a, l), n)]
      });
    });
  }
}), wE = Ca("v-code", "code"), _E = z({
  color: {
    type: Object
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  height: {
    type: [Number, String],
    default: 150
  },
  width: {
    type: [Number, String],
    default: 300
  },
  ...ke()
}, "VColorPickerCanvas"), xE = Cn({
  name: "VColorPickerCanvas",
  props: _E(),
  emits: {
    "update:color": (e) => !0,
    "update:position": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const a = fe(!1), l = Z(), i = fe(parseFloat(e.width)), o = fe(parseFloat(e.height)), r = Z({
      x: 0,
      y: 0
    }), s = x({
      get: () => r.value,
      set(g) {
        var _, E;
        if (!l.value) return;
        const {
          x: p,
          y
        } = g;
        r.value = g, n("update:color", {
          h: ((_ = e.color) == null ? void 0 : _.h) ?? 0,
          s: ot(p, 0, i.value) / i.value,
          v: 1 - ot(y, 0, o.value) / o.value,
          a: ((E = e.color) == null ? void 0 : E.a) ?? 1
        });
      }
    }), d = x(() => {
      const {
        x: g,
        y: p
      } = s.value, y = parseInt(e.dotSize, 10) / 2;
      return {
        width: pe(e.dotSize),
        height: pe(e.dotSize),
        transform: `translate(${pe(g - y)}, ${pe(p - y)})`
      };
    }), {
      resizeRef: u
    } = In((g) => {
      var _;
      if (!((_ = u.el) != null && _.offsetParent)) return;
      const {
        width: p,
        height: y
      } = g[0].contentRect;
      i.value = p, o.value = y;
    });
    function c(g, p, y) {
      const {
        left: _,
        top: E,
        width: k,
        height: P
      } = y;
      s.value = {
        x: ot(g - _, 0, k),
        y: ot(p - E, 0, P)
      };
    }
    function f(g) {
      g.type === "mousedown" && g.preventDefault(), !e.disabled && (v(g), window.addEventListener("mousemove", v), window.addEventListener("mouseup", m), window.addEventListener("touchmove", v), window.addEventListener("touchend", m));
    }
    function v(g) {
      if (e.disabled || !l.value) return;
      a.value = !0;
      const p = Px(g);
      c(p.clientX, p.clientY, l.value.getBoundingClientRect());
    }
    function m() {
      window.removeEventListener("mousemove", v), window.removeEventListener("mouseup", m), window.removeEventListener("touchmove", v), window.removeEventListener("touchend", m);
    }
    function h() {
      var E;
      if (!l.value) return;
      const g = l.value, p = g.getContext("2d");
      if (!p) return;
      const y = p.createLinearGradient(0, 0, g.width, 0);
      y.addColorStop(0, "hsla(0, 0%, 100%, 1)"), y.addColorStop(1, `hsla(${((E = e.color) == null ? void 0 : E.h) ?? 0}, 100%, 50%, 1)`), p.fillStyle = y, p.fillRect(0, 0, g.width, g.height);
      const _ = p.createLinearGradient(0, 0, 0, g.height);
      _.addColorStop(0, "hsla(0, 0%, 0%, 0)"), _.addColorStop(1, "hsla(0, 0%, 0%, 1)"), p.fillStyle = _, p.fillRect(0, 0, g.width, g.height);
    }
    return me(() => {
      var g;
      return (g = e.color) == null ? void 0 : g.h;
    }, h, {
      immediate: !0
    }), me(() => [i.value, o.value], (g, p) => {
      h(), r.value = {
        x: s.value.x * g[0] / p[0],
        y: s.value.y * g[1] / p[1]
      };
    }, {
      flush: "post"
    }), me(() => e.color, () => {
      if (a.value) {
        a.value = !1;
        return;
      }
      r.value = e.color ? {
        x: e.color.s * i.value,
        y: (1 - e.color.v) * o.value
      } : {
        x: 0,
        y: 0
      };
    }, {
      deep: !0,
      immediate: !0
    }), At(() => h()), re(() => S("div", {
      ref: u,
      class: le(["v-color-picker-canvas", e.class]),
      style: he(e.style),
      onMousedown: f,
      onTouchstartPassive: f
    }, [S("canvas", {
      ref: l,
      width: i.value,
      height: o.value
    }, null), e.color && S("div", {
      class: le(["v-color-picker-canvas__dot", {
        "v-color-picker-canvas__dot--disabled": e.disabled
      }]),
      style: he(d.value)
    }, null)])), {};
  }
});
function kE(e, t) {
  if (t) {
    const {
      a: n,
      ...a
    } = e;
    return a;
  }
  return e;
}
function CE(e, t) {
  if (t == null || typeof t == "string") {
    const n = e.a !== 1;
    if (t != null && t.startsWith("rgb(")) {
      const {
        r: l,
        g: i,
        b: o,
        a: r
      } = la(e);
      return `rgb(${l} ${i} ${o}` + (n ? ` / ${r})` : ")");
    } else if (t != null && t.startsWith("hsl(")) {
      const {
        h: l,
        s: i,
        l: o,
        a: r
      } = pu(e);
      return `hsl(${l} ${Math.round(i * 100)} ${Math.round(o * 100)}` + (n ? ` / ${r})` : ")");
    }
    const a = Eg(e);
    return e.a === 1 ? a.slice(0, 7) : a;
  }
  if (typeof t == "object") {
    let n;
    return tl(t, ["r", "g", "b"]) ? n = la(e) : tl(t, ["h", "s", "l"]) ? n = pu(e) : tl(t, ["h", "s", "v"]) && (n = e), kE(n, !tl(t, ["a"]) && e.a === 1);
  }
  return e;
}
const Gl = {
  h: 0,
  s: 0,
  v: 0,
  a: 1
}, $u = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "R",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.r),
    getColor: (e, t) => ({
      ...e,
      r: Number(t)
    }),
    localeKey: "redInput"
  }, {
    label: "G",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.g),
    getColor: (e, t) => ({
      ...e,
      g: Number(t)
    }),
    localeKey: "greenInput"
  }, {
    label: "B",
    max: 255,
    step: 1,
    getValue: (e) => Math.round(e.b),
    getColor: (e, t) => ({
      ...e,
      b: Number(t)
    }),
    localeKey: "blueInput"
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    }),
    localeKey: "alphaInput"
  }],
  to: la,
  from: po
};
var Qv;
const VE = {
  ...$u,
  inputs: (Qv = $u.inputs) == null ? void 0 : Qv.slice(0, 3)
}, Bu = {
  inputProps: {
    type: "number",
    min: 0
  },
  inputs: [{
    label: "H",
    max: 360,
    step: 1,
    getValue: (e) => Math.round(e.h),
    getColor: (e, t) => ({
      ...e,
      h: Number(t)
    }),
    localeKey: "hueInput"
  }, {
    label: "S",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.s * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      s: Number(t)
    }),
    localeKey: "saturationInput"
  }, {
    label: "L",
    max: 1,
    step: 0.01,
    getValue: (e) => Math.round(e.l * 100) / 100,
    getColor: (e, t) => ({
      ...e,
      l: Number(t)
    }),
    localeKey: "lightnessInput"
  }, {
    label: "A",
    max: 1,
    step: 0.01,
    getValue: (e) => {
      let {
        a: t
      } = e;
      return t != null ? Math.round(t * 100) / 100 : 1;
    },
    getColor: (e, t) => ({
      ...e,
      a: Number(t)
    }),
    localeKey: "alphaInput"
  }],
  to: pu,
  from: Ac
}, EE = {
  ...Bu,
  inputs: Bu.inputs.slice(0, 3)
}, db = {
  inputProps: {
    type: "text"
  },
  inputs: [{
    label: "HEXA",
    getValue: (e) => e,
    getColor: (e, t) => t,
    localeKey: "hexaInput"
  }],
  to: Eg,
  from: Qx
}, PE = {
  ...db,
  inputs: [{
    label: "HEX",
    getValue: (e) => e.slice(0, 7),
    getColor: (e, t) => t,
    localeKey: "hexInput"
  }]
}, fl = {
  rgb: VE,
  rgba: $u,
  hsl: EE,
  hsla: Bu,
  hex: PE,
  hexa: db
}, IE = (e) => {
  let {
    label: t,
    ...n
  } = e;
  return S("div", {
    class: "v-color-picker-edit__input"
  }, [S("input", Yp(Ch(n)), null), S("span", null, [t])]);
}, NE = z({
  color: Object,
  disabled: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(fl).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(fl),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(fl).includes(t))
  },
  ...ke()
}, "VColorPickerEdit"), DE = Cn({
  name: "VColorPickerEdit",
  props: NE(),
  emits: {
    "update:color": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const {
      t: a
    } = nt(), l = x(() => e.modes.map((o) => ({
      ...fl[o],
      name: o
    }))), i = x(() => {
      var s;
      const o = l.value.find((d) => d.name === e.mode);
      if (!o) return [];
      const r = e.color ? o.to(e.color) : null;
      return (s = o.inputs) == null ? void 0 : s.map((d) => {
        let {
          getValue: u,
          getColor: c,
          localeKey: f,
          ...v
        } = d;
        return {
          ...o.inputProps,
          ...v,
          ariaLabel: a(`$vuetify.colorPicker.ariaLabel.${f}`),
          disabled: e.disabled,
          value: r && u(r),
          onChange: (m) => {
            const h = m.target;
            h && n("update:color", o.from(c(r ?? o.to(Gl), h.value)));
          }
        };
      });
    });
    return re(() => {
      var o;
      return S("div", {
        class: le(["v-color-picker-edit", e.class]),
        style: he(e.style)
      }, [(o = i.value) == null ? void 0 : o.map((r) => b(IE, r, null)), l.value.length > 1 && b(Le, {
        icon: "$unfold",
        size: "x-small",
        variant: "plain",
        "aria-label": a("$vuetify.colorPicker.ariaLabel.changeFormat"),
        onClick: () => {
          const r = l.value.findIndex((s) => s.name === e.mode);
          n("update:mode", l.value[(r + 1) % l.value.length].name);
        }
      }, null)]);
    }), {};
  }
}), ud = Symbol.for("vuetify:v-slider");
function Mu(e, t, n) {
  const a = n === "vertical", l = t.getBoundingClientRect(), i = "touches" in e ? e.touches[0] : e;
  return a ? i.clientY - (l.top + l.height / 2) : i.clientX - (l.left + l.width / 2);
}
function AE(e, t) {
  return "touches" in e && e.touches.length ? e.touches[0][t] : "changedTouches" in e && e.changedTouches.length ? e.changedTouches[0][t] : e[t];
}
const fb = z({
  disabled: {
    type: Boolean,
    default: null
  },
  error: Boolean,
  readonly: {
    type: Boolean,
    default: null
  },
  max: {
    type: [Number, String],
    default: 100
  },
  min: {
    type: [Number, String],
    default: 0
  },
  step: {
    type: [Number, String],
    default: 0
  },
  thumbColor: String,
  thumbLabel: {
    type: [Boolean, String],
    default: void 0,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  thumbSize: {
    type: [Number, String],
    default: 20
  },
  showTicks: {
    type: [Boolean, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || e === "always"
  },
  ticks: {
    type: [Array, Object]
  },
  tickSize: {
    type: [Number, String],
    default: 2
  },
  color: String,
  trackColor: String,
  trackFillColor: String,
  trackSize: {
    type: [Number, String],
    default: 4
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  reverse: Boolean,
  noKeyboard: Boolean,
  ...ft(),
  ...Pt({
    elevation: 2
  }),
  ripple: {
    type: Boolean,
    default: !0
  }
}, "Slider"), vb = (e) => {
  const t = x(() => parseFloat(e.min)), n = x(() => parseFloat(e.max)), a = x(() => Number(e.step) > 0 ? parseFloat(e.step) : 0), l = x(() => Math.max(Gf(a.value), Gf(t.value)));
  function i(o) {
    if (o = parseFloat(o), a.value <= 0) return o;
    const r = ot(o, t.value, n.value), s = t.value % a.value;
    let d = Math.round((r - s) / a.value) * a.value + s;
    return r > d && d + a.value > n.value && (d = n.value), parseFloat(Math.min(d, n.value).toFixed(l.value));
  }
  return {
    min: t,
    max: n,
    step: a,
    decimals: l,
    roundValue: i
  };
}, mb = (e) => {
  let {
    props: t,
    steps: n,
    onSliderStart: a,
    onSliderMove: l,
    onSliderEnd: i,
    getActiveThumb: o
  } = e;
  const r = yi(t), {
    isRtl: s
  } = Et(), d = R(() => t.reverse), u = x(() => t.direction === "vertical"), c = x(() => u.value !== d.value), {
    min: f,
    max: v,
    step: m,
    decimals: h,
    roundValue: g
  } = n, p = x(() => parseInt(t.thumbSize, 10)), y = x(() => parseInt(t.tickSize, 10)), _ = x(() => parseInt(t.trackSize, 10)), E = x(() => (v.value - f.value) / m.value), k = x(() => t.error || r.isDisabled.value ? void 0 : t.thumbColor ?? t.color), P = x(() => t.error || r.isDisabled.value ? void 0 : t.thumbColor), A = x(() => t.error || r.isDisabled.value ? void 0 : t.trackColor ?? t.color), D = x(() => t.error || r.isDisabled.value ? void 0 : t.trackFillColor ?? t.color), N = fe(!1), V = fe(0), I = Z(), w = Z();
  function T(B) {
    var X;
    const G = (X = I.value) == null ? void 0 : X.$el;
    if (!G) return;
    const ie = t.direction === "vertical", de = ie ? "top" : "left", Se = ie ? "height" : "width", Ce = ie ? "clientY" : "clientX", {
      [de]: C,
      [Se]: O
    } = G.getBoundingClientRect(), $ = AE(B, Ce);
    let K = ot(($ - C - V.value) / O) || 0;
    return (ie ? c.value : c.value !== s.value) && (K = 1 - K), g(f.value + K * (v.value - f.value));
  }
  const M = (B) => {
    const G = T(B);
    G != null && i({
      value: G
    }), N.value = !1, V.value = 0;
  }, W = (B) => {
    const G = T(B);
    w.value = o(B), w.value && (N.value = !0, w.value.contains(B.target) ? V.value = Mu(B, w.value, t.direction) : (V.value = 0, G != null && l({
      value: G
    })), G != null && a({
      value: G
    }), He(() => {
      var ie;
      return (ie = w.value) == null ? void 0 : ie.focus();
    }));
  }, J = {
    passive: !0,
    capture: !0
  };
  function ee(B) {
    const G = T(B);
    G != null && l({
      value: G
    });
  }
  function Y(B) {
    B.stopPropagation(), B.preventDefault(), M(B), window.removeEventListener("mousemove", ee, J), window.removeEventListener("mouseup", Y);
  }
  function L(B) {
    var G;
    M(B), window.removeEventListener("touchmove", ee, J), (G = B.target) == null || G.removeEventListener("touchend", L);
  }
  function H(B) {
    var G;
    W(B), window.addEventListener("touchmove", ee, J), (G = B.target) == null || G.addEventListener("touchend", L, {
      passive: !1
    });
  }
  function j(B) {
    B.button === 0 && (B.preventDefault(), W(B), window.addEventListener("mousemove", ee, J), window.addEventListener("mouseup", Y, {
      passive: !1
    }));
  }
  const U = (B) => {
    const G = (B - f.value) / (v.value - f.value) * 100;
    return ot(isNaN(G) ? 0 : G, 0, 100);
  }, F = R(() => t.showTicks), oe = x(() => F.value ? t.ticks ? Array.isArray(t.ticks) ? t.ticks.map((B) => ({
    value: B,
    position: U(B),
    label: B.toString()
  })) : Object.keys(t.ticks).map((B) => ({
    value: parseFloat(B),
    position: U(parseFloat(B)),
    label: t.ticks[B]
  })) : E.value !== 1 / 0 ? bn(E.value + 1).map((B) => {
    const G = f.value + B * m.value;
    return {
      value: G,
      position: U(G)
    };
  }) : [] : []), ve = x(() => oe.value.some((B) => {
    let {
      label: G
    } = B;
    return !!G;
  })), _e = {
    activeThumbRef: w,
    color: R(() => t.color),
    decimals: h,
    disabled: r.isDisabled,
    direction: R(() => t.direction),
    elevation: R(() => t.elevation),
    hasLabels: ve,
    isReversed: d,
    indexFromEnd: c,
    min: f,
    max: v,
    mousePressed: N,
    noKeyboard: R(() => t.noKeyboard),
    numTicks: E,
    onSliderMousedown: j,
    onSliderTouchstart: H,
    parsedTicks: oe,
    parseMouseMove: T,
    position: U,
    readonly: r.isReadonly,
    rounded: R(() => t.rounded),
    roundValue: g,
    showTicks: F,
    startOffset: V,
    step: m,
    thumbSize: p,
    thumbColor: k,
    thumbLabelColor: P,
    thumbLabel: R(() => t.thumbLabel),
    ticks: R(() => t.ticks),
    tickSize: y,
    trackColor: A,
    trackContainerRef: I,
    trackFillColor: D,
    trackSize: _,
    vertical: u
  };
  return at(ud, _e), _e;
}, TE = z({
  focused: Boolean,
  max: {
    type: Number,
    required: !0
  },
  min: {
    type: Number,
    required: !0
  },
  modelValue: {
    type: Number,
    required: !0
  },
  position: {
    type: Number,
    required: !0
  },
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  name: String,
  noKeyboard: Boolean,
  ...ke()
}, "VSliderThumb"), Ru = ne()({
  name: "VSliderThumb",
  directives: {
    vRipple: en
  },
  props: TE(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const l = Me(ud), {
      isRtl: i,
      rtlClasses: o
    } = Et();
    if (!l) throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
    const {
      min: r,
      max: s,
      thumbColor: d,
      thumbLabelColor: u,
      step: c,
      disabled: f,
      thumbSize: v,
      thumbLabel: m,
      direction: h,
      isReversed: g,
      vertical: p,
      readonly: y,
      elevation: _,
      mousePressed: E,
      decimals: k,
      indexFromEnd: P
    } = l, A = x(() => f.value ? void 0 : _.value), {
      elevationClasses: D
    } = Rt(A), {
      textColorClasses: N,
      textColorStyles: V
    } = jt(d), {
      backgroundColorClasses: I,
      backgroundColorStyles: w
    } = Xe(u), {
      pageup: T,
      pagedown: M,
      end: W,
      home: J,
      left: ee,
      right: Y,
      down: L,
      up: H
    } = vu, j = [T, M, W, J, ee, Y, L, H], U = x(() => c.value ? [1, 2, 3] : [1, 5, 10]);
    function F(ve, _e) {
      if (e.noKeyboard || !j.includes(ve.key)) return;
      ve.preventDefault();
      const B = c.value || 0.1, G = (s.value - r.value) / B;
      if ([ee, Y, L, H].includes(ve.key)) {
        const de = (p.value ? [i.value ? ee : Y, g.value ? L : H] : P.value !== i.value ? [ee, H] : [Y, H]).includes(ve.key) ? 1 : -1, Se = ve.shiftKey ? 2 : ve.ctrlKey ? 1 : 0;
        de === -1 && _e === s.value && !Se && !Number.isInteger(G) ? _e = _e - G % 1 * B : _e = _e + de * B * U.value[Se];
      } else if (ve.key === J)
        _e = r.value;
      else if (ve.key === W)
        _e = s.value;
      else {
        const ie = ve.key === M ? 1 : -1;
        _e = _e - ie * B * (G > 100 ? G / 10 : 10);
      }
      return Math.max(e.min, Math.min(e.max, _e));
    }
    function oe(ve) {
      const _e = F(ve, e.modelValue);
      _e != null && a("update:modelValue", _e);
    }
    return re(() => {
      const ve = pe(P.value ? 100 - e.position : e.position, "%");
      return S("div", {
        class: le(["v-slider-thumb", {
          "v-slider-thumb--focused": e.focused,
          "v-slider-thumb--pressed": e.focused && E.value
        }, e.class, o.value]),
        style: he([{
          "--v-slider-thumb-position": ve,
          "--v-slider-thumb-size": pe(v.value)
        }, e.style]),
        role: "slider",
        tabindex: f.value ? -1 : 0,
        "aria-label": e.name,
        "aria-valuemin": r.value,
        "aria-valuemax": s.value,
        "aria-valuenow": e.modelValue,
        "aria-readonly": !!y.value,
        "aria-orientation": h.value,
        onKeydown: y.value ? void 0 : oe
      }, [S("div", {
        class: le(["v-slider-thumb__surface", N.value, D.value]),
        style: he(V.value)
      }, null), dt(S("div", {
        class: le(["v-slider-thumb__ripple", N.value]),
        style: he(V.value)
      }, null), [[en, e.ripple, null, {
        circle: !0,
        center: !0
      }]]), b(jc, {
        origin: "bottom center"
      }, {
        default: () => {
          var _e;
          return [dt(S("div", {
            class: "v-slider-thumb__label-container"
          }, [S("div", {
            class: le(["v-slider-thumb__label", I.value]),
            style: he(w.value)
          }, [S("div", null, [((_e = n["thumb-label"]) == null ? void 0 : _e.call(n, {
            modelValue: e.modelValue
          })) ?? e.modelValue.toFixed(c.value ? k.value : 1)]), S("div", {
            class: "v-slider-thumb__label-wedge"
          }, null)])]), [[Nn, m.value && e.focused || m.value === "always"]])];
        }
      })]);
    }), {};
  }
}), OE = z({
  start: {
    type: Number,
    required: !0
  },
  stop: {
    type: Number,
    required: !0
  },
  ...ke()
}, "VSliderTrack"), hb = ne()({
  name: "VSliderTrack",
  props: OE(),
  emits: {},
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Me(ud);
    if (!a) throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
    const {
      color: l,
      parsedTicks: i,
      rounded: o,
      showTicks: r,
      tickSize: s,
      trackColor: d,
      trackFillColor: u,
      trackSize: c,
      vertical: f,
      min: v,
      max: m,
      indexFromEnd: h
    } = a, {
      roundedClasses: g
    } = yt(o), {
      backgroundColorClasses: p,
      backgroundColorStyles: y
    } = Xe(u), {
      backgroundColorClasses: _,
      backgroundColorStyles: E
    } = Xe(d), k = x(() => `inset-${f.value ? "block" : "inline"}-${h.value ? "end" : "start"}`), P = x(() => f.value ? "height" : "width"), A = x(() => ({
      [k.value]: "0%",
      [P.value]: "100%"
    })), D = x(() => e.stop - e.start), N = x(() => ({
      [k.value]: pe(e.start, "%"),
      [P.value]: pe(D.value, "%")
    })), V = x(() => r.value ? (f.value ? i.value.slice().reverse() : i.value).map((w, T) => {
      var W;
      const M = w.value !== v.value && w.value !== m.value ? pe(w.position, "%") : void 0;
      return S("div", {
        key: w.value,
        class: le(["v-slider-track__tick", {
          "v-slider-track__tick--filled": w.position >= e.start && w.position <= e.stop,
          "v-slider-track__tick--first": w.value === v.value,
          "v-slider-track__tick--last": w.value === m.value
        }]),
        style: {
          [k.value]: M
        }
      }, [(w.label || n["tick-label"]) && S("div", {
        class: "v-slider-track__tick-label"
      }, [((W = n["tick-label"]) == null ? void 0 : W.call(n, {
        tick: w,
        index: T
      })) ?? w.label])]);
    }) : []);
    return re(() => S("div", {
      class: le(["v-slider-track", g.value, e.class]),
      style: he([{
        "--v-slider-track-size": pe(c.value),
        "--v-slider-tick-size": pe(s.value)
      }, e.style])
    }, [S("div", {
      class: le(["v-slider-track__background", _.value, {
        "v-slider-track__background--opacity": !!l.value || !u.value
      }]),
      style: {
        ...A.value,
        ...E.value
      }
    }, null), S("div", {
      class: le(["v-slider-track__fill", p.value]),
      style: {
        ...N.value,
        ...y.value
      }
    }, null), r.value && S("div", {
      class: le(["v-slider-track__ticks", {
        "v-slider-track__ticks--always-show": r.value === "always"
      }])
    }, [V.value])])), {};
  }
}), $E = z({
  ...Eo(),
  ...fb(),
  ...Pa(),
  modelValue: {
    type: [Number, String],
    default: 0
  }
}, "VSlider"), Lu = ne()({
  name: "VSlider",
  props: $E(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    start: (e) => !0,
    end: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const l = Z(), i = Z(), {
      rtlClasses: o
    } = Et(), r = vb(e), s = Ee(e, "modelValue", void 0, (N) => r.roundValue(N ?? r.min.value)), {
      min: d,
      max: u,
      mousePressed: c,
      roundValue: f,
      onSliderMousedown: v,
      onSliderTouchstart: m,
      trackContainerRef: h,
      position: g,
      hasLabels: p,
      disabled: y,
      readonly: _,
      noKeyboard: E
    } = mb({
      props: e,
      steps: r,
      onSliderStart: () => {
        a("start", s.value);
      },
      onSliderEnd: (N) => {
        let {
          value: V
        } = N;
        const I = f(V);
        s.value = I, a("end", I);
      },
      onSliderMove: (N) => {
        let {
          value: V
        } = N;
        return s.value = f(V);
      },
      getActiveThumb: () => {
        var N;
        return (N = l.value) == null ? void 0 : N.$el;
      }
    }), {
      isFocused: k,
      focus: P,
      blur: A
    } = Ea(e), D = x(() => g(s.value));
    return re(() => {
      const N = Kt.filterProps(e), V = !!(e.label || n.label || n.prepend);
      return b(Kt, Q({
        ref: i,
        class: ["v-slider", {
          "v-slider--has-labels": !!n["tick-label"] || p.value,
          "v-slider--focused": k.value,
          "v-slider--pressed": c.value,
          "v-slider--disabled": e.disabled
        }, o.value, e.class],
        style: e.style
      }, N, {
        focused: k.value
      }), {
        ...n,
        prepend: V ? (I) => {
          var w, T;
          return S(ye, null, [((w = n.label) == null ? void 0 : w.call(n, I)) ?? (e.label ? b(gi, {
            id: I.id.value,
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (T = n.prepend) == null ? void 0 : T.call(n, I)]);
        } : void 0,
        default: (I) => {
          let {
            id: w,
            messagesId: T
          } = I;
          return S("div", {
            class: "v-slider__container",
            onMousedown: _.value ? void 0 : v,
            onTouchstartPassive: _.value ? void 0 : m
          }, [S("input", {
            id: w.value,
            name: e.name || w.value,
            disabled: !!y.value,
            readonly: !!_.value,
            tabindex: "-1",
            value: s.value
          }, null), b(hb, {
            ref: h,
            start: 0,
            stop: D.value
          }, {
            "tick-label": n["tick-label"]
          }), b(Ru, {
            ref: l,
            "aria-describedby": T.value,
            focused: k.value,
            noKeyboard: E.value,
            min: d.value,
            max: u.value,
            modelValue: s.value,
            "onUpdate:modelValue": (M) => s.value = M,
            position: D.value,
            elevation: e.elevation,
            onFocus: P,
            onBlur: A,
            ripple: e.ripple,
            name: e.name
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), Lt({
      focus: () => {
        var N;
        return (N = l.value) == null ? void 0 : N.$el.focus();
      }
    }, i);
  }
}), gb = z({
  color: {
    type: Object
  },
  disabled: Boolean,
  hideAlpha: Boolean,
  hideEyeDropper: Boolean,
  eyeDropperIcon: {
    type: Ve,
    default: "$eyeDropper"
  },
  ...ke()
}, "VColorPickerPreview"), BE = Cn({
  name: "VColorPickerPreview",
  props: gb(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const {
      t: a
    } = nt(), l = new AbortController();
    Or(() => l.abort());
    async function i() {
      if (!zf || e.disabled) return;
      const o = new window.EyeDropper();
      try {
        const r = await o.open({
          signal: l.signal
        }), s = po(pn(r.sRGBHex));
        n("update:color", {
          ...e.color ?? Gl,
          ...s
        });
      } catch {
      }
    }
    return re(() => {
      var o, r;
      return S("div", {
        class: le(["v-color-picker-preview", {
          "v-color-picker-preview--hide-alpha": e.hideAlpha
        }, e.class]),
        style: he(e.style)
      }, [zf && !e.hideEyeDropper && S("div", {
        class: "v-color-picker-preview__eye-dropper",
        key: "eyeDropper"
      }, [b(Le, {
        "aria-label": a("$vuetify.colorPicker.ariaLabel.eyedropper"),
        density: "comfortable",
        disabled: e.disabled,
        icon: e.eyeDropperIcon,
        variant: "plain",
        onClick: i
      }, null)]), S("div", {
        class: "v-color-picker-preview__dot"
      }, [S("div", {
        style: {
          background: kg(e.color ?? Gl)
        }
      }, null)]), S("div", {
        class: "v-color-picker-preview__sliders"
      }, [b(Lu, {
        class: "v-color-picker-preview__track v-color-picker-preview__hue",
        name: a("$vuetify.colorPicker.ariaLabel.hueSlider"),
        modelValue: (o = e.color) == null ? void 0 : o.h,
        "onUpdate:modelValue": (s) => n("update:color", {
          ...e.color ?? Gl,
          h: s
        }),
        step: 0,
        min: 0,
        max: 360,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null), !e.hideAlpha && b(Lu, {
        class: "v-color-picker-preview__track v-color-picker-preview__alpha",
        name: a("$vuetify.colorPicker.ariaLabel.alphaSlider"),
        modelValue: ((r = e.color) == null ? void 0 : r.a) ?? 1,
        "onUpdate:modelValue": (s) => n("update:color", {
          ...e.color ?? Gl,
          a: s
        }),
        step: 1 / 256,
        min: 0,
        max: 1,
        disabled: e.disabled,
        thumbSize: 14,
        trackSize: 8,
        trackFillColor: "white",
        hideDetails: !0
      }, null)])]);
    }), {};
  }
}), ME = {
  base: "#f44336",
  lighten5: "#ffebee",
  lighten4: "#ffcdd2",
  lighten3: "#ef9a9a",
  lighten2: "#e57373",
  lighten1: "#ef5350",
  darken1: "#e53935",
  darken2: "#d32f2f",
  darken3: "#c62828",
  darken4: "#b71c1c",
  accent1: "#ff8a80",
  accent2: "#ff5252",
  accent3: "#ff1744",
  accent4: "#d50000"
}, RE = {
  base: "#e91e63",
  lighten5: "#fce4ec",
  lighten4: "#f8bbd0",
  lighten3: "#f48fb1",
  lighten2: "#f06292",
  lighten1: "#ec407a",
  darken1: "#d81b60",
  darken2: "#c2185b",
  darken3: "#ad1457",
  darken4: "#880e4f",
  accent1: "#ff80ab",
  accent2: "#ff4081",
  accent3: "#f50057",
  accent4: "#c51162"
}, LE = {
  base: "#9c27b0",
  lighten5: "#f3e5f5",
  lighten4: "#e1bee7",
  lighten3: "#ce93d8",
  lighten2: "#ba68c8",
  lighten1: "#ab47bc",
  darken1: "#8e24aa",
  darken2: "#7b1fa2",
  darken3: "#6a1b9a",
  darken4: "#4a148c",
  accent1: "#ea80fc",
  accent2: "#e040fb",
  accent3: "#d500f9",
  accent4: "#aa00ff"
}, FE = {
  base: "#673ab7",
  lighten5: "#ede7f6",
  lighten4: "#d1c4e9",
  lighten3: "#b39ddb",
  lighten2: "#9575cd",
  lighten1: "#7e57c2",
  darken1: "#5e35b1",
  darken2: "#512da8",
  darken3: "#4527a0",
  darken4: "#311b92",
  accent1: "#b388ff",
  accent2: "#7c4dff",
  accent3: "#651fff",
  accent4: "#6200ea"
}, HE = {
  base: "#3f51b5",
  lighten5: "#e8eaf6",
  lighten4: "#c5cae9",
  lighten3: "#9fa8da",
  lighten2: "#7986cb",
  lighten1: "#5c6bc0",
  darken1: "#3949ab",
  darken2: "#303f9f",
  darken3: "#283593",
  darken4: "#1a237e",
  accent1: "#8c9eff",
  accent2: "#536dfe",
  accent3: "#3d5afe",
  accent4: "#304ffe"
}, zE = {
  base: "#2196f3",
  lighten5: "#e3f2fd",
  lighten4: "#bbdefb",
  lighten3: "#90caf9",
  lighten2: "#64b5f6",
  lighten1: "#42a5f5",
  darken1: "#1e88e5",
  darken2: "#1976d2",
  darken3: "#1565c0",
  darken4: "#0d47a1",
  accent1: "#82b1ff",
  accent2: "#448aff",
  accent3: "#2979ff",
  accent4: "#2962ff"
}, jE = {
  base: "#03a9f4",
  lighten5: "#e1f5fe",
  lighten4: "#b3e5fc",
  lighten3: "#81d4fa",
  lighten2: "#4fc3f7",
  lighten1: "#29b6f6",
  darken1: "#039be5",
  darken2: "#0288d1",
  darken3: "#0277bd",
  darken4: "#01579b",
  accent1: "#80d8ff",
  accent2: "#40c4ff",
  accent3: "#00b0ff",
  accent4: "#0091ea"
}, WE = {
  base: "#00bcd4",
  lighten5: "#e0f7fa",
  lighten4: "#b2ebf2",
  lighten3: "#80deea",
  lighten2: "#4dd0e1",
  lighten1: "#26c6da",
  darken1: "#00acc1",
  darken2: "#0097a7",
  darken3: "#00838f",
  darken4: "#006064",
  accent1: "#84ffff",
  accent2: "#18ffff",
  accent3: "#00e5ff",
  accent4: "#00b8d4"
}, UE = {
  base: "#009688",
  lighten5: "#e0f2f1",
  lighten4: "#b2dfdb",
  lighten3: "#80cbc4",
  lighten2: "#4db6ac",
  lighten1: "#26a69a",
  darken1: "#00897b",
  darken2: "#00796b",
  darken3: "#00695c",
  darken4: "#004d40",
  accent1: "#a7ffeb",
  accent2: "#64ffda",
  accent3: "#1de9b6",
  accent4: "#00bfa5"
}, GE = {
  base: "#4caf50",
  lighten5: "#e8f5e9",
  lighten4: "#c8e6c9",
  lighten3: "#a5d6a7",
  lighten2: "#81c784",
  lighten1: "#66bb6a",
  darken1: "#43a047",
  darken2: "#388e3c",
  darken3: "#2e7d32",
  darken4: "#1b5e20",
  accent1: "#b9f6ca",
  accent2: "#69f0ae",
  accent3: "#00e676",
  accent4: "#00c853"
}, KE = {
  base: "#8bc34a",
  lighten5: "#f1f8e9",
  lighten4: "#dcedc8",
  lighten3: "#c5e1a5",
  lighten2: "#aed581",
  lighten1: "#9ccc65",
  darken1: "#7cb342",
  darken2: "#689f38",
  darken3: "#558b2f",
  darken4: "#33691e",
  accent1: "#ccff90",
  accent2: "#b2ff59",
  accent3: "#76ff03",
  accent4: "#64dd17"
}, YE = {
  base: "#cddc39",
  lighten5: "#f9fbe7",
  lighten4: "#f0f4c3",
  lighten3: "#e6ee9c",
  lighten2: "#dce775",
  lighten1: "#d4e157",
  darken1: "#c0ca33",
  darken2: "#afb42b",
  darken3: "#9e9d24",
  darken4: "#827717",
  accent1: "#f4ff81",
  accent2: "#eeff41",
  accent3: "#c6ff00",
  accent4: "#aeea00"
}, qE = {
  base: "#ffeb3b",
  lighten5: "#fffde7",
  lighten4: "#fff9c4",
  lighten3: "#fff59d",
  lighten2: "#fff176",
  lighten1: "#ffee58",
  darken1: "#fdd835",
  darken2: "#fbc02d",
  darken3: "#f9a825",
  darken4: "#f57f17",
  accent1: "#ffff8d",
  accent2: "#ffff00",
  accent3: "#ffea00",
  accent4: "#ffd600"
}, XE = {
  base: "#ffc107",
  lighten5: "#fff8e1",
  lighten4: "#ffecb3",
  lighten3: "#ffe082",
  lighten2: "#ffd54f",
  lighten1: "#ffca28",
  darken1: "#ffb300",
  darken2: "#ffa000",
  darken3: "#ff8f00",
  darken4: "#ff6f00",
  accent1: "#ffe57f",
  accent2: "#ffd740",
  accent3: "#ffc400",
  accent4: "#ffab00"
}, JE = {
  base: "#ff9800",
  lighten5: "#fff3e0",
  lighten4: "#ffe0b2",
  lighten3: "#ffcc80",
  lighten2: "#ffb74d",
  lighten1: "#ffa726",
  darken1: "#fb8c00",
  darken2: "#f57c00",
  darken3: "#ef6c00",
  darken4: "#e65100",
  accent1: "#ffd180",
  accent2: "#ffab40",
  accent3: "#ff9100",
  accent4: "#ff6d00"
}, ZE = {
  base: "#ff5722",
  lighten5: "#fbe9e7",
  lighten4: "#ffccbc",
  lighten3: "#ffab91",
  lighten2: "#ff8a65",
  lighten1: "#ff7043",
  darken1: "#f4511e",
  darken2: "#e64a19",
  darken3: "#d84315",
  darken4: "#bf360c",
  accent1: "#ff9e80",
  accent2: "#ff6e40",
  accent3: "#ff3d00",
  accent4: "#dd2c00"
}, QE = {
  base: "#795548",
  lighten5: "#efebe9",
  lighten4: "#d7ccc8",
  lighten3: "#bcaaa4",
  lighten2: "#a1887f",
  lighten1: "#8d6e63",
  darken1: "#6d4c41",
  darken2: "#5d4037",
  darken3: "#4e342e",
  darken4: "#3e2723"
}, eP = {
  base: "#607d8b",
  lighten5: "#eceff1",
  lighten4: "#cfd8dc",
  lighten3: "#b0bec5",
  lighten2: "#90a4ae",
  lighten1: "#78909c",
  darken1: "#546e7a",
  darken2: "#455a64",
  darken3: "#37474f",
  darken4: "#263238"
}, tP = {
  base: "#9e9e9e",
  lighten5: "#fafafa",
  lighten4: "#f5f5f5",
  lighten3: "#eeeeee",
  lighten2: "#e0e0e0",
  lighten1: "#bdbdbd",
  darken1: "#757575",
  darken2: "#616161",
  darken3: "#424242",
  darken4: "#212121"
}, nP = {
  black: "#000000",
  white: "#ffffff",
  transparent: "#ffffff00"
}, aP = {
  red: ME,
  pink: RE,
  purple: LE,
  deepPurple: FE,
  indigo: HE,
  blue: zE,
  lightBlue: jE,
  cyan: WE,
  teal: UE,
  green: GE,
  lightGreen: KE,
  lime: YE,
  yellow: qE,
  amber: XE,
  orange: JE,
  deepOrange: ZE,
  brown: QE,
  blueGrey: eP,
  grey: tP,
  shades: nP
}, lP = z({
  swatches: {
    type: Array,
    default: () => iP(aP)
  },
  disabled: Boolean,
  color: Object,
  maxHeight: [Number, String],
  ...ke()
}, "VColorPickerSwatches");
function iP(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return n.base ? [n.base, n.darken4, n.darken3, n.darken2, n.darken1, n.lighten1, n.lighten2, n.lighten3, n.lighten4, n.lighten5] : [n.black, n.white, n.transparent];
  });
}
const oP = Cn({
  name: "VColorPickerSwatches",
  props: lP(),
  emits: {
    "update:color": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    return re(() => S("div", {
      class: le(["v-color-picker-swatches", e.class]),
      style: he([{
        maxHeight: pe(e.maxHeight)
      }, e.style])
    }, [S("div", null, [e.swatches.map((a) => S("div", {
      class: "v-color-picker-swatches__swatch"
    }, [a.map((l) => {
      const i = pn(l), o = po(i), r = xg(i);
      return S("div", {
        class: "v-color-picker-swatches__color",
        onClick: () => o && n("update:color", o)
      }, [S("div", {
        style: {
          background: r
        }
      }, [e.color && Mt(e.color, o) ? b(Ue, {
        size: "x-small",
        icon: "$success",
        color: ak(l, "#FFFFFF") > 2 ? "white" : "black"
      }, null) : void 0])]);
    })]))])])), {};
  }
}), rP = Ca("v-picker-title"), cd = z({
  color: String,
  ...cn(),
  ...ke(),
  ...kt(),
  ...Pt(),
  ...Va(),
  ...mi(),
  ...ft(),
  ...Oe(),
  ...We()
}, "VSheet"), ro = ne()({
  name: "VSheet",
  props: cd(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: i
    } = Xe(() => e.color), {
      borderClasses: o
    } = hn(e), {
      dimensionStyles: r
    } = Ct(e), {
      elevationClasses: s
    } = Rt(e), {
      locationStyles: d
    } = Al(e), {
      positionClasses: u
    } = hi(e), {
      roundedClasses: c
    } = yt(e);
    return re(() => b(e.tag, {
      class: le(["v-sheet", a.value, l.value, o.value, s.value, u.value, c.value, e.class]),
      style: he([i.value, r.value, d.value, e.style])
    }, n)), {};
  }
}), Qr = z({
  bgColor: String,
  divided: Boolean,
  landscape: Boolean,
  title: String,
  hideHeader: Boolean,
  hideTitle: Boolean,
  ...cd()
}, "VPicker"), ui = ne()({
  name: "VPicker",
  props: Qr(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      backgroundColorClasses: a,
      backgroundColorStyles: l
    } = Xe(() => e.color);
    return re(() => {
      const i = ro.filterProps(e), o = !e.hideTitle && !!(e.title || n.title);
      return b(ro, Q(i, {
        color: e.bgColor,
        class: ["v-picker", {
          "v-picker--divided": e.divided,
          "v-picker--landscape": e.landscape,
          "v-picker--with-actions": !!n.actions
        }, e.class],
        style: e.style
      }), {
        default: () => {
          var r;
          return [!e.hideHeader && S("div", {
            key: "header",
            class: le([a.value]),
            style: he([l.value])
          }, [o && b(rP, {
            key: "picker-title"
          }, {
            default: () => {
              var s;
              return [((s = n.title) == null ? void 0 : s.call(n)) ?? e.title];
            }
          }), n.header && S("div", {
            class: "v-picker__header"
          }, [n.header()])]), S("div", {
            class: "v-picker__body"
          }, [(r = n.default) == null ? void 0 : r.call(n)]), n.actions && b(Be, {
            defaults: {
              VBtn: {
                slim: !0,
                variant: "text"
              }
            }
          }, {
            default: () => [S("div", {
              class: "v-picker__actions"
            }, [n.actions()])]
          })];
        }
      });
    }), {};
  }
}), sP = z({
  canvasHeight: {
    type: [String, Number],
    default: 150
  },
  disabled: Boolean,
  dotSize: {
    type: [Number, String],
    default: 10
  },
  hideCanvas: Boolean,
  hideSliders: Boolean,
  hideInputs: Boolean,
  mode: {
    type: String,
    default: "rgba",
    validator: (e) => Object.keys(fl).includes(e)
  },
  modes: {
    type: Array,
    default: () => Object.keys(fl),
    validator: (e) => Array.isArray(e) && e.every((t) => Object.keys(fl).includes(t))
  },
  showSwatches: Boolean,
  swatches: Array,
  swatchesMaxHeight: {
    type: [Number, String],
    default: 150
  },
  modelValue: {
    type: [Object, String]
  },
  ...Qr({
    hideHeader: !0
  }),
  ...mn(gb(), ["hideEyeDropper", "eyeDropperIcon"])
}, "VColorPicker"), uP = Cn({
  name: "VColorPicker",
  props: sP(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:mode": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "mode"), l = Z(null), i = Ee(e, "modelValue", void 0, (u) => {
      if (u == null || u === "") return null;
      let c;
      try {
        c = po(pn(u));
      } catch (f) {
        return vn(f), null;
      }
      return c;
    }, (u) => u ? CE(u, e.modelValue) : null), o = x(() => i.value ? {
      ...i.value,
      h: l.value ?? i.value.h
    } : null), {
      rtlClasses: r
    } = Et();
    let s = !0;
    me(i, (u) => {
      if (!s) {
        s = !0;
        return;
      }
      u && (l.value = u.h);
    }, {
      immediate: !0
    });
    const d = (u) => {
      s = !1, l.value = u.h, i.value = u;
    };
    return fi(() => {
      e.modes.includes(a.value) || (a.value = e.modes[0]);
    }), gt({
      VSlider: {
        color: void 0,
        trackColor: void 0,
        trackFillColor: void 0
      }
    }), re(() => {
      const u = ui.filterProps(e);
      return b(ui, Q(u, {
        class: ["v-color-picker", r.value, e.class],
        style: [{
          "--v-color-picker-color-hsv": kg({
            ...o.value ?? Gl,
            a: 1
          })
        }, e.style]
      }), {
        ...n,
        default: () => S(ye, null, [!e.hideCanvas && b(xE, {
          key: "canvas",
          color: o.value,
          "onUpdate:color": d,
          disabled: e.disabled,
          dotSize: e.dotSize,
          width: e.width,
          height: e.canvasHeight
        }, null), (!e.hideSliders || !e.hideInputs) && S("div", {
          key: "controls",
          class: "v-color-picker__controls"
        }, [!e.hideSliders && b(BE, {
          key: "preview",
          color: o.value,
          "onUpdate:color": d,
          hideAlpha: !a.value.endsWith("a"),
          disabled: e.disabled,
          hideEyeDropper: e.hideEyeDropper,
          eyeDropperIcon: e.eyeDropperIcon
        }, null), !e.hideInputs && b(DE, {
          key: "edit",
          modes: e.modes,
          mode: a.value,
          "onUpdate:mode": (c) => a.value = c,
          color: o.value,
          "onUpdate:color": d,
          disabled: e.disabled
        }, null)]), e.showSwatches && b(oP, {
          key: "swatches",
          color: o.value,
          "onUpdate:color": d,
          maxHeight: e.swatchesMaxHeight,
          swatches: e.swatches,
          disabled: e.disabled
        }, null)])
      });
    }), {};
  }
}), cP = z({
  autoSelectFirst: {
    type: [Boolean, String]
  },
  clearOnSelect: {
    type: Boolean,
    default: !0
  },
  delimiters: Array,
  ...Si({
    filterKeys: ["title"]
  }),
  ...rd({
    hideNoData: !0,
    returnObject: !0
  }),
  ...tt(No({
    modelValue: null,
    role: "combobox"
  }), ["validationValue", "dirty", "appendInnerIcon"]),
  ...Wn({
    transition: !1
  })
}, "VCombobox"), dP = ne()({
  name: "VCombobox",
  props: cP(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:search": (e) => !0,
    "update:menu": (e) => !0
  },
  setup(e, t) {
    var O;
    let {
      emit: n,
      slots: a
    } = t;
    const {
      t: l
    } = nt(), i = Z(), o = fe(!1), r = fe(!0), s = fe(!1), d = Z(), u = Z(), c = fe(-1);
    let f = !1;
    const {
      items: v,
      transformIn: m,
      transformOut: h
    } = Zc(e), {
      textColorClasses: g,
      textColorStyles: p
    } = jt(() => {
      var $;
      return ($ = i.value) == null ? void 0 : $.color;
    }), y = Ee(e, "modelValue", [], ($) => m(ht($)), ($) => {
      const K = h($);
      return e.multiple ? K : K[0] ?? null;
    }), _ = yi(e), E = x(() => !!(e.chips || a.chip)), k = x(() => E.value || !!a.selection), P = fe(!e.multiple && !k.value ? ((O = y.value[0]) == null ? void 0 : O.title) ?? "" : ""), A = x({
      get: () => P.value,
      set: async ($) => {
        var K;
        if (P.value = $ ?? "", !e.multiple && !k.value && (y.value = [Tn(e, $)], He(() => {
          var X;
          return (X = u.value) == null ? void 0 : X.scrollToIndex(0);
        })), $ && e.multiple && ((K = e.delimiters) != null && K.length)) {
          const X = e.delimiters.map(yr).join("|"), te = $.split(new RegExp(`(?:${X})+`));
          if (te.length > 1) {
            for (let ue of te)
              ue = ue.trim(), ue && (de(Tn(e, ue)), await He());
            P.value = "";
          }
        }
        $ || (c.value = -1), r.value = !$;
      }
    }), D = x(() => typeof e.counterValue == "function" ? e.counterValue(y.value) : typeof e.counterValue == "number" ? e.counterValue : e.multiple ? y.value.length : A.value.length), {
      filteredItems: N,
      getMatches: V
    } = wi(e, v, () => r.value ? "" : A.value), I = x(() => e.hideSelected ? N.value.filter(($) => !y.value.some((K) => K.value === $.value)) : N.value), w = x(() => e.hideNoData && !I.value.length || _.isReadonly.value || _.isDisabled.value), T = Ee(e, "menu"), M = x({
      get: () => T.value,
      set: ($) => {
        var K;
        T.value && !$ && ((K = d.value) != null && K.openChildren.size) || $ && w.value || (T.value = $);
      }
    }), {
      menuId: W,
      ariaExpanded: J,
      ariaControls: ee,
      ariaLabel: Y
    } = od(e, M);
    me(P, ($) => {
      f ? He(() => f = !1) : o.value && !M.value && (M.value = !0), n("update:search", $);
    }), me(y, ($) => {
      var K;
      !e.multiple && !k.value && (P.value = ((K = $[0]) == null ? void 0 : K.title) ?? "");
    });
    const L = x(() => y.value.map(($) => $.value)), H = x(() => {
      var K;
      return (e.autoSelectFirst === !0 || e.autoSelectFirst === "exact" && A.value === ((K = I.value[0]) == null ? void 0 : K.title)) && I.value.length > 0 && !r.value && !s.value;
    }), j = Z(), U = id(j, i);
    function F($) {
      f = !0, e.openOnClear && (M.value = !0);
    }
    function oe() {
      w.value || (M.value = !0);
    }
    function ve($) {
      w.value || (o.value && ($.preventDefault(), $.stopPropagation()), M.value = !M.value);
    }
    function _e($) {
      var K;
      (ai($) || $.key === "Backspace") && ((K = i.value) == null || K.focus());
    }
    function B($) {
      var te, ue, se, ce;
      if (Vx($) || _.isReadonly.value) return;
      const K = (te = i.value) == null ? void 0 : te.selectionStart, X = y.value.length;
      if (["Enter", "ArrowDown", "ArrowUp"].includes($.key) && $.preventDefault(), ["Enter", "ArrowDown"].includes($.key) && (M.value = !0), ["Escape"].includes($.key) && (M.value = !1), ["Enter", "Escape", "Tab"].includes($.key) && (H.value && ["Enter", "Tab"].includes($.key) && !y.value.some((ae) => {
        let {
          value: Ie
        } = ae;
        return Ie === I.value[0].value;
      }) && de(N.value[0]), r.value = !0), $.key === "ArrowDown" && H.value && ((ue = j.value) == null || ue.focus("next")), $.key === "Enter" && A.value && (de(Tn(e, A.value)), k.value && (P.value = "")), ["Backspace", "Delete"].includes($.key)) {
        if (!e.multiple && k.value && y.value.length > 0 && !A.value) return de(y.value[0], !1);
        if (~c.value) {
          $.preventDefault();
          const ae = c.value;
          de(y.value[c.value], !1), c.value = ae >= X - 1 ? X - 2 : ae;
        } else $.key === "Backspace" && !A.value && (c.value = X - 1);
        return;
      }
      if (e.multiple)
        if ($.key === "ArrowLeft") {
          if (c.value < 0 && K && K > 0) return;
          const ae = c.value > -1 ? c.value - 1 : X - 1;
          y.value[ae] ? c.value = ae : (c.value = -1, (se = i.value) == null || se.setSelectionRange(A.value.length, A.value.length));
        } else if ($.key === "ArrowRight") {
          if (c.value < 0) return;
          const ae = c.value + 1;
          y.value[ae] ? c.value = ae : (c.value = -1, (ce = i.value) == null || ce.setSelectionRange(0, 0));
        } else ~c.value && ai($) && (c.value = -1);
    }
    function G() {
      var $;
      e.eager && (($ = u.value) == null || $.calculateVisibleItems());
    }
    function ie() {
      var $;
      o.value && (r.value = !0, ($ = i.value) == null || $.focus());
    }
    function de($) {
      let K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      if (!(!$ || $.props.disabled))
        if (e.multiple) {
          const X = y.value.findIndex((ue) => (e.valueComparator || Mt)(ue.value, $.value)), te = K ?? !~X;
          if (~X) {
            const ue = te ? [...y.value, $] : [...y.value];
            ue.splice(X, 1), y.value = ue;
          } else te && (y.value = [...y.value, $]);
          e.clearOnSelect && (A.value = "");
        } else {
          const X = K !== !1;
          y.value = X ? [$] : [], P.value = X && !k.value ? $.title : "", He(() => {
            M.value = !1, r.value = !0;
          });
        }
    }
    function Se($) {
      o.value = !0, setTimeout(() => {
        s.value = !0;
      });
    }
    function Ce($) {
      s.value = !1;
    }
    function C($) {
      ($ == null || $ === "" && !e.multiple && !k.value) && (y.value = []);
    }
    return me(o, ($, K) => {
      if (!($ || $ === K) && (c.value = -1, M.value = !1, A.value)) {
        if (e.multiple) {
          de(Tn(e, A.value));
          return;
        }
        if (!k.value) return;
        y.value.some((X) => {
          let {
            title: te
          } = X;
          return te === A.value;
        }) ? P.value = "" : de(Tn(e, A.value));
      }
    }), me(M, () => {
      if (!e.hideSelected && M.value && y.value.length) {
        const $ = I.value.findIndex((K) => y.value.some((X) => (e.valueComparator || Mt)(X.value, K.value)));
        qe && window.requestAnimationFrame(() => {
          var K;
          $ >= 0 && ((K = u.value) == null || K.scrollToIndex($));
        });
      }
    }), me(v, ($, K) => {
      M.value || o.value && !K.length && $.length && (M.value = !0);
    }), re(() => {
      const $ = !!(!e.hideNoData || I.value.length || a["prepend-item"] || a["append-item"] || a["no-data"]), K = y.value.length > 0, X = wa.filterProps(e);
      return b(wa, Q({
        ref: i
      }, X, {
        modelValue: A.value,
        "onUpdate:modelValue": [(te) => A.value = te, C],
        focused: o.value,
        "onUpdate:focused": (te) => o.value = te,
        validationValue: y.externalValue,
        counterValue: D.value,
        dirty: K,
        class: ["v-combobox", {
          "v-combobox--active-menu": M.value,
          "v-combobox--chips": !!e.chips,
          "v-combobox--selection-slot": !!k.value,
          "v-combobox--selecting-index": c.value > -1,
          [`v-combobox--${e.multiple ? "multiple" : "single"}`]: !0
        }, e.class],
        style: e.style,
        readonly: _.isReadonly.value,
        placeholder: K ? void 0 : e.placeholder,
        "onClick:clear": F,
        "onMousedown:control": oe,
        onKeydown: B,
        "aria-expanded": J.value,
        "aria-controls": ee.value
      }), {
        ...a,
        default: () => S(ye, null, [b(si, Q({
          id: W.value,
          ref: d,
          modelValue: M.value,
          "onUpdate:modelValue": (te) => M.value = te,
          activator: "parent",
          contentClass: "v-combobox__content",
          disabled: w.value,
          eager: e.eager,
          maxHeight: 310,
          openOnClick: !1,
          closeOnContentClick: !1,
          transition: e.transition,
          onAfterEnter: G,
          onAfterLeave: ie
        }, e.menuProps), {
          default: () => [$ && b(ri, Q({
            ref: j,
            filterable: !0,
            selected: L.value,
            selectStrategy: e.multiple ? "independent" : "single-independent",
            onMousedown: (te) => te.preventDefault(),
            selectable: !0,
            onKeydown: _e,
            onFocusin: Se,
            onFocusout: Ce,
            tabindex: "-1",
            "aria-live": "polite",
            color: e.itemColor ?? e.color
          }, U, e.listProps), {
            default: () => {
              var te, ue, se;
              return [(te = a["prepend-item"]) == null ? void 0 : te.call(a), !I.value.length && !e.hideNoData && (((ue = a["no-data"]) == null ? void 0 : ue.call(a)) ?? b(zn, {
                key: "no-data",
                title: l(e.noDataText)
              }, null)), b(Xr, {
                ref: u,
                renderless: !0,
                items: I.value,
                itemKey: "value"
              }, {
                default: (ce) => {
                  var $e, Fe, Je;
                  let {
                    item: ae,
                    index: Ie,
                    itemRef: we
                  } = ce;
                  const Ne = Q(ae.props, {
                    ref: we,
                    key: ae.value,
                    active: H.value && Ie === 0 ? !0 : void 0,
                    onClick: () => de(ae, null)
                  });
                  return ae.type === "divider" ? (($e = a.divider) == null ? void 0 : $e.call(a, {
                    props: ae.raw,
                    index: Ie
                  })) ?? b(Sn, Q(ae.props, {
                    key: `divider-${Ie}`
                  }), null) : ae.type === "subheader" ? ((Fe = a.subheader) == null ? void 0 : Fe.call(a, {
                    props: ae.raw,
                    index: Ie
                  })) ?? b(pi, Q(ae.props, {
                    key: `subheader-${Ie}`
                  }), null) : ((Je = a.item) == null ? void 0 : Je.call(a, {
                    item: ae,
                    index: Ie,
                    props: Ne
                  })) ?? b(zn, Q(Ne, {
                    role: "option"
                  }), {
                    prepend: (Ge) => {
                      let {
                        isSelected: qt
                      } = Ge;
                      return S(ye, null, [e.multiple && !e.hideSelected ? b(ia, {
                        key: ae.value,
                        modelValue: qt,
                        ripple: !1,
                        tabindex: "-1"
                      }, null) : void 0, ae.props.prependAvatar && b(kn, {
                        image: ae.props.prependAvatar
                      }, null), ae.props.prependIcon && b(Ue, {
                        icon: ae.props.prependIcon
                      }, null)]);
                    },
                    title: () => {
                      var Ge;
                      return r.value ? ae.title : Zy("v-combobox", ae.title, (Ge = V(ae)) == null ? void 0 : Ge.title);
                    }
                  });
                }
              }), (se = a["append-item"]) == null ? void 0 : se.call(a)];
            }
          })]
        }), y.value.map((te, ue) => {
          function se(we) {
            we.stopPropagation(), we.preventDefault(), de(te, !1);
          }
          const ce = {
            "onClick:close": se,
            onKeydown(we) {
              we.key !== "Enter" && we.key !== " " || (we.preventDefault(), we.stopPropagation(), se(we));
            },
            onMousedown(we) {
              we.preventDefault(), we.stopPropagation();
            },
            modelValue: !0,
            "onUpdate:modelValue": void 0
          }, ae = E.value ? !!a.chip : !!a.selection, Ie = ae ? Fr(E.value ? a.chip({
            item: te,
            index: ue,
            props: ce
          }) : a.selection({
            item: te,
            index: ue
          })) : void 0;
          if (!(ae && !Ie))
            return S("div", {
              key: te.value,
              class: le(["v-combobox__selection", ue === c.value && ["v-combobox__selection--selected", g.value]]),
              style: he(ue === c.value ? p.value : {})
            }, [E.value ? a.chip ? b(Be, {
              key: "chip-defaults",
              defaults: {
                VChip: {
                  closable: e.closableChips,
                  size: "small",
                  text: te.title
                }
              }
            }, {
              default: () => [Ie]
            }) : b(bi, Q({
              key: "chip",
              closable: e.closableChips,
              size: "small",
              text: te.title,
              disabled: te.props.disabled
            }, ce), null) : Ie ?? S("span", {
              class: "v-combobox__selection-text"
            }, [te.title, e.multiple && ue < y.value.length - 1 && S("span", {
              class: "v-combobox__selection-comma"
            }, [ze(",")])])]);
        })]),
        "append-inner": function() {
          var ce, ae;
          for (var te = arguments.length, ue = new Array(te), se = 0; se < te; se++)
            ue[se] = arguments[se];
          return S(ye, null, [(ce = a["append-inner"]) == null ? void 0 : ce.call(a, ...ue), (!e.hideNoData || e.items.length) && e.menuIcon ? b(Ue, {
            class: "v-combobox__menu-icon",
            color: (ae = i.value) == null ? void 0 : ae.fieldIconColor,
            icon: e.menuIcon,
            onMousedown: ve,
            onClick: gg,
            "aria-label": Y.value,
            title: Y.value,
            tabindex: "-1"
          }, null) : void 0]);
        }
      });
    }), Lt({
      isFocused: o,
      isPristine: r,
      menu: M,
      search: A,
      selectionIndex: c,
      filteredItems: N,
      select: de
    }, i);
  }
}), fP = z({
  modelValue: null,
  color: String,
  cancelText: {
    type: String,
    default: "$vuetify.confirmEdit.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.confirmEdit.ok"
  },
  disabled: {
    type: [Boolean, Array],
    default: void 0
  },
  hideActions: Boolean
}, "VConfirmEdit"), vP = ne()({
  name: "VConfirmEdit",
  props: fP(),
  emits: {
    cancel: () => !0,
    save: (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const l = Ee(e, "modelValue"), i = Z();
    ut(() => {
      i.value = structuredClone(Pe(l.value));
    });
    const {
      t: o
    } = nt(), r = x(() => Mt(l.value, i.value));
    function s(h) {
      return typeof e.disabled == "boolean" ? e.disabled : Array.isArray(e.disabled) ? e.disabled.includes(h) : r.value;
    }
    const d = x(() => s("save")), u = x(() => s("cancel"));
    function c() {
      l.value = i.value, n("save", i.value);
    }
    function f() {
      i.value = structuredClone(Pe(l.value)), n("cancel");
    }
    function v(h) {
      return S(ye, null, [b(Le, Q({
        disabled: u.value,
        variant: "text",
        color: e.color,
        onClick: f,
        text: o(e.cancelText)
      }, h), null), b(Le, Q({
        disabled: d.value,
        variant: "text",
        color: e.color,
        onClick: c,
        text: o(e.okText)
      }, h), null)]);
    }
    let m = !1;
    return re(() => {
      var h;
      return S(ye, null, [(h = a.default) == null ? void 0 : h.call(a, {
        model: i,
        save: c,
        cancel: f,
        isPristine: r.value,
        get actions() {
          return m = !0, v;
        }
      }), !e.hideActions && !m && v()]);
    }), {
      save: c,
      cancel: f,
      isPristine: r
    };
  }
}), yb = z({
  expandOnClick: Boolean,
  showExpand: Boolean,
  expanded: {
    type: Array,
    default: () => []
  }
}, "DataTable-expand"), bb = Symbol.for("vuetify:datatable:expanded");
function es(e) {
  const t = R(() => e.expandOnClick), n = Ee(e, "expanded", e.expanded, (r) => new Set(r), (r) => [...r.values()]);
  function a(r, s) {
    const d = new Set(n.value), u = Pe(r.value);
    if (s)
      d.add(u);
    else {
      const c = [...n.value].find((f) => Pe(f) === u);
      d.delete(c);
    }
    n.value = d;
  }
  function l(r) {
    const s = Pe(r.value);
    return [...n.value].some((d) => Pe(d) === s);
  }
  function i(r) {
    a(r, !l(r));
  }
  const o = {
    expand: a,
    expanded: n,
    expandOnClick: t,
    isExpanded: l,
    toggleExpand: i
  };
  return at(bb, o), o;
}
function pb() {
  const e = Me(bb);
  if (!e) throw new Error("foo");
  return e;
}
const dd = z({
  groupBy: {
    type: Array,
    default: () => []
  }
}, "DataTable-group"), Sb = Symbol.for("vuetify:data-table-group");
function fd(e) {
  return {
    groupBy: Ee(e, "groupBy")
  };
}
function ts(e) {
  const {
    disableSort: t,
    groupBy: n,
    sortBy: a
  } = e, l = Z(/* @__PURE__ */ new Set()), i = x(() => n.value.map((u) => ({
    ...u,
    order: u.order ?? !1
  })).concat(t != null && t.value ? [] : a.value));
  function o(u) {
    return l.value.has(u.id);
  }
  function r(u) {
    const c = new Set(l.value);
    o(u) ? c.delete(u.id) : c.add(u.id), l.value = c;
  }
  function s(u) {
    function c(f) {
      const v = [];
      for (const m of f.items)
        "type" in m && m.type === "group" ? v.push(...c(m)) : v.push(m);
      return [...new Set(v)];
    }
    return c({
      items: u
    });
  }
  const d = {
    sortByWithGroups: i,
    toggleGroup: r,
    opened: l,
    groupBy: n,
    extractRows: s,
    isGroupOpen: o
  };
  return at(Sb, d), d;
}
function wb() {
  const e = Me(Sb);
  if (!e) throw new Error("Missing group!");
  return e;
}
function mP(e, t) {
  if (!e.length) return [];
  const n = /* @__PURE__ */ new Map();
  for (const a of e) {
    const l = gl(a.raw, t);
    n.has(l) || n.set(l, []), n.get(l).push(a);
  }
  return n;
}
function _b(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "root";
  if (!t.length) return [];
  const l = mP(e, t[0]), i = [], o = t.slice(1);
  return l.forEach((r, s) => {
    const d = t[0], u = `${a}_${d}_${s}`;
    i.push({
      depth: n,
      id: u,
      key: d,
      value: s,
      items: o.length ? _b(r, o, n + 1, u) : r,
      type: "group"
    });
  }), i;
}
function xb(e, t, n) {
  const a = [];
  for (const l of e)
    "type" in l && l.type === "group" ? (l.value != null && a.push(l), (t.has(l.id) || l.value == null) && (a.push(...xb(l.items, t, n)), n && a.push({
      ...l,
      type: "group-summary"
    }))) : a.push(l);
  return a;
}
function ns(e, t, n, a) {
  return {
    flatItems: x(() => {
      if (!t.value.length) return e.value;
      const i = _b(e.value, t.value.map((o) => o.key));
      return xb(i, n.value, un(a));
    })
  };
}
function as(e) {
  let {
    page: t,
    itemsPerPage: n,
    sortBy: a,
    groupBy: l,
    search: i
  } = e;
  const o = St("VDataTable"), r = () => ({
    page: t.value,
    itemsPerPage: n.value,
    sortBy: a.value,
    groupBy: l.value,
    search: i.value
  });
  let s = null;
  me(r, (d) => {
    Mt(s, d) || (s && s.search !== d.search && (t.value = 1), o.emit("update:options", d), s = d);
  }, {
    deep: !0,
    immediate: !0
  });
}
const vd = z({
  page: {
    type: [Number, String],
    default: 1
  },
  itemsPerPage: {
    type: [Number, String],
    default: 10
  }
}, "DataTable-paginate"), kb = Symbol.for("vuetify:data-table-pagination");
function md(e) {
  const t = Ee(e, "page", void 0, (a) => Number(a ?? 1)), n = Ee(e, "itemsPerPage", void 0, (a) => Number(a ?? 10));
  return {
    page: t,
    itemsPerPage: n
  };
}
function hd(e) {
  const {
    page: t,
    itemsPerPage: n,
    itemsLength: a
  } = e, l = x(() => n.value === -1 ? 0 : n.value * (t.value - 1)), i = x(() => n.value === -1 ? a.value : Math.min(a.value, l.value + n.value)), o = x(() => n.value === -1 || a.value === 0 ? 1 : Math.ceil(a.value / n.value));
  me([t, o], () => {
    t.value > o.value && (t.value = o.value);
  });
  function r(f) {
    n.value = f, t.value = 1;
  }
  function s() {
    t.value = ot(t.value + 1, 1, o.value);
  }
  function d() {
    t.value = ot(t.value - 1, 1, o.value);
  }
  function u(f) {
    t.value = ot(f, 1, o.value);
  }
  const c = {
    page: t,
    itemsPerPage: n,
    startIndex: l,
    stopIndex: i,
    pageCount: o,
    itemsLength: a,
    nextPage: s,
    prevPage: d,
    setPage: u,
    setItemsPerPage: r
  };
  return at(kb, c), c;
}
function hP() {
  const e = Me(kb);
  if (!e) throw new Error("Missing pagination!");
  return e;
}
function Cb(e) {
  const t = St("usePaginatedItems"), {
    items: n,
    startIndex: a,
    stopIndex: l,
    itemsPerPage: i
  } = e, o = x(() => i.value <= 0 ? n.value : n.value.slice(a.value, l.value));
  return me(o, (r) => {
    t.emit("update:currentItems", r);
  }, {
    immediate: !0
  }), {
    paginatedItems: o
  };
}
const gP = {
  showSelectAll: !1,
  allSelected: () => [],
  select: (e) => {
    var a;
    let {
      items: t,
      value: n
    } = e;
    return new Set(n ? [(a = t[0]) == null ? void 0 : a.value] : []);
  },
  selectAll: (e) => {
    let {
      selected: t
    } = e;
    return t;
  }
}, Vb = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      currentPage: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: a
    } = e;
    for (const l of t)
      n ? a.add(l.value) : a.delete(l.value);
    return a;
  },
  selectAll: (e) => {
    let {
      value: t,
      currentPage: n,
      selected: a
    } = e;
    return Vb.select({
      items: n,
      value: t,
      selected: a
    });
  }
}, Eb = {
  showSelectAll: !0,
  allSelected: (e) => {
    let {
      allItems: t
    } = e;
    return t;
  },
  select: (e) => {
    let {
      items: t,
      value: n,
      selected: a
    } = e;
    for (const l of t)
      n ? a.add(l.value) : a.delete(l.value);
    return a;
  },
  selectAll: (e) => {
    let {
      value: t,
      allItems: n,
      selected: a
    } = e;
    return Eb.select({
      items: n,
      value: t,
      selected: a
    });
  }
}, Pb = z({
  showSelect: Boolean,
  selectStrategy: {
    type: [String, Object],
    default: "page"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  valueComparator: {
    type: Function,
    default: Mt
  }
}, "DataTable-select"), Ib = Symbol.for("vuetify:data-table-selection");
function ls(e, t) {
  let {
    allItems: n,
    currentPage: a
  } = t;
  const l = Ee(e, "modelValue", e.modelValue, (y) => new Set(ht(y).map((_) => {
    var E;
    return ((E = n.value.find((k) => e.valueComparator(_, k.value))) == null ? void 0 : E.value) ?? _;
  })), (y) => [...y.values()]), i = x(() => n.value.filter((y) => y.selectable)), o = x(() => a.value.filter((y) => y.selectable)), r = x(() => {
    if (typeof e.selectStrategy == "object") return e.selectStrategy;
    switch (e.selectStrategy) {
      case "single":
        return gP;
      case "all":
        return Eb;
      case "page":
      default:
        return Vb;
    }
  }), s = fe(null);
  function d(y) {
    return ht(y).every((_) => l.value.has(_.value));
  }
  function u(y) {
    return ht(y).some((_) => l.value.has(_.value));
  }
  function c(y, _) {
    const E = r.value.select({
      items: y,
      value: _,
      selected: new Set(l.value)
    });
    l.value = E;
  }
  function f(y, _, E) {
    const k = [];
    if (_ = _ ?? a.value.findIndex((P) => P.value === y.value), e.selectStrategy !== "single" && (E != null && E.shiftKey) && s.value !== null) {
      const [P, A] = [s.value, _].sort((D, N) => D - N);
      k.push(...a.value.slice(P, A + 1).filter((D) => D.selectable));
    } else
      k.push(y), s.value = _;
    c(k, !d([y]));
  }
  function v(y) {
    const _ = r.value.selectAll({
      value: y,
      allItems: i.value,
      currentPage: o.value,
      selected: new Set(l.value)
    });
    l.value = _;
  }
  const m = x(() => l.value.size > 0), h = x(() => {
    const y = r.value.allSelected({
      allItems: i.value,
      currentPage: o.value
    });
    return !!y.length && d(y);
  }), g = R(() => r.value.showSelectAll), p = {
    toggleSelect: f,
    select: c,
    selectAll: v,
    isSelected: d,
    isSomeSelected: u,
    someSelected: m,
    allSelected: h,
    showSelectAll: g,
    lastSelectedIndex: s,
    selectStrategy: r
  };
  return at(Ib, p), p;
}
function is() {
  const e = Me(Ib);
  if (!e) throw new Error("Missing selection!");
  return e;
}
const Nb = z({
  sortBy: {
    type: Array,
    default: () => []
  },
  customKeySort: Object,
  multiSort: Boolean,
  mustSort: Boolean
}, "DataTable-sort"), Db = Symbol.for("vuetify:data-table-sort");
function os(e) {
  const t = Ee(e, "sortBy"), n = R(() => e.mustSort), a = R(() => e.multiSort);
  return {
    sortBy: t,
    mustSort: n,
    multiSort: a
  };
}
function rs(e) {
  const {
    sortBy: t,
    mustSort: n,
    multiSort: a,
    page: l
  } = e, i = (s) => {
    if (s.key == null) return;
    let d = t.value.map((c) => ({
      ...c
    })) ?? [];
    const u = d.find((c) => c.key === s.key);
    u ? u.order === "desc" ? n.value && d.length === 1 ? u.order = "asc" : d = d.filter((c) => c.key !== s.key) : u.order = "desc" : a.value ? d.push({
      key: s.key,
      order: "asc"
    }) : d = [{
      key: s.key,
      order: "asc"
    }], t.value = d, l && (l.value = 1);
  };
  function o(s) {
    return !!t.value.find((d) => d.key === s.key);
  }
  const r = {
    sortBy: t,
    toggleSort: i,
    isSorted: o
  };
  return at(Db, r), r;
}
function Ab() {
  const e = Me(Db);
  if (!e) throw new Error("Missing sort!");
  return e;
}
function gd(e, t, n, a) {
  const l = nt();
  return {
    sortedItems: x(() => {
      var o, r;
      return n.value.length ? yP(t.value, n.value, l.current.value, {
        transform: a == null ? void 0 : a.transform,
        sortFunctions: {
          ...e.customKeySort,
          ...(o = a == null ? void 0 : a.sortFunctions) == null ? void 0 : o.value
        },
        sortRawFunctions: (r = a == null ? void 0 : a.sortRawFunctions) == null ? void 0 : r.value
      }) : t.value;
    })
  };
}
function yP(e, t, n, a) {
  const l = new Intl.Collator(n, {
    sensitivity: "accent",
    usage: "sort"
  });
  return e.map((o) => [o, a != null && a.transform ? a.transform(o) : o]).sort((o, r) => {
    var s, d;
    for (let u = 0; u < t.length; u++) {
      let c = !1;
      const f = t[u].key, v = t[u].order ?? "asc";
      if (v === !1) continue;
      let m = gl(o[1], f), h = gl(r[1], f), g = o[0].raw, p = r[0].raw;
      if (v === "desc" && ([m, h] = [h, m], [g, p] = [p, g]), (s = a == null ? void 0 : a.sortRawFunctions) != null && s[f]) {
        const y = a.sortRawFunctions[f](g, p);
        if (y == null) continue;
        if (c = !0, y) return y;
      }
      if ((d = a == null ? void 0 : a.sortFunctions) != null && d[f]) {
        const y = a.sortFunctions[f](m, h);
        if (y == null) continue;
        if (c = !0, y) return y;
      }
      if (!c && (m instanceof Date && h instanceof Date && (m = m.getTime(), h = h.getTime()), [m, h] = [m, h].map((y) => y != null ? y.toString().toLocaleLowerCase() : y), m !== h))
        return Mo(m) && Mo(h) ? 0 : Mo(m) ? -1 : Mo(h) ? 1 : !isNaN(m) && !isNaN(h) ? Number(m) - Number(h) : l.compare(m, h);
    }
    return 0;
  }).map((o) => {
    let [r] = o;
    return r;
  });
}
const bP = z({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  returnObject: Boolean
}, "DataIterator-items");
function pP(e, t) {
  const n = e.returnObject ? t : xt(t, e.itemValue), a = xt(t, e.itemSelectable, !0);
  return {
    type: "item",
    value: n,
    selectable: a,
    raw: t
  };
}
function SP(e, t) {
  const n = [];
  for (const a of t)
    n.push(pP(e, a));
  return n;
}
function wP(e) {
  return {
    items: x(() => SP(e, e.items))
  };
}
const _P = z({
  search: String,
  loading: Boolean,
  ...ke(),
  ...bP(),
  ...Pb(),
  ...Nb(),
  ...vd({
    itemsPerPage: 5
  }),
  ...yb(),
  ...dd(),
  ...Si(),
  ...Oe(),
  ...Wn({
    transition: {
      component: eo,
      hideOnLeave: !0
    }
  })
}, "VDataIterator"), xP = ne()({
  name: "VDataIterator",
  props: _P(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "groupBy"), l = R(() => e.search), {
      items: i
    } = wP(e), {
      filteredItems: o
    } = wi(e, i, l, {
      transform: (j) => j.raw
    }), {
      sortBy: r,
      multiSort: s,
      mustSort: d
    } = os(e), {
      page: u,
      itemsPerPage: c
    } = md(e), {
      toggleSort: f
    } = rs({
      sortBy: r,
      multiSort: s,
      mustSort: d,
      page: u
    }), {
      sortByWithGroups: v,
      opened: m,
      extractRows: h,
      isGroupOpen: g,
      toggleGroup: p
    } = ts({
      groupBy: a,
      sortBy: r
    }), {
      sortedItems: y
    } = gd(e, o, v, {
      transform: (j) => j.raw
    }), {
      flatItems: _
    } = ns(y, a, m, !1), E = R(() => _.value.length), {
      startIndex: k,
      stopIndex: P,
      pageCount: A,
      prevPage: D,
      nextPage: N,
      setItemsPerPage: V,
      setPage: I
    } = hd({
      page: u,
      itemsPerPage: c,
      itemsLength: E
    }), {
      paginatedItems: w
    } = Cb({
      items: _,
      startIndex: k,
      stopIndex: P,
      itemsPerPage: c
    }), T = x(() => h(w.value)), {
      isSelected: M,
      select: W,
      selectAll: J,
      toggleSelect: ee
    } = ls(e, {
      allItems: i,
      currentPage: T
    }), {
      isExpanded: Y,
      toggleExpand: L
    } = es(e);
    as({
      page: u,
      itemsPerPage: c,
      sortBy: r,
      groupBy: a,
      search: l
    });
    const H = x(() => ({
      page: u.value,
      itemsPerPage: c.value,
      sortBy: r.value,
      pageCount: A.value,
      toggleSort: f,
      prevPage: D,
      nextPage: N,
      setPage: I,
      setItemsPerPage: V,
      isSelected: M,
      select: W,
      selectAll: J,
      toggleSelect: ee,
      isExpanded: Y,
      toggleExpand: L,
      isGroupOpen: g,
      toggleGroup: p,
      items: T.value,
      itemsCount: o.value.length,
      groupedItems: w.value
    }));
    return re(() => b(e.tag, {
      class: le(["v-data-iterator", {
        "v-data-iterator--loading": e.loading
      }, e.class]),
      style: he(e.style)
    }, {
      default: () => {
        var j, U;
        return [(j = n.header) == null ? void 0 : j.call(n, H.value), b(Zt, {
          transition: e.transition
        }, {
          default: () => {
            var F, oe;
            return [e.loading ? b(ko, {
              key: "loader",
              name: "v-data-iterator",
              active: !0
            }, {
              default: (ve) => {
                var _e;
                return (_e = n.loader) == null ? void 0 : _e.call(n, ve);
              }
            }) : S("div", {
              key: "items"
            }, [w.value.length ? (oe = n.default) == null ? void 0 : oe.call(n, H.value) : (F = n["no-data"]) == null ? void 0 : F.call(n)])];
          }
        }), (U = n.footer) == null ? void 0 : U.call(n, H.value)];
      }
    })), {};
  }
});
function kP() {
  const e = Z([]);
  th(() => e.value = []);
  function t(n, a) {
    e.value[a] = n;
  }
  return {
    refs: e,
    updateRef: t
  };
}
const CP = z({
  activeColor: String,
  start: {
    type: [Number, String],
    default: 1
  },
  modelValue: {
    type: Number,
    default: (e) => e.start
  },
  disabled: Boolean,
  length: {
    type: [Number, String],
    default: 1,
    validator: (e) => e % 1 === 0
  },
  totalVisible: [Number, String],
  firstIcon: {
    type: Ve,
    default: "$first"
  },
  prevIcon: {
    type: Ve,
    default: "$prev"
  },
  nextIcon: {
    type: Ve,
    default: "$next"
  },
  lastIcon: {
    type: Ve,
    default: "$last"
  },
  ariaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.root"
  },
  pageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.page"
  },
  currentPageAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.currentPage"
  },
  firstAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.first"
  },
  previousAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.previous"
  },
  nextAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.next"
  },
  lastAriaLabel: {
    type: String,
    default: "$vuetify.pagination.ariaLabel.last"
  },
  ellipsis: {
    type: String,
    default: "..."
  },
  showFirstLastPage: Boolean,
  ...cn(),
  ...ke(),
  ...Tt(),
  ...Pt(),
  ...ft(),
  ...sa(),
  ...Oe({
    tag: "nav"
  }),
  ...We(),
  ...Dn({
    variant: "text"
  })
}, "VPagination"), Fu = ne()({
  name: "VPagination",
  props: CP(),
  emits: {
    "update:modelValue": (e) => !0,
    first: (e) => !0,
    prev: (e) => !0,
    next: (e) => !0,
    last: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const l = Ee(e, "modelValue"), {
      t: i,
      n: o
    } = nt(), {
      isRtl: r
    } = Et(), {
      themeClasses: s
    } = Ye(e), {
      width: d
    } = Vn(), u = fe(-1);
    gt(void 0, {
      scoped: !0
    });
    const {
      resizeRef: c
    } = In((D) => {
      if (!D.length) return;
      const {
        target: N,
        contentRect: V
      } = D[0], I = N.querySelector(".v-pagination__list > *");
      if (!I) return;
      const w = V.width, T = I.offsetWidth + parseFloat(getComputedStyle(I).marginRight) * 2;
      u.value = h(w, T);
    }), f = x(() => parseInt(e.length, 10)), v = x(() => parseInt(e.start, 10)), m = x(() => e.totalVisible != null ? parseInt(e.totalVisible, 10) : u.value >= 0 ? u.value : h(d.value, 58));
    function h(D, N) {
      const V = e.showFirstLastPage ? 5 : 3;
      return Math.max(0, Math.floor(
        // Round to two decimal places to avoid floating point errors
        Number(((D - N * V) / N).toFixed(2))
      ));
    }
    const g = x(() => {
      if (f.value <= 0 || isNaN(f.value) || f.value > Number.MAX_SAFE_INTEGER) return [];
      if (m.value <= 0) return [];
      if (m.value === 1) return [l.value];
      if (f.value <= m.value)
        return bn(f.value, v.value);
      const D = m.value % 2 === 0, N = D ? m.value / 2 : Math.floor(m.value / 2), V = D ? N : N + 1, I = f.value - N;
      if (V - l.value >= 0)
        return [...bn(Math.max(1, m.value - 1), v.value), e.ellipsis, f.value];
      if (l.value - I >= (D ? 1 : 0)) {
        const w = m.value - 1, T = f.value - w + v.value;
        return [v.value, e.ellipsis, ...bn(w, T)];
      } else {
        const w = Math.max(1, m.value - 2), T = w === 1 ? l.value : l.value - Math.ceil(w / 2) + v.value;
        return [v.value, e.ellipsis, ...bn(w, T), e.ellipsis, f.value];
      }
    });
    function p(D, N, V) {
      D.preventDefault(), l.value = N, V && a(V, N);
    }
    const {
      refs: y,
      updateRef: _
    } = kP();
    gt({
      VPaginationBtn: {
        color: R(() => e.color),
        border: R(() => e.border),
        density: R(() => e.density),
        size: R(() => e.size),
        variant: R(() => e.variant),
        rounded: R(() => e.rounded),
        elevation: R(() => e.elevation)
      }
    });
    const E = x(() => g.value.map((D, N) => {
      const V = (I) => _(I, N);
      if (typeof D == "string")
        return {
          isActive: !1,
          key: `ellipsis-${N}`,
          page: D,
          props: {
            ref: V,
            ellipsis: !0,
            icon: !0,
            disabled: !0
          }
        };
      {
        const I = D === l.value;
        return {
          isActive: I,
          key: D,
          page: o(D),
          props: {
            ref: V,
            ellipsis: !1,
            icon: !0,
            disabled: !!e.disabled || Number(e.length) < 2,
            color: I ? e.activeColor : e.color,
            "aria-current": I,
            "aria-label": i(I ? e.currentPageAriaLabel : e.pageAriaLabel, D),
            onClick: (w) => p(w, D)
          }
        };
      }
    })), k = x(() => {
      const D = !!e.disabled || l.value <= v.value, N = !!e.disabled || l.value >= v.value + f.value - 1;
      return {
        first: e.showFirstLastPage ? {
          icon: r.value ? e.lastIcon : e.firstIcon,
          onClick: (V) => p(V, v.value, "first"),
          disabled: D,
          "aria-label": i(e.firstAriaLabel),
          "aria-disabled": D
        } : void 0,
        prev: {
          icon: r.value ? e.nextIcon : e.prevIcon,
          onClick: (V) => p(V, l.value - 1, "prev"),
          disabled: D,
          "aria-label": i(e.previousAriaLabel),
          "aria-disabled": D
        },
        next: {
          icon: r.value ? e.prevIcon : e.nextIcon,
          onClick: (V) => p(V, l.value + 1, "next"),
          disabled: N,
          "aria-label": i(e.nextAriaLabel),
          "aria-disabled": N
        },
        last: e.showFirstLastPage ? {
          icon: r.value ? e.firstIcon : e.lastIcon,
          onClick: (V) => p(V, v.value + f.value - 1, "last"),
          disabled: N,
          "aria-label": i(e.lastAriaLabel),
          "aria-disabled": N
        } : void 0
      };
    });
    function P() {
      var N;
      const D = l.value - v.value;
      (N = y.value[D]) == null || N.$el.focus();
    }
    function A(D) {
      D.key === vu.left && !e.disabled && l.value > Number(e.start) ? (l.value = l.value - 1, He(P)) : D.key === vu.right && !e.disabled && l.value < v.value + f.value - 1 && (l.value = l.value + 1, He(P));
    }
    return re(() => b(e.tag, {
      ref: c,
      class: le(["v-pagination", s.value, e.class]),
      style: he(e.style),
      role: "navigation",
      "aria-label": i(e.ariaLabel),
      onKeydown: A,
      "data-test": "v-pagination-root"
    }, {
      default: () => [S("ul", {
        class: "v-pagination__list"
      }, [e.showFirstLastPage && S("li", {
        key: "first",
        class: "v-pagination__first",
        "data-test": "v-pagination-first"
      }, [n.first ? n.first(k.value.first) : b(Le, Q({
        _as: "VPaginationBtn"
      }, k.value.first), null)]), S("li", {
        key: "prev",
        class: "v-pagination__prev",
        "data-test": "v-pagination-prev"
      }, [n.prev ? n.prev(k.value.prev) : b(Le, Q({
        _as: "VPaginationBtn"
      }, k.value.prev), null)]), E.value.map((D, N) => S("li", {
        key: D.key,
        class: le(["v-pagination__item", {
          "v-pagination__item--is-active": D.isActive
        }]),
        "data-test": "v-pagination-item"
      }, [n.item ? n.item(D) : b(Le, Q({
        _as: "VPaginationBtn"
      }, D.props), {
        default: () => [D.page]
      })])), S("li", {
        key: "next",
        class: "v-pagination__next",
        "data-test": "v-pagination-next"
      }, [n.next ? n.next(k.value.next) : b(Le, Q({
        _as: "VPaginationBtn"
      }, k.value.next), null)]), e.showFirstLastPage && S("li", {
        key: "last",
        class: "v-pagination__last",
        "data-test": "v-pagination-last"
      }, [n.last ? n.last(k.value.last) : b(Le, Q({
        _as: "VPaginationBtn"
      }, k.value.last), null)])])]
    })), {};
  }
}), yd = z({
  prevIcon: {
    type: Ve,
    default: "$prev"
  },
  nextIcon: {
    type: Ve,
    default: "$next"
  },
  firstIcon: {
    type: Ve,
    default: "$first"
  },
  lastIcon: {
    type: Ve,
    default: "$last"
  },
  itemsPerPageText: {
    type: String,
    default: "$vuetify.dataFooter.itemsPerPageText"
  },
  pageText: {
    type: String,
    default: "$vuetify.dataFooter.pageText"
  },
  firstPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.firstPage"
  },
  prevPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.prevPage"
  },
  nextPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.nextPage"
  },
  lastPageLabel: {
    type: String,
    default: "$vuetify.dataFooter.lastPage"
  },
  itemsPerPageOptions: {
    type: Array,
    default: () => [{
      value: 10,
      title: "10"
    }, {
      value: 25,
      title: "25"
    }, {
      value: 50,
      title: "50"
    }, {
      value: 100,
      title: "100"
    }, {
      value: -1,
      title: "$vuetify.dataFooter.itemsPerPageAll"
    }]
  },
  showCurrentPage: Boolean
}, "VDataTableFooter"), so = ne()({
  name: "VDataTableFooter",
  props: yd(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = nt(), {
      page: l,
      pageCount: i,
      startIndex: o,
      stopIndex: r,
      itemsLength: s,
      itemsPerPage: d,
      setItemsPerPage: u
    } = hP(), c = x(() => e.itemsPerPageOptions.map((f) => typeof f == "number" ? {
      value: f,
      title: f === -1 ? a("$vuetify.dataFooter.itemsPerPageAll") : String(f)
    } : {
      ...f,
      title: isNaN(Number(f.title)) ? a(f.title) : f.title
    }));
    return re(() => {
      var v;
      const f = Fu.filterProps(e);
      return S("div", {
        class: "v-data-table-footer"
      }, [(v = n.prepend) == null ? void 0 : v.call(n), S("div", {
        class: "v-data-table-footer__items-per-page"
      }, [S("span", {
        "aria-label": a(e.itemsPerPageText)
      }, [a(e.itemsPerPageText)]), b(sd, {
        items: c.value,
        modelValue: d.value,
        "onUpdate:modelValue": (m) => u(Number(m)),
        density: "compact",
        variant: "outlined",
        hideDetails: !0
      }, null)]), S("div", {
        class: "v-data-table-footer__info"
      }, [S("div", null, [a(e.pageText, s.value ? o.value + 1 : 0, r.value, s.value)])]), S("div", {
        class: "v-data-table-footer__pagination"
      }, [b(Fu, Q({
        modelValue: l.value,
        "onUpdate:modelValue": (m) => l.value = m,
        density: "comfortable",
        firstAriaLabel: e.firstPageLabel,
        lastAriaLabel: e.lastPageLabel,
        length: i.value,
        nextAriaLabel: e.nextPageLabel,
        previousAriaLabel: e.prevPageLabel,
        rounded: !0,
        showFirstLastPage: !0,
        totalVisible: e.showCurrentPage ? 1 : 0,
        variant: "plain"
      }, f), null)])]);
    }), {};
  }
}), uo = sk({
  align: {
    type: String,
    default: "start"
  },
  fixed: {
    type: [Boolean, String],
    default: !1
  },
  fixedOffset: [Number, String],
  fixedEndOffset: [Number, String],
  height: [Number, String],
  lastFixed: Boolean,
  firstFixedEnd: Boolean,
  noPadding: Boolean,
  indent: [Number, String],
  empty: Boolean,
  tag: String,
  width: [Number, String],
  maxWidth: [Number, String],
  nowrap: Boolean
}, (e, t) => {
  let {
    slots: n
  } = t;
  const a = e.tag ?? "td", l = typeof e.fixed == "string" ? e.fixed : e.fixed ? "start" : "none";
  return b(a, {
    class: le(["v-data-table__td", {
      "v-data-table-column--fixed": l === "start",
      "v-data-table-column--fixed-end": l === "end",
      "v-data-table-column--last-fixed": e.lastFixed,
      "v-data-table-column--first-fixed-end": e.firstFixedEnd,
      "v-data-table-column--no-padding": e.noPadding,
      "v-data-table-column--nowrap": e.nowrap,
      "v-data-table-column--empty": e.empty
    }, `v-data-table-column--align-${e.align}`]),
    style: {
      height: pe(e.height),
      width: pe(e.width),
      maxWidth: pe(e.maxWidth),
      left: l === "start" ? pe(e.fixedOffset || null) : void 0,
      right: l === "end" ? pe(e.fixedEndOffset || null) : void 0,
      paddingInlineStart: e.indent ? pe(e.indent) : void 0
    }
  }, {
    default: () => {
      var i;
      return [(i = n.default) == null ? void 0 : i.call(n)];
    }
  });
}), VP = z({
  headers: Array
}, "DataTable-header"), Tb = Symbol.for("vuetify:data-table-headers"), Ob = {
  title: "",
  sortable: !1
}, EP = {
  ...Ob,
  width: 48
};
function PP() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).map((n) => ({
    element: n,
    priority: 0
  }));
  return {
    enqueue: (n, a) => {
      let l = !1;
      for (let i = 0; i < t.length; i++)
        if (t[i].priority > a) {
          t.splice(i, 0, {
            element: n,
            priority: a
          }), l = !0;
          break;
        }
      l || t.push({
        element: n,
        priority: a
      });
    },
    size: () => t.length,
    count: () => {
      let n = 0;
      if (!t.length) return 0;
      const a = Math.floor(t[0].priority);
      for (let l = 0; l < t.length; l++)
        Math.floor(t[l].priority) === a && (n += 1);
      return n;
    },
    dequeue: () => t.shift()
  };
}
function Hu(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  if (!e.children)
    t.push(e);
  else
    for (const n of e.children)
      Hu(n, t);
  return t;
}
function $b(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
  for (const n of e)
    n.key && t.add(n.key), n.children && $b(n.children, t);
  return t;
}
function IP(e) {
  if (e.key) {
    if (e.key === "data-table-group") return Ob;
    if (["data-table-expand", "data-table-select"].includes(e.key)) return EP;
  }
}
function bd(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return e.children ? Math.max(t, ...e.children.map((n) => bd(n, t + 1))) : t;
}
function NP(e) {
  let t = !1;
  function n(i, o) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "none";
    if (i)
      if (r !== "none" && (i.fixed = r), i.fixed === !0 && (i.fixed = "start"), i.fixed === o)
        if (i.children)
          if (o === "start")
            for (let s = i.children.length - 1; s >= 0; s--)
              n(i.children[s], o, o);
          else
            for (let s = 0; s < i.children.length; s++)
              n(i.children[s], o, o);
        else
          !t && o === "start" ? i.lastFixed = !0 : !t && o === "end" ? i.firstFixedEnd = !0 : isNaN(Number(i.width)) ? li(`Multiple fixed columns should have a static width (key: ${i.key})`) : i.minWidth = Math.max(Number(i.width) || 0, Number(i.minWidth) || 0), t = !0;
      else if (i.children)
        if (o === "start")
          for (let s = i.children.length - 1; s >= 0; s--)
            n(i.children[s], o);
        else
          for (let s = 0; s < i.children.length; s++)
            n(i.children[s], o);
      else
        t = !1;
  }
  for (let i = e.length - 1; i >= 0; i--)
    n(e[i], "start");
  for (let i = 0; i < e.length; i++)
    n(e[i], "end");
  let a = 0;
  for (let i = 0; i < e.length; i++)
    a = Bb(e[i], a);
  let l = 0;
  for (let i = e.length - 1; i >= 0; i--)
    l = Mb(e[i], l);
}
function Bb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!e) return t;
  if (e.children) {
    e.fixedOffset = t;
    for (const n of e.children)
      t = Bb(n, t);
  } else e.fixed && e.fixed !== "end" && (e.fixedOffset = t, t += parseFloat(e.width || "0") || 0);
  return t;
}
function Mb(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!e) return t;
  if (e.children) {
    e.fixedEndOffset = t;
    for (const n of e.children)
      t = Mb(n, t);
  } else e.fixed === "end" && (e.fixedEndOffset = t, t += parseFloat(e.width || "0") || 0);
  return t;
}
function DP(e, t) {
  const n = [];
  let a = 0;
  const l = PP(e);
  for (; l.size() > 0; ) {
    let o = l.count();
    const r = [];
    let s = 1;
    for (; o > 0; ) {
      const {
        element: d,
        priority: u
      } = l.dequeue(), c = t - a - bd(d);
      if (r.push({
        ...d,
        rowspan: c ?? 1,
        colspan: d.children ? Hu(d).length : 1
      }), d.children)
        for (const f of d.children) {
          const v = u % 1 + s / Math.pow(10, a + 2);
          l.enqueue(f, a + c + v);
        }
      s += 1, o -= 1;
    }
    a += 1, n.push(r);
  }
  return {
    columns: e.map((o) => Hu(o)).flat(),
    headers: n
  };
}
function Rb(e) {
  const t = [];
  for (const n of e) {
    const a = {
      ...IP(n),
      ...n
    }, l = a.key ?? (typeof a.value == "string" ? a.value : null), i = a.value ?? l ?? null, o = {
      ...a,
      key: l,
      value: i,
      sortable: a.sortable ?? (a.key != null || !!a.sort),
      children: a.children ? Rb(a.children) : void 0
    };
    t.push(o);
  }
  return t;
}
function pd(e, t) {
  const n = Z([]), a = Z([]), l = Z({}), i = Z({}), o = Z({});
  ut(() => {
    var h, g, p;
    const d = (e.headers || Object.keys(e.items[0] ?? {}).map((y) => ({
      key: y,
      title: wn(y)
    }))).slice(), u = $b(d);
    (h = t == null ? void 0 : t.groupBy) != null && h.value.length && !u.has("data-table-group") && d.unshift({
      key: "data-table-group",
      title: "Group"
    }), (g = t == null ? void 0 : t.showSelect) != null && g.value && !u.has("data-table-select") && d.unshift({
      key: "data-table-select"
    }), (p = t == null ? void 0 : t.showExpand) != null && p.value && !u.has("data-table-expand") && d.push({
      key: "data-table-expand"
    });
    const c = Rb(d);
    NP(c);
    const f = Math.max(...c.map((y) => bd(y))) + 1, v = DP(c, f);
    n.value = v.headers, a.value = v.columns;
    const m = v.headers.flat(1);
    for (const y of m)
      y.key && (y.sortable && (y.sort && (l.value[y.key] = y.sort), y.sortRaw && (i.value[y.key] = y.sortRaw)), y.filter && (o.value[y.key] = y.filter));
  });
  const r = {
    headers: n,
    columns: a,
    sortFunctions: l,
    sortRawFunctions: i,
    filterFunctions: o
  };
  return at(Tb, r), r;
}
function ss() {
  const e = Me(Tb);
  if (!e) throw new Error("Missing headers!");
  return e;
}
const Lb = z({
  color: String,
  disableSort: Boolean,
  fixedHeader: Boolean,
  multiSort: Boolean,
  sortAscIcon: {
    type: Ve,
    default: "$sortAsc"
  },
  sortDescIcon: {
    type: Ve,
    default: "$sortDesc"
  },
  headerProps: {
    type: Object
  },
  /** @deprecated */
  sticky: Boolean,
  ...kl(),
  ...Gr()
}, "VDataTableHeaders"), Sl = ne()({
  name: "VDataTableHeaders",
  props: Lb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = nt(), {
      toggleSort: l,
      sortBy: i,
      isSorted: o
    } = Ab(), {
      someSelected: r,
      allSelected: s,
      selectAll: d,
      showSelectAll: u
    } = is(), {
      columns: c,
      headers: f
    } = ss(), {
      loaderClasses: v
    } = xo(e);
    function m(N, V) {
      if (!(e.sticky || e.fixedHeader) && !N.fixed) return;
      const I = typeof N.fixed == "string" ? N.fixed : N.fixed ? "start" : "none";
      return {
        position: "sticky",
        left: I === "start" ? pe(N.fixedOffset) : void 0,
        right: I === "end" ? pe(N.fixedEndOffset) : void 0,
        top: e.sticky || e.fixedHeader ? `calc(var(--v-table-header-height) * ${V})` : void 0
      };
    }
    function h(N, V) {
      N.key === "Enter" && !e.disableSort && l(V);
    }
    function g(N) {
      const V = i.value.find((I) => I.key === N.key);
      return V ? V.order === "asc" ? e.sortAscIcon : e.sortDescIcon : e.sortAscIcon;
    }
    const {
      backgroundColorClasses: p,
      backgroundColorStyles: y
    } = Xe(() => e.color), {
      displayClasses: _,
      mobile: E
    } = Vn(e), k = x(() => ({
      headers: f.value,
      columns: c.value,
      toggleSort: l,
      isSorted: o,
      sortBy: i.value,
      someSelected: r.value,
      allSelected: s.value,
      selectAll: d,
      getSortIcon: g
    })), P = x(() => ["v-data-table__th", {
      "v-data-table__th--sticky": e.sticky || e.fixedHeader
    }, _.value, v.value]), A = (N) => {
      let {
        column: V,
        x: I,
        y: w
      } = N;
      const T = V.key === "data-table-select" || V.key === "data-table-expand", M = V.key === "data-table-group" && V.width === 0 && !V.title, W = Q(e.headerProps ?? {}, V.headerProps ?? {});
      return b(uo, Q({
        tag: "th",
        align: V.align,
        class: [{
          "v-data-table__th--sortable": V.sortable && !e.disableSort,
          "v-data-table__th--sorted": o(V),
          "v-data-table__th--fixed": V.fixed
        }, ...P.value],
        style: {
          width: pe(V.width),
          minWidth: pe(V.minWidth),
          maxWidth: pe(V.maxWidth),
          ...m(V, w)
        },
        colspan: V.colspan,
        rowspan: V.rowspan,
        fixed: V.fixed,
        nowrap: V.nowrap,
        lastFixed: V.lastFixed,
        firstFixedEnd: V.firstFixedEnd,
        noPadding: T,
        empty: M,
        tabindex: V.sortable ? 0 : void 0,
        onClick: V.sortable ? () => l(V) : void 0,
        onKeydown: V.sortable ? (J) => h(J, V) : void 0
      }, W), {
        default: () => {
          var Y;
          const J = `header.${V.key}`, ee = {
            column: V,
            selectAll: d,
            isSorted: o,
            toggleSort: l,
            sortBy: i.value,
            someSelected: r.value,
            allSelected: s.value,
            getSortIcon: g
          };
          return n[J] ? n[J](ee) : M ? "" : V.key === "data-table-select" ? ((Y = n["header.data-table-select"]) == null ? void 0 : Y.call(n, ee)) ?? (u.value && b(ia, {
            modelValue: s.value,
            indeterminate: r.value && !s.value,
            "onUpdate:modelValue": d
          }, null)) : S("div", {
            class: "v-data-table-header__content"
          }, [S("span", null, [V.title]), V.sortable && !e.disableSort && b(Ue, {
            key: "icon",
            class: "v-data-table-header__sort-icon",
            icon: g(V)
          }, null), e.multiSort && o(V) && S("div", {
            key: "badge",
            class: le(["v-data-table-header__sort-badge", ...p.value]),
            style: he(y.value)
          }, [i.value.findIndex((L) => L.key === V.key) + 1])]);
        }
      });
    }, D = () => {
      const N = x(() => c.value.filter((I) => (I == null ? void 0 : I.sortable) && !e.disableSort)), V = x(() => {
        if (c.value.find((w) => w.key === "data-table-select") != null)
          return s.value ? "$checkboxOn" : r.value ? "$checkboxIndeterminate" : "$checkboxOff";
      });
      return b(uo, Q({
        tag: "th",
        class: [...P.value],
        colspan: f.value.length + 1
      }, e.headerProps), {
        default: () => [S("div", {
          class: "v-data-table-header__content"
        }, [b(sd, {
          chips: !0,
          class: "v-data-table__td-sort-select",
          clearable: !0,
          density: "default",
          items: N.value,
          label: a("$vuetify.dataTable.sortBy"),
          multiple: e.multiSort,
          variant: "underlined",
          "onClick:clear": () => i.value = [],
          appendIcon: V.value,
          "onClick:append": () => d(!s.value)
        }, {
          chip: (I) => {
            var w;
            return b(bi, {
              onClick: (w = I.item.raw) != null && w.sortable ? () => l(I.item.raw) : void 0,
              onMousedown: (T) => {
                T.preventDefault(), T.stopPropagation();
              }
            }, {
              default: () => [I.item.title, b(Ue, {
                class: le(["v-data-table__td-sort-icon", o(I.item.raw) && "v-data-table__td-sort-icon-active"]),
                icon: g(I.item.raw),
                size: "small"
              }, null)]
            });
          }
        })])]
      });
    };
    re(() => E.value ? S("tr", null, [b(D, null, null)]) : S(ye, null, [n.headers ? n.headers(k.value) : f.value.map((N, V) => S("tr", null, [N.map((I, w) => b(A, {
      column: I,
      x: w,
      y: V
    }, null))])), e.loading && S("tr", {
      class: "v-data-table-progress"
    }, [S("th", {
      colspan: c.value.length
    }, [b(ko, {
      name: "v-data-table-progress",
      absolute: !0,
      active: !0,
      color: typeof e.loading == "boolean" ? void 0 : e.loading,
      indeterminate: !0
    }, {
      default: n.loader
    })])])]));
  }
}), Fb = z({
  item: {
    type: Object,
    required: !0
  },
  groupCollapseIcon: {
    type: Ve,
    default: "$tableGroupCollapse"
  },
  groupExpandIcon: {
    type: Ve,
    default: "$tableGroupExpand"
  }
}, "VDataTableGroupHeaderRow"), AP = ne()({
  name: "VDataTableGroupHeaderRow",
  props: Fb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isGroupOpen: a,
      toggleGroup: l,
      extractRows: i
    } = wb(), {
      isSelected: o,
      isSomeSelected: r,
      select: s
    } = is(), {
      columns: d
    } = ss(), u = x(() => i([e.item])), c = R(() => d.value.length - (d.value.some((f) => f.key === "data-table-select") ? 1 : 0));
    return () => S("tr", {
      class: "v-data-table-group-header-row",
      style: {
        "--v-data-table-group-header-row-depth": e.item.depth
      }
    }, [d.value.map((f) => {
      var v, m;
      if (f.key === "data-table-group") {
        const h = a(e.item) ? e.groupCollapseIcon : e.groupExpandIcon, g = () => l(e.item);
        return ((v = n["data-table-group"]) == null ? void 0 : v.call(n, {
          item: e.item,
          count: u.value.length,
          props: {
            icon: h,
            onClick: g
          }
        })) ?? b(uo, {
          class: "v-data-table-group-header-row__column",
          colspan: c.value
        }, {
          default: () => [b(Le, {
            size: "small",
            variant: "text",
            icon: h,
            onClick: g
          }, null), S("span", null, [e.item.value]), S("span", null, [ze("("), u.value.length, ze(")")])]
        });
      } else if (f.key === "data-table-select") {
        const h = o(u.value), g = r(u.value) && !h, p = (y) => s(u.value, y);
        return ((m = n["data-table-select"]) == null ? void 0 : m.call(n, {
          props: {
            modelValue: h,
            indeterminate: g,
            "onUpdate:modelValue": p
          }
        })) ?? b(uo, {
          class: "v-data-table__td--select-row",
          noPadding: !0
        }, {
          default: () => [b(ia, {
            modelValue: h,
            indeterminate: g,
            "onUpdate:modelValue": p
          }, null)]
        });
      }
      return "";
    })]);
  }
}), Hb = z({
  index: Number,
  item: Object,
  cellProps: [Object, Function],
  collapseIcon: {
    type: Ve,
    default: "$collapse"
  },
  expandIcon: {
    type: Ve,
    default: "$expand"
  },
  onClick: zt(),
  onContextmenu: zt(),
  onDblclick: zt(),
  ...kl()
}, "VDataTableRow"), Sd = ne()({
  name: "VDataTableRow",
  props: Hb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      displayClasses: a,
      mobile: l
    } = Vn(e, "v-data-table__tr"), {
      isSelected: i,
      toggleSelect: o,
      someSelected: r,
      allSelected: s,
      selectAll: d
    } = is(), {
      isExpanded: u,
      toggleExpand: c
    } = pb(), {
      toggleSort: f,
      sortBy: v,
      isSorted: m
    } = Ab(), {
      columns: h
    } = ss();
    re(() => S("tr", {
      class: le(["v-data-table__tr", {
        "v-data-table__tr--clickable": !!(e.onClick || e.onContextmenu || e.onDblclick)
      }, a.value]),
      onClick: e.onClick,
      onContextmenu: e.onContextmenu,
      onDblclick: e.onDblclick
    }, [e.item && h.value.map((g, p) => {
      const y = e.item, _ = `item.${g.key}`, E = `header.${g.key}`, k = {
        index: e.index,
        item: y.raw,
        internalItem: y,
        value: gl(y.columns, g.key),
        column: g,
        isSelected: i,
        toggleSelect: o,
        isExpanded: u,
        toggleExpand: c
      }, P = {
        column: g,
        selectAll: d,
        isSorted: m,
        toggleSort: f,
        sortBy: v.value,
        someSelected: r.value,
        allSelected: s.value,
        getSortIcon: () => ""
      }, A = typeof e.cellProps == "function" ? e.cellProps({
        index: k.index,
        item: k.item,
        internalItem: k.internalItem,
        value: k.value,
        column: g
      }) : e.cellProps, D = typeof g.cellProps == "function" ? g.cellProps({
        index: k.index,
        item: k.item,
        internalItem: k.internalItem,
        value: k.value
      }) : g.cellProps, N = g.key === "data-table-select" || g.key === "data-table-expand", V = g.key === "data-table-group" && g.width === 0 && !g.title;
      return b(uo, Q({
        align: g.align,
        indent: g.intent,
        class: {
          "v-data-table__td--expanded-row": g.key === "data-table-expand",
          "v-data-table__td--select-row": g.key === "data-table-select"
        },
        fixed: g.fixed,
        fixedOffset: g.fixedOffset,
        fixedEndOffset: g.fixedEndOffset,
        lastFixed: g.lastFixed,
        firstFixedEnd: g.firstFixedEnd,
        maxWidth: l.value ? void 0 : g.maxWidth,
        noPadding: N,
        empty: V,
        nowrap: g.nowrap,
        width: l.value ? void 0 : g.width
      }, A, D), {
        default: () => {
          var w, T, M, W;
          if (g.key === "data-table-select")
            return ((w = n["item.data-table-select"]) == null ? void 0 : w.call(n, {
              ...k,
              props: {
                disabled: !y.selectable,
                modelValue: i([y]),
                onClick: ea(() => o(y), ["stop"])
              }
            })) ?? b(ia, {
              disabled: !y.selectable,
              modelValue: i([y]),
              onClick: ea((J) => o(y, e.index, J), ["stop"])
            }, null);
          if (g.key === "data-table-expand")
            return ((T = n["item.data-table-expand"]) == null ? void 0 : T.call(n, {
              ...k,
              props: {
                icon: u(y) ? e.collapseIcon : e.expandIcon,
                size: "small",
                variant: "text",
                onClick: ea(() => c(y), ["stop"])
              }
            })) ?? b(Le, {
              icon: u(y) ? e.collapseIcon : e.expandIcon,
              size: "small",
              variant: "text",
              onClick: ea(() => c(y), ["stop"])
            }, null);
          if (n[_] && !l.value) return n[_](k);
          const I = Re(k.value);
          return l.value ? S(ye, null, [S("div", {
            class: "v-data-table__td-title"
          }, [((M = n[E]) == null ? void 0 : M.call(n, P)) ?? g.title]), S("div", {
            class: "v-data-table__td-value"
          }, [((W = n[_]) == null ? void 0 : W.call(n, k)) ?? I])]) : I;
        }
      });
    })]));
  }
}), zb = z({
  loading: [Boolean, String],
  loadingText: {
    type: String,
    default: "$vuetify.dataIterator.loadingText"
  },
  hideNoData: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  ...mn(Hb(), ["collapseIcon", "expandIcon"]),
  ...mn(Fb(), ["groupCollapseIcon", "groupExpandIcon"]),
  ...kl()
}, "VDataTableRows"), wl = ne()({
  name: "VDataTableRows",
  inheritAttrs: !1,
  props: zb(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      columns: l
    } = ss(), {
      expandOnClick: i,
      toggleExpand: o,
      isExpanded: r
    } = pb(), {
      isSelected: s,
      toggleSelect: d
    } = is(), {
      toggleGroup: u,
      isGroupOpen: c
    } = wb(), {
      t: f
    } = nt(), {
      mobile: v
    } = Vn(e);
    return re(() => {
      var h, g;
      const m = mn(e, ["groupCollapseIcon", "groupExpandIcon"]);
      return e.loading && (!e.items.length || a.loading) ? S("tr", {
        class: "v-data-table-rows-loading",
        key: "loading"
      }, [S("td", {
        colspan: l.value.length
      }, [((h = a.loading) == null ? void 0 : h.call(a)) ?? f(e.loadingText)])]) : !e.loading && !e.items.length && !e.hideNoData ? S("tr", {
        class: "v-data-table-rows-no-data",
        key: "no-data"
      }, [S("td", {
        colspan: l.value.length
      }, [((g = a["no-data"]) == null ? void 0 : g.call(a)) ?? f(e.noDataText)])]) : S(ye, null, [e.items.map((p, y) => {
        var k, P;
        if (p.type === "group") {
          const A = {
            index: y,
            item: p,
            columns: l.value,
            isExpanded: r,
            toggleExpand: o,
            isSelected: s,
            toggleSelect: d,
            toggleGroup: u,
            isGroupOpen: c
          };
          return a["group-header"] ? a["group-header"](A) : b(AP, Q({
            key: `group-header_${p.id}`,
            item: p
          }, fv(n, ":groupHeader", () => A), m), a);
        }
        if (p.type === "group-summary") {
          const A = {
            index: y,
            item: p,
            columns: l.value,
            toggleGroup: u
          };
          return ((k = a["group-summary"]) == null ? void 0 : k.call(a, A)) ?? "";
        }
        const _ = {
          index: y,
          item: p.raw,
          internalItem: p,
          columns: l.value,
          isExpanded: r,
          toggleExpand: o,
          isSelected: s,
          toggleSelect: d
        }, E = {
          ..._,
          props: Q({
            key: `item_${p.key ?? p.index}`,
            onClick: i.value ? () => {
              o(p);
            } : void 0,
            index: y,
            item: p,
            cellProps: e.cellProps,
            collapseIcon: e.collapseIcon,
            expandIcon: e.expandIcon,
            mobile: v.value
          }, fv(n, ":row", () => _), typeof e.rowProps == "function" ? e.rowProps({
            item: _.item,
            index: _.index,
            internalItem: _.internalItem
          }) : e.rowProps)
        };
        return S(ye, {
          key: E.props.key
        }, [a.item ? a.item(E) : b(Sd, E.props, a), r(p) && ((P = a["expanded-row"]) == null ? void 0 : P.call(a, _))]);
      })]);
    }), {};
  }
}), jb = z({
  fixedHeader: Boolean,
  fixedFooter: Boolean,
  height: [Number, String],
  hover: Boolean,
  striped: {
    type: String,
    default: null,
    validator: (e) => ["even", "odd"].includes(e)
  },
  ...ke(),
  ...Tt(),
  ...Oe(),
  ...We()
}, "VTable"), _l = ne()({
  name: "VTable",
  props: jb(),
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const {
      themeClasses: l
    } = Ye(e), {
      densityClasses: i
    } = tn(e);
    return re(() => {
      const o = {
        VCheckboxBtn: {
          density: e.density
        }
      };
      return b(e.tag, {
        class: le(["v-table", {
          "v-table--fixed-height": !!e.height,
          "v-table--fixed-header": e.fixedHeader,
          "v-table--fixed-footer": e.fixedFooter,
          "v-table--has-top": !!n.top,
          "v-table--has-bottom": !!n.bottom,
          "v-table--hover": e.hover,
          "v-table--striped-even": e.striped === "even",
          "v-table--striped-odd": e.striped === "odd"
        }, l.value, i.value, e.class]),
        style: he(e.style)
      }, {
        default: () => {
          var r, s;
          return [(r = n.top) == null ? void 0 : r.call(n), b(Be, {
            defaults: o
          }, {
            default: () => {
              var d;
              return [n.default ? S("div", {
                class: "v-table__wrapper",
                style: {
                  height: pe(e.height)
                }
              }, [S("table", null, [n.default()])]) : (d = n.wrapper) == null ? void 0 : d.call(n)];
            }
          }), (s = n.bottom) == null ? void 0 : s.call(n)];
        }
      });
    }), {};
  }
}), TP = z({
  items: {
    type: Array,
    default: () => []
  },
  itemValue: {
    type: [String, Array, Function],
    default: "id"
  },
  itemSelectable: {
    type: [String, Array, Function],
    default: null
  },
  rowProps: [Object, Function],
  cellProps: [Object, Function],
  returnObject: Boolean
}, "DataTable-items");
function OP(e, t, n, a) {
  const l = e.returnObject ? t : xt(t, e.itemValue), i = xt(t, e.itemSelectable, !0), o = a.reduce((r, s) => (s.key != null && (r[s.key] = xt(t, s.value)), r), {});
  return {
    type: "item",
    key: e.returnObject ? xt(t, e.itemValue) : l,
    index: n,
    value: l,
    selectable: i,
    columns: o,
    raw: t
  };
}
function $P(e, t, n) {
  return t.map((a, l) => OP(e, a, l, n));
}
function wd(e, t) {
  return {
    items: x(() => $P(e, e.items, t.value))
  };
}
const _d = z({
  ...zb(),
  hideDefaultBody: Boolean,
  hideDefaultFooter: Boolean,
  hideDefaultHeader: Boolean,
  width: [String, Number],
  search: String,
  ...yb(),
  ...dd(),
  ...VP(),
  ...TP(),
  ...Pb(),
  ...Nb(),
  ...Lb(),
  ...jb()
}, "DataTable"), BP = z({
  ...vd(),
  ..._d(),
  ...Si(),
  ...yd()
}, "VDataTable"), MP = ne()({
  name: "VDataTable",
  props: BP(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0,
    "update:currentItems": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      groupBy: l
    } = fd(e), {
      sortBy: i,
      multiSort: o,
      mustSort: r
    } = os(e), {
      page: s,
      itemsPerPage: d
    } = md(e), {
      disableSort: u
    } = ci(e), {
      columns: c,
      headers: f,
      sortFunctions: v,
      sortRawFunctions: m,
      filterFunctions: h
    } = pd(e, {
      groupBy: l,
      showSelect: R(() => e.showSelect),
      showExpand: R(() => e.showExpand)
    }), {
      items: g
    } = wd(e, c), p = R(() => e.search), {
      filteredItems: y
    } = wi(e, g, p, {
      transform: (B) => B.columns,
      customKeyFilter: h
    }), {
      toggleSort: _
    } = rs({
      sortBy: i,
      multiSort: o,
      mustSort: r,
      page: s
    }), {
      sortByWithGroups: E,
      opened: k,
      extractRows: P,
      isGroupOpen: A,
      toggleGroup: D
    } = ts({
      groupBy: l,
      sortBy: i,
      disableSort: u
    }), {
      sortedItems: N
    } = gd(e, y, E, {
      transform: (B) => ({
        ...B.raw,
        ...B.columns
      }),
      sortFunctions: v,
      sortRawFunctions: m
    }), {
      flatItems: V
    } = ns(N, l, k, () => !!a["group-summary"]), I = x(() => V.value.length), {
      startIndex: w,
      stopIndex: T,
      pageCount: M,
      setItemsPerPage: W
    } = hd({
      page: s,
      itemsPerPage: d,
      itemsLength: I
    }), {
      paginatedItems: J
    } = Cb({
      items: V,
      startIndex: w,
      stopIndex: T,
      itemsPerPage: d
    }), ee = x(() => P(J.value)), {
      isSelected: Y,
      select: L,
      selectAll: H,
      toggleSelect: j,
      someSelected: U,
      allSelected: F
    } = ls(e, {
      allItems: g,
      currentPage: ee
    }), {
      isExpanded: oe,
      toggleExpand: ve
    } = es(e);
    as({
      page: s,
      itemsPerPage: d,
      sortBy: i,
      groupBy: l,
      search: p
    }), gt({
      VDataTableRows: {
        hideNoData: R(() => e.hideNoData),
        noDataText: R(() => e.noDataText),
        loading: R(() => e.loading),
        loadingText: R(() => e.loadingText)
      }
    });
    const _e = x(() => ({
      page: s.value,
      itemsPerPage: d.value,
      sortBy: i.value,
      pageCount: M.value,
      toggleSort: _,
      setItemsPerPage: W,
      someSelected: U.value,
      allSelected: F.value,
      isSelected: Y,
      select: L,
      selectAll: H,
      toggleSelect: j,
      isExpanded: oe,
      toggleExpand: ve,
      isGroupOpen: A,
      toggleGroup: D,
      items: ee.value.map((B) => B.raw),
      internalItems: ee.value,
      groupedItems: J.value,
      columns: c.value,
      headers: f.value
    }));
    return re(() => {
      const B = so.filterProps(e), G = Sl.filterProps(e), ie = wl.filterProps(e), de = _l.filterProps(e);
      return b(_l, Q({
        class: ["v-data-table", {
          "v-data-table--show-select": e.showSelect,
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, de, {
        fixedHeader: e.fixedHeader || e.sticky
      }), {
        top: () => {
          var Se;
          return (Se = a.top) == null ? void 0 : Se.call(a, _e.value);
        },
        default: () => {
          var Se, Ce, C, O, $, K;
          return a.default ? a.default(_e.value) : S(ye, null, [(Se = a.colgroup) == null ? void 0 : Se.call(a, _e.value), !e.hideDefaultHeader && S("thead", {
            key: "thead"
          }, [b(Sl, G, a)]), (Ce = a.thead) == null ? void 0 : Ce.call(a, _e.value), !e.hideDefaultBody && S("tbody", null, [(C = a["body.prepend"]) == null ? void 0 : C.call(a, _e.value), a.body ? a.body(_e.value) : b(wl, Q(n, ie, {
            items: J.value
          }), a), (O = a["body.append"]) == null ? void 0 : O.call(a, _e.value)]), ($ = a.tbody) == null ? void 0 : $.call(a, _e.value), (K = a.tfoot) == null ? void 0 : K.call(a, _e.value)]);
        },
        bottom: () => a.bottom ? a.bottom(_e.value) : !e.hideDefaultFooter && S(ye, null, [b(Sn, null, null), b(so, B, {
          prepend: a["footer.prepend"]
        })])
      });
    }), {};
  }
}), RP = z({
  ...tt(_d(), ["hideDefaultFooter"]),
  ...dd(),
  ...Xy(),
  ...Si()
}, "VDataTableVirtual"), LP = ne()({
  name: "VDataTableVirtual",
  props: RP(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:groupBy": (e) => !0,
    "update:expanded": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      groupBy: l
    } = fd(e), {
      sortBy: i,
      multiSort: o,
      mustSort: r
    } = os(e), {
      disableSort: s
    } = ci(e), {
      columns: d,
      headers: u,
      filterFunctions: c,
      sortFunctions: f,
      sortRawFunctions: v
    } = pd(e, {
      groupBy: l,
      showSelect: R(() => e.showSelect),
      showExpand: R(() => e.showExpand)
    }), {
      items: m
    } = wd(e, d), h = R(() => e.search), {
      filteredItems: g
    } = wi(e, m, h, {
      transform: (de) => de.columns,
      customKeyFilter: c
    }), {
      toggleSort: p
    } = rs({
      sortBy: i,
      multiSort: o,
      mustSort: r
    }), {
      sortByWithGroups: y,
      opened: _,
      extractRows: E,
      isGroupOpen: k,
      toggleGroup: P
    } = ts({
      groupBy: l,
      sortBy: i,
      disableSort: s
    }), {
      sortedItems: A
    } = gd(e, g, y, {
      transform: (de) => ({
        ...de.raw,
        ...de.columns
      }),
      sortFunctions: f,
      sortRawFunctions: v
    }), {
      flatItems: D
    } = ns(A, l, _, () => !!a["group-summary"]), N = x(() => E(D.value)), {
      isSelected: V,
      select: I,
      selectAll: w,
      toggleSelect: T,
      someSelected: M,
      allSelected: W
    } = ls(e, {
      allItems: N,
      currentPage: N
    }), {
      isExpanded: J,
      toggleExpand: ee
    } = es(e), {
      containerRef: Y,
      markerRef: L,
      paddingTop: H,
      paddingBottom: j,
      computedItems: U,
      handleItemResize: F,
      handleScroll: oe,
      handleScrollend: ve,
      calculateVisibleItems: _e,
      scrollToIndex: B
    } = Jy(e, D), G = x(() => U.value.map((de) => de.raw));
    as({
      sortBy: i,
      page: fe(1),
      itemsPerPage: fe(-1),
      groupBy: l,
      search: h
    }), gt({
      VDataTableRows: {
        hideNoData: R(() => e.hideNoData),
        noDataText: R(() => e.noDataText),
        loading: R(() => e.loading),
        loadingText: R(() => e.loadingText)
      }
    });
    const ie = x(() => ({
      sortBy: i.value,
      toggleSort: p,
      someSelected: M.value,
      allSelected: W.value,
      isSelected: V,
      select: I,
      selectAll: w,
      toggleSelect: T,
      isExpanded: J,
      toggleExpand: ee,
      isGroupOpen: k,
      toggleGroup: P,
      items: N.value.map((de) => de.raw),
      internalItems: N.value,
      groupedItems: D.value,
      columns: d.value,
      headers: u.value
    }));
    return re(() => {
      const de = Sl.filterProps(e), Se = wl.filterProps(e), Ce = _l.filterProps(e);
      return b(_l, Q({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, Ce, {
        fixedHeader: e.fixedHeader || e.sticky
      }), {
        top: () => {
          var C;
          return (C = a.top) == null ? void 0 : C.call(a, ie.value);
        },
        wrapper: () => {
          var C, O, $, K, X, te;
          return S("div", {
            ref: Y,
            onScrollPassive: oe,
            onScrollend: ve,
            class: "v-table__wrapper",
            style: {
              height: pe(e.height)
            }
          }, [S("table", null, [(C = a.colgroup) == null ? void 0 : C.call(a, ie.value), !e.hideDefaultHeader && S("thead", {
            key: "thead"
          }, [b(Sl, de, a)]), (O = a.thead) == null ? void 0 : O.call(a, ie.value), !e.hideDefaultBody && S("tbody", {
            key: "tbody"
          }, [S("tr", {
            ref: L,
            style: {
              height: pe(H.value),
              border: 0
            }
          }, [S("td", {
            colspan: d.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)]), ($ = a["body.prepend"]) == null ? void 0 : $.call(a, ie.value), b(wl, Q(n, Se, {
            items: G.value
          }), {
            ...a,
            item: (ue) => b(qy, {
              key: ue.internalItem.index,
              renderless: !0,
              "onUpdate:height": (se) => F(ue.internalItem.index, se)
            }, {
              default: (se) => {
                var ae;
                let {
                  itemRef: ce
                } = se;
                return ((ae = a.item) == null ? void 0 : ae.call(a, {
                  ...ue,
                  itemRef: ce
                })) ?? b(Sd, Q(ue.props, {
                  ref: ce,
                  key: ue.internalItem.index,
                  index: ue.internalItem.index
                }), a);
              }
            })
          }), (K = a["body.append"]) == null ? void 0 : K.call(a, ie.value), S("tr", {
            style: {
              height: pe(j.value),
              border: 0
            }
          }, [S("td", {
            colspan: d.value.length,
            style: {
              height: 0,
              border: 0
            }
          }, null)])]), (X = a.tbody) == null ? void 0 : X.call(a, ie.value), (te = a.tfoot) == null ? void 0 : te.call(a, ie.value)])]);
        },
        bottom: () => {
          var C;
          return (C = a.bottom) == null ? void 0 : C.call(a, ie.value);
        }
      });
    }), {
      calculateVisibleItems: _e,
      scrollToIndex: B
    };
  }
}), FP = z({
  itemsLength: {
    type: [Number, String],
    required: !0
  },
  ...vd(),
  ..._d(),
  ...yd()
}, "VDataTableServer"), HP = ne()({
  name: "VDataTableServer",
  props: FP(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:page": (e) => !0,
    "update:itemsPerPage": (e) => !0,
    "update:sortBy": (e) => !0,
    "update:options": (e) => !0,
    "update:expanded": (e) => !0,
    "update:groupBy": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      groupBy: l
    } = fd(e), {
      sortBy: i,
      multiSort: o,
      mustSort: r
    } = os(e), {
      page: s,
      itemsPerPage: d
    } = md(e), {
      disableSort: u
    } = ci(e), c = x(() => parseInt(e.itemsLength, 10)), {
      columns: f,
      headers: v
    } = pd(e, {
      groupBy: l,
      showSelect: R(() => e.showSelect),
      showExpand: R(() => e.showExpand)
    }), {
      items: m
    } = wd(e, f), {
      toggleSort: h
    } = rs({
      sortBy: i,
      multiSort: o,
      mustSort: r,
      page: s
    }), {
      opened: g,
      isGroupOpen: p,
      toggleGroup: y,
      extractRows: _
    } = ts({
      groupBy: l,
      sortBy: i,
      disableSort: u
    }), {
      pageCount: E,
      setItemsPerPage: k
    } = hd({
      page: s,
      itemsPerPage: d,
      itemsLength: c
    }), {
      flatItems: P
    } = ns(m, l, g, () => !!a["group-summary"]), {
      isSelected: A,
      select: D,
      selectAll: N,
      toggleSelect: V,
      someSelected: I,
      allSelected: w
    } = ls(e, {
      allItems: m,
      currentPage: m
    }), {
      isExpanded: T,
      toggleExpand: M
    } = es(e), W = x(() => _(m.value));
    as({
      page: s,
      itemsPerPage: d,
      sortBy: i,
      groupBy: l,
      search: R(() => e.search)
    }), at("v-data-table", {
      toggleSort: h,
      sortBy: i
    }), gt({
      VDataTableRows: {
        hideNoData: R(() => e.hideNoData),
        noDataText: R(() => e.noDataText),
        loading: R(() => e.loading),
        loadingText: R(() => e.loadingText)
      }
    });
    const J = x(() => ({
      page: s.value,
      itemsPerPage: d.value,
      sortBy: i.value,
      pageCount: E.value,
      toggleSort: h,
      setItemsPerPage: k,
      someSelected: I.value,
      allSelected: w.value,
      isSelected: A,
      select: D,
      selectAll: N,
      toggleSelect: V,
      isExpanded: T,
      toggleExpand: M,
      isGroupOpen: p,
      toggleGroup: y,
      items: W.value.map((ee) => ee.raw),
      internalItems: W.value,
      groupedItems: P.value,
      columns: f.value,
      headers: v.value
    }));
    re(() => {
      const ee = so.filterProps(e), Y = Sl.filterProps(e), L = wl.filterProps(e), H = _l.filterProps(e);
      return b(_l, Q({
        class: ["v-data-table", {
          "v-data-table--loading": e.loading
        }, e.class],
        style: e.style
      }, H, {
        fixedHeader: e.fixedHeader || e.sticky
      }), {
        top: () => {
          var j;
          return (j = a.top) == null ? void 0 : j.call(a, J.value);
        },
        default: () => {
          var j, U, F, oe, ve, _e;
          return a.default ? a.default(J.value) : S(ye, null, [(j = a.colgroup) == null ? void 0 : j.call(a, J.value), !e.hideDefaultHeader && S("thead", {
            key: "thead",
            class: "v-data-table__thead",
            role: "rowgroup"
          }, [b(Sl, Y, a)]), (U = a.thead) == null ? void 0 : U.call(a, J.value), !e.hideDefaultBody && S("tbody", {
            class: "v-data-table__tbody",
            role: "rowgroup"
          }, [(F = a["body.prepend"]) == null ? void 0 : F.call(a, J.value), a.body ? a.body(J.value) : b(wl, Q(n, L, {
            items: P.value
          }), a), (oe = a["body.append"]) == null ? void 0 : oe.call(a, J.value)]), (ve = a.tbody) == null ? void 0 : ve.call(a, J.value), (_e = a.tfoot) == null ? void 0 : _e.call(a, J.value)]);
        },
        bottom: () => a.bottom ? a.bottom(J.value) : !e.hideDefaultFooter && S(ye, null, [b(Sn, null, null), b(so, ee, {
          prepend: a["footer.prepend"]
        })])
      });
    });
  }
}), zP = z({
  fluid: {
    type: Boolean,
    default: !1
  },
  ...ke(),
  ...kt(),
  ...Oe()
}, "VContainer"), jP = ne()({
  name: "VContainer",
  props: zP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: a
    } = Et(), {
      dimensionStyles: l
    } = Ct(e);
    return re(() => b(e.tag, {
      class: le(["v-container", {
        "v-container--fluid": e.fluid
      }, a.value, e.class]),
      style: he([l.value, e.style])
    }, n)), {};
  }
}), Wb = Hr.reduce((e, t) => (e[t] = {
  type: [Boolean, String, Number],
  default: !1
}, e), {}), Ub = Hr.reduce((e, t) => {
  const n = "offset" + wn(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}), Gb = Hr.reduce((e, t) => {
  const n = "order" + wn(t);
  return e[n] = {
    type: [String, Number],
    default: null
  }, e;
}, {}), Rv = {
  col: Object.keys(Wb),
  offset: Object.keys(Ub),
  order: Object.keys(Gb)
};
function WP(e, t, n) {
  let a = e;
  if (!(n == null || n === !1)) {
    if (t) {
      const l = t.replace(e, "");
      a += `-${l}`;
    }
    return e === "col" && (a = "v-" + a), e === "col" && (n === "" || n === !0) || (a += `-${n}`), a.toLowerCase();
  }
}
const UP = ["auto", "start", "end", "center", "baseline", "stretch"], GP = z({
  cols: {
    type: [Boolean, String, Number],
    default: !1
  },
  ...Wb,
  offset: {
    type: [String, Number],
    default: null
  },
  ...Ub,
  order: {
    type: [String, Number],
    default: null
  },
  ...Gb,
  alignSelf: {
    type: String,
    default: null,
    validator: (e) => UP.includes(e)
  },
  ...ke(),
  ...Oe()
}, "VCol"), KP = ne()({
  name: "VCol",
  props: GP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = x(() => {
      const l = [];
      let i;
      for (i in Rv)
        Rv[i].forEach((r) => {
          const s = e[r], d = WP(i, r, s);
          d && l.push(d);
        });
      const o = l.some((r) => r.startsWith("v-col-"));
      return l.push({
        // Default to .v-col if no other col-{bp}-* classes generated nor `cols` specified.
        "v-col": !o || !e.cols,
        [`v-col-${e.cols}`]: e.cols,
        [`offset-${e.offset}`]: e.offset,
        [`order-${e.order}`]: e.order,
        [`align-self-${e.alignSelf}`]: e.alignSelf
      }), l;
    });
    return () => {
      var l;
      return jn(e.tag, {
        class: [a.value, e.class],
        style: e.style
      }, (l = n.default) == null ? void 0 : l.call(n));
    };
  }
}), xd = ["start", "end", "center"], Kb = ["space-between", "space-around", "space-evenly"];
function kd(e, t) {
  return Hr.reduce((n, a) => {
    const l = e + wn(a);
    return n[l] = t(), n;
  }, {});
}
const YP = [...xd, "baseline", "stretch"], Yb = (e) => YP.includes(e), qb = kd("align", () => ({
  type: String,
  default: null,
  validator: Yb
})), qP = [...xd, ...Kb], Xb = (e) => qP.includes(e), Jb = kd("justify", () => ({
  type: String,
  default: null,
  validator: Xb
})), XP = [...xd, ...Kb, "stretch"], Zb = (e) => XP.includes(e), Qb = kd("alignContent", () => ({
  type: String,
  default: null,
  validator: Zb
})), Lv = {
  align: Object.keys(qb),
  justify: Object.keys(Jb),
  alignContent: Object.keys(Qb)
}, JP = {
  align: "align",
  justify: "justify",
  alignContent: "align-content"
};
function ZP(e, t, n) {
  let a = JP[e];
  if (n != null) {
    if (t) {
      const l = t.replace(e, "");
      a += `-${l}`;
    }
    return a += `-${n}`, a.toLowerCase();
  }
}
const QP = z({
  dense: Boolean,
  noGutters: Boolean,
  align: {
    type: String,
    default: null,
    validator: Yb
  },
  ...qb,
  justify: {
    type: String,
    default: null,
    validator: Xb
  },
  ...Jb,
  alignContent: {
    type: String,
    default: null,
    validator: Zb
  },
  ...Qb,
  ...ke(),
  ...Oe()
}, "VRow"), eI = ne()({
  name: "VRow",
  props: QP(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = x(() => {
      const l = [];
      let i;
      for (i in Lv)
        Lv[i].forEach((o) => {
          const r = e[o], s = ZP(i, o, r);
          s && l.push(s);
        });
      return l.push({
        "v-row--no-gutters": e.noGutters,
        "v-row--dense": e.dense,
        [`align-${e.align}`]: e.align,
        [`justify-${e.justify}`]: e.justify,
        [`align-content-${e.alignContent}`]: e.alignContent
      }), l;
    });
    return () => {
      var l;
      return jn(e.tag, {
        class: ["v-row", a.value, e.class],
        style: e.style
      }, (l = n.default) == null ? void 0 : l.call(n));
    };
  }
}), ep = Ca("v-spacer", "div", "VSpacer"), tp = z({
  active: {
    type: [String, Array],
    default: void 0
  },
  controlHeight: [Number, String],
  disabled: {
    type: [Boolean, String, Array],
    default: null
  },
  nextIcon: {
    type: Ve,
    default: "$next"
  },
  prevIcon: {
    type: Ve,
    default: "$prev"
  },
  modeIcon: {
    type: Ve,
    default: "$subgroup"
  },
  text: String,
  viewMode: {
    type: String,
    default: "month"
  }
}, "VDatePickerControls"), zu = ne()({
  name: "VDatePickerControls",
  props: tp(),
  emits: {
    "click:year": () => !0,
    "click:month": () => !0,
    "click:prev": () => !0,
    "click:next": () => !0,
    "click:text": () => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const {
      t: a
    } = nt(), l = x(() => Array.isArray(e.disabled) ? e.disabled.includes("text") : !!e.disabled), i = x(() => Array.isArray(e.disabled) ? e.disabled.includes("mode") : !!e.disabled), o = x(() => Array.isArray(e.disabled) ? e.disabled.includes("prev") : !!e.disabled), r = x(() => Array.isArray(e.disabled) ? e.disabled.includes("next") : !!e.disabled);
    function s() {
      n("click:prev");
    }
    function d() {
      n("click:next");
    }
    function u() {
      n("click:year");
    }
    function c() {
      n("click:month");
    }
    return re(() => S("div", {
      class: le(["v-date-picker-controls"]),
      style: {
        "--v-date-picker-controls-height": pe(e.controlHeight)
      }
    }, [b(Le, {
      class: "v-date-picker-controls__month-btn",
      "data-testid": "month-btn",
      disabled: l.value,
      text: e.text,
      variant: "text",
      rounded: !0,
      onClick: c
    }, null), b(Le, {
      class: "v-date-picker-controls__mode-btn",
      "data-testid": "year-btn",
      disabled: i.value,
      density: "comfortable",
      icon: e.modeIcon,
      variant: "text",
      "aria-label": a("$vuetify.datePicker.ariaLabel.selectYear"),
      onClick: u
    }, null), b(ep, null, null), S("div", {
      class: "v-date-picker-controls__month"
    }, [b(Le, {
      "data-testid": "prev-month",
      disabled: o.value,
      density: "comfortable",
      icon: e.prevIcon,
      variant: "text",
      "aria-label": a("$vuetify.datePicker.ariaLabel.previousMonth"),
      onClick: s
    }, null), b(Le, {
      "data-testid": "next-month",
      disabled: r.value,
      icon: e.nextIcon,
      density: "comfortable",
      variant: "text",
      "aria-label": a("$vuetify.datePicker.ariaLabel.nextMonth"),
      onClick: d
    }, null)])])), {};
  }
}), tI = z({
  appendIcon: Ve,
  color: String,
  header: String,
  transition: String,
  onClick: zt()
}, "VDatePickerHeader"), ju = ne()({
  name: "VDatePickerHeader",
  props: tI(),
  emits: {
    click: () => !0,
    "click:append": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      backgroundColorClasses: l,
      backgroundColorStyles: i
    } = Xe(() => e.color);
    function o() {
      n("click");
    }
    function r() {
      n("click:append");
    }
    return re(() => {
      const s = !!(a.default || e.header), d = !!(a.append || e.appendIcon);
      return S("div", {
        class: le(["v-date-picker-header", {
          "v-date-picker-header--clickable": !!e.onClick
        }, l.value]),
        style: he(i.value),
        onClick: o
      }, [a.prepend && S("div", {
        key: "prepend",
        class: "v-date-picker-header__prepend"
      }, [a.prepend()]), s && b(Zt, {
        key: "content",
        name: e.transition
      }, {
        default: () => {
          var u;
          return [S("div", {
            key: e.header,
            class: "v-date-picker-header__content"
          }, [((u = a.default) == null ? void 0 : u.call(a)) ?? e.header])];
        }
      }), d && S("div", {
        class: "v-date-picker-header__append"
      }, [a.append ? b(Be, {
        key: "append-defaults",
        disabled: !e.appendIcon,
        defaults: {
          VBtn: {
            icon: e.appendIcon,
            variant: "text"
          }
        }
      }, {
        default: () => {
          var u;
          return [(u = a.append) == null ? void 0 : u.call(a)];
        }
      }) : b(Le, {
        key: "append-btn",
        icon: e.appendIcon,
        variant: "text",
        onClick: r
      }, null)])]);
    }), {};
  }
}), nI = z({
  allowedDates: [Array, Function],
  disabled: {
    type: Boolean,
    default: null
  },
  displayValue: null,
  modelValue: Array,
  month: [Number, String],
  max: null,
  min: null,
  showAdjacentMonths: Boolean,
  year: [Number, String],
  weekdays: {
    type: Array,
    default: () => [0, 1, 2, 3, 4, 5, 6]
  },
  weeksInMonth: {
    type: String,
    default: "dynamic"
  },
  firstDayOfWeek: {
    type: [Number, String],
    default: void 0
  },
  firstDayOfYear: {
    type: [Number, String],
    default: void 0
  },
  weekdayFormat: String
}, "calendar");
function aI(e) {
  const t = wo(), n = Ee(e, "modelValue", [], (v) => ht(v).map((m) => t.date(m))), a = x(() => e.displayValue ? t.date(e.displayValue) : n.value.length > 0 ? t.date(n.value[0]) : e.min ? t.date(e.min) : Array.isArray(e.allowedDates) ? t.date(e.allowedDates[0]) : t.date()), l = Ee(e, "year", void 0, (v) => {
    const m = v != null ? Number(v) : t.getYear(a.value);
    return t.startOfYear(t.setYear(t.date(), m));
  }, (v) => t.getYear(v)), i = Ee(e, "month", void 0, (v) => {
    const m = v != null ? Number(v) : t.getMonth(a.value), h = t.setYear(t.startOfMonth(t.date()), t.getYear(l.value));
    return t.setMonth(h, m);
  }, (v) => t.getMonth(v)), o = x(() => {
    const v = t.toJsDate(t.startOfWeek(t.date(), e.firstDayOfWeek)).getDay();
    return t.getWeekdays(e.firstDayOfWeek, e.weekdayFormat).filter((m, h) => e.weekdays.includes((h + v) % 7));
  }), r = x(() => {
    const v = t.getWeekArray(i.value, e.firstDayOfWeek), m = v.flat(), h = 6 * 7;
    if (e.weeksInMonth === "static" && m.length < h) {
      const g = m[m.length - 1];
      let p = [];
      for (let y = 1; y <= h - m.length; y++)
        p.push(t.addDays(g, y)), y % 7 === 0 && (v.push(p), p = []);
    }
    return v;
  });
  function s(v, m) {
    return v.filter((h) => e.weekdays.includes(t.toJsDate(h).getDay())).map((h, g) => {
      const p = t.toISO(h), y = !t.isSameMonth(h, i.value), _ = t.isSameDay(h, t.startOfMonth(i.value)), E = t.isSameDay(h, t.endOfMonth(i.value)), k = t.isSameDay(h, i.value), P = e.weekdays.length;
      return {
        date: h,
        formatted: t.format(h, "keyboardDate"),
        isAdjacent: y,
        isDisabled: f(h),
        isEnd: E,
        isHidden: y && !e.showAdjacentMonths,
        isSame: k,
        isSelected: n.value.some((A) => t.isSameDay(h, A)),
        isStart: _,
        isToday: t.isSameDay(h, m),
        isWeekEnd: g % P === P - 1,
        isWeekStart: g % P === 0,
        isoDate: p,
        localized: t.format(h, "dayOfMonth"),
        month: t.getMonth(h),
        year: t.getYear(h)
      };
    });
  }
  const d = x(() => {
    const v = t.startOfWeek(a.value, e.firstDayOfWeek), m = [];
    for (let g = 0; g <= 6; g++)
      m.push(t.addDays(v, g));
    const h = t.date();
    return s(m, h);
  }), u = x(() => {
    const v = r.value.flat(), m = t.date();
    return s(v, m);
  }), c = x(() => r.value.map((v) => v.length ? t.getWeek(v[0], e.firstDayOfWeek, e.firstDayOfYear) : null));
  function f(v) {
    if (e.disabled) return !0;
    const m = t.date(v);
    return e.min && t.isBefore(t.endOfDay(m), t.date(e.min)) || e.max && t.isAfter(m, t.date(e.max)) ? !0 : Array.isArray(e.allowedDates) && e.allowedDates.length > 0 ? !e.allowedDates.some((h) => t.isSameDay(t.date(h), m)) : typeof e.allowedDates == "function" ? !e.allowedDates(m) : !1;
  }
  return {
    displayValue: a,
    daysInMonth: u,
    daysInWeek: d,
    genDays: s,
    model: n,
    weeksInMonth: r,
    weekdayLabels: o,
    weekNumbers: c
  };
}
const np = z({
  color: String,
  hideWeekdays: Boolean,
  multiple: [Boolean, Number, String],
  showWeek: Boolean,
  transition: {
    type: String,
    default: "picker-transition"
  },
  reverseTransition: {
    type: String,
    default: "picker-reverse-transition"
  },
  ...tt(nI(), ["displayValue"])
}, "VDatePickerMonth"), Wu = ne()({
  name: "VDatePickerMonth",
  props: np(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const l = Z(), {
      t: i
    } = nt(), {
      daysInMonth: o,
      model: r,
      weekNumbers: s,
      weekdayLabels: d
    } = aI(e), u = wo(), c = fe(), f = fe(), v = fe(!1), m = R(() => v.value ? e.reverseTransition : e.transition);
    e.multiple === "range" && r.value.length > 0 && (c.value = r.value[0], r.value.length > 1 && (f.value = r.value[r.value.length - 1]));
    const h = x(() => {
      const E = ["number", "string"].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0;
      return r.value.length >= E;
    });
    me(o, (E, k) => {
      k && (v.value = u.isBefore(E[0].date, k[0].date));
    });
    function g(E) {
      const k = u.startOfDay(E);
      if (r.value.length === 0 ? c.value = void 0 : r.value.length === 1 && (c.value = r.value[0], f.value = void 0), !c.value)
        c.value = k, r.value = [c.value];
      else if (f.value)
        c.value = E, f.value = void 0, r.value = [c.value];
      else {
        if (u.isSameDay(k, c.value)) {
          c.value = void 0, r.value = [];
          return;
        } else u.isBefore(k, c.value) ? (f.value = u.endOfDay(c.value), c.value = k) : f.value = u.endOfDay(k);
        r.value = lC(u, c.value, f.value);
      }
    }
    function p(E) {
      const k = u.format(E.date, "fullDateWithWeekday"), P = E.isToday ? "currentDate" : "selectDate";
      return i(`$vuetify.datePicker.ariaLabel.${P}`, k);
    }
    function y(E) {
      const k = r.value.findIndex((P) => u.isSameDay(P, E));
      if (k === -1)
        r.value = [...r.value, E];
      else {
        const P = [...r.value];
        P.splice(k, 1), r.value = P;
      }
    }
    function _(E) {
      e.multiple === "range" ? g(E) : e.multiple ? y(E) : r.value = [E];
    }
    re(() => S("div", {
      class: "v-date-picker-month",
      style: {
        "--v-date-picker-days-in-week": e.weekdays.length
      }
    }, [e.showWeek && S("div", {
      key: "weeks",
      class: "v-date-picker-month__weeks"
    }, [!e.hideWeekdays && S("div", {
      key: "hide-week-days",
      class: "v-date-picker-month__day"
    }, [ze("")]), s.value.map((E) => S("div", {
      class: le(["v-date-picker-month__day", "v-date-picker-month__day--adjacent"])
    }, [E]))]), b(Zt, {
      name: m.value
    }, {
      default: () => {
        var E;
        return [S("div", {
          ref: l,
          key: (E = o.value[0].date) == null ? void 0 : E.toString(),
          class: "v-date-picker-month__days"
        }, [!e.hideWeekdays && d.value.map((k) => S("div", {
          class: le(["v-date-picker-month__day", "v-date-picker-month__weekday"])
        }, [k])), o.value.map((k, P) => {
          var D;
          const A = {
            props: {
              class: "v-date-picker-month__day-btn",
              color: k.isSelected || k.isToday ? e.color : void 0,
              disabled: k.isDisabled,
              icon: !0,
              ripple: !1,
              text: k.localized,
              variant: k.isSelected ? "flat" : k.isToday ? "outlined" : "text",
              "aria-label": p(k),
              "aria-current": k.isToday ? "date" : void 0,
              onClick: () => _(k.date)
            },
            item: k,
            i: P
          };
          return h.value && !k.isSelected && (k.isDisabled = !0), S("div", {
            class: le(["v-date-picker-month__day", {
              "v-date-picker-month__day--adjacent": k.isAdjacent,
              "v-date-picker-month__day--hide-adjacent": k.isHidden,
              "v-date-picker-month__day--selected": k.isSelected,
              "v-date-picker-month__day--week-end": k.isWeekEnd,
              "v-date-picker-month__day--week-start": k.isWeekStart
            }]),
            "data-v-date": k.isDisabled ? void 0 : k.isoDate
          }, [(e.showAdjacentMonths || !k.isAdjacent) && (((D = a.day) == null ? void 0 : D.call(a, A)) ?? b(Le, A.props, null))]);
        })])];
      }
    })]));
  }
}), ap = z({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  year: Number,
  allowedMonths: [Array, Function]
}, "VDatePickerMonths"), Uu = ne()({
  name: "VDatePickerMonths",
  props: ap(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const l = wo(), i = Ee(e, "modelValue"), o = x(() => {
      let s = l.startOfYear(l.date());
      return e.year && (s = l.setYear(s, e.year)), bn(12).map((d) => {
        const u = l.format(s, "monthShort"), c = l.format(s, "month"), f = !!(!r(d) || e.min && l.isAfter(l.startOfMonth(l.date(e.min)), s) || e.max && l.isAfter(s, l.startOfMonth(l.date(e.max))));
        return s = l.getNextMonth(s), {
          isDisabled: f,
          text: u,
          label: c,
          value: d
        };
      });
    });
    ut(() => {
      i.value = i.value ?? l.getMonth(l.date());
    });
    function r(s) {
      return Array.isArray(e.allowedMonths) && e.allowedMonths.length ? e.allowedMonths.includes(s) : typeof e.allowedMonths == "function" ? e.allowedMonths(s) : !0;
    }
    return re(() => S("div", {
      class: "v-date-picker-months",
      style: {
        height: pe(e.height)
      }
    }, [S("div", {
      class: "v-date-picker-months__content"
    }, [o.value.map((s, d) => {
      var f;
      const u = {
        active: i.value === d,
        ariaLabel: s.label,
        color: i.value === d ? e.color : void 0,
        disabled: s.isDisabled,
        rounded: !0,
        text: s.text,
        variant: i.value === s.value ? "flat" : "text",
        onClick: () => c(d)
      };
      function c(v) {
        if (i.value === v) {
          n("update:modelValue", i.value);
          return;
        }
        i.value = v;
      }
      return ((f = a.month) == null ? void 0 : f.call(a, {
        month: s,
        i: d,
        props: u
      })) ?? b(Le, Q({
        key: "month"
      }, u), null);
    })])])), {};
  }
}), lp = z({
  color: String,
  height: [String, Number],
  min: null,
  max: null,
  modelValue: Number,
  allowedYears: [Array, Function]
}, "VDatePickerYears"), Gu = ne()({
  name: "VDatePickerYears",
  props: lp(),
  directives: {
    vIntersect: Hn
  },
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const l = wo(), i = Ee(e, "modelValue"), o = x(() => {
      const u = l.getYear(l.date());
      let c = u - 100, f = u + 52;
      e.min && (c = l.getYear(l.date(e.min))), e.max && (f = l.getYear(l.date(e.max)));
      let v = l.startOfYear(l.date());
      return v = l.setYear(v, c), bn(f - c + 1, c).map((m) => {
        const h = l.format(v, "year");
        return v = l.setYear(v, l.getYear(v) + 1), {
          text: h,
          value: m,
          isDisabled: !d(m)
        };
      });
    });
    ut(() => {
      i.value = i.value ?? l.getYear(l.date());
    });
    const r = gr();
    function s() {
      var u, c;
      (u = r.el) == null || u.focus(), (c = r.el) == null || c.scrollIntoView({
        block: "center"
      });
    }
    function d(u) {
      return Array.isArray(e.allowedYears) && e.allowedYears.length ? e.allowedYears.includes(u) : typeof e.allowedYears == "function" ? e.allowedYears(u) : !0;
    }
    return re(() => dt(S("div", {
      class: "v-date-picker-years",
      style: {
        height: pe(e.height)
      }
    }, [S("div", {
      class: "v-date-picker-years__content"
    }, [o.value.map((u, c) => {
      var v;
      const f = {
        ref: i.value === u.value ? r : void 0,
        active: i.value === u.value,
        color: i.value === u.value ? e.color : void 0,
        rounded: !0,
        text: u.text,
        disabled: u.isDisabled,
        variant: i.value === u.value ? "flat" : "text",
        onClick: () => {
          if (i.value === u.value) {
            n("update:modelValue", i.value);
            return;
          }
          i.value = u.value;
        }
      };
      return ((v = a.year) == null ? void 0 : v.call(a, {
        year: u,
        i: c,
        props: f
      })) ?? b(Le, Q({
        key: "month"
      }, f), null);
    })])]), [[Hn, {
      handler: s
    }, null, {
      once: !0
    }]])), {};
  }
}), lI = z({
  // TODO: implement in v3.5
  // calendarIcon: {
  //   type: String,
  //   default: '$calendar',
  // },
  // keyboardIcon: {
  //   type: String,
  //   default: '$edit',
  // },
  // inputMode: {
  //   type: String as PropType<'calendar' | 'keyboard'>,
  //   default: 'calendar',
  // },
  // inputText: {
  //   type: String,
  //   default: '$vuetify.datePicker.input.placeholder',
  // },
  // inputPlaceholder: {
  //   type: String,
  //   default: 'dd/mm/yyyy',
  // },
  header: {
    type: String,
    default: "$vuetify.datePicker.header"
  },
  headerColor: String,
  ...tp(),
  ...np({
    weeksInMonth: "static"
  }),
  ...tt(ap(), ["modelValue"]),
  ...tt(lp(), ["modelValue"]),
  ...Qr({
    title: "$vuetify.datePicker.title"
  }),
  modelValue: null
}, "VDatePicker"), iI = ne()({
  name: "VDatePicker",
  props: lI(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:month": (e) => !0,
    "update:year": (e) => !0,
    // 'update:inputMode': (date: any) => true,
    "update:viewMode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const l = wo(), {
      t: i
    } = nt(), {
      rtlClasses: o
    } = Et(), r = Ee(e, "modelValue", void 0, (Y) => ht(Y).map((L) => l.date(L)), (Y) => e.multiple ? Y : Y[0]), s = Ee(e, "viewMode"), d = x(() => {
      const Y = l.date(e.min);
      return e.min && l.isValid(Y) ? Y : null;
    }), u = x(() => {
      const Y = l.date(e.max);
      return e.max && l.isValid(Y) ? Y : null;
    }), c = x(() => {
      var H;
      const Y = l.date();
      let L = Y;
      return (H = r.value) != null && H[0] ? L = l.date(r.value[0]) : d.value && l.isBefore(Y, d.value) ? L = d.value : u.value && l.isAfter(Y, u.value) && (L = u.value), L && l.isValid(L) ? L : Y;
    }), f = R(() => e.headerColor ?? e.color), v = Ee(e, "month"), m = x({
      get: () => Number(v.value ?? l.getMonth(l.startOfMonth(c.value))),
      set: (Y) => v.value = Y
    }), h = Ee(e, "year"), g = x({
      get: () => Number(h.value ?? l.getYear(l.startOfYear(l.setMonth(c.value, m.value)))),
      set: (Y) => h.value = Y
    }), p = fe(!1), y = x(() => e.multiple && r.value.length > 1 ? i("$vuetify.datePicker.itemsSelected", r.value.length) : r.value[0] && l.isValid(r.value[0]) ? l.format(l.date(r.value[0]), "normalDateWithWeekday") : i(e.header)), _ = x(() => {
      let Y = l.date();
      return Y = l.setDate(Y, 1), Y = l.setMonth(Y, m.value), Y = l.setYear(Y, g.value), l.format(Y, "monthAndYear");
    }), E = R(() => `date-picker-header${p.value ? "-reverse" : ""}-transition`), k = x(() => {
      if (e.disabled) return !0;
      const Y = [];
      if (s.value !== "month")
        Y.push("prev", "next");
      else {
        let L = l.date();
        if (L = l.startOfMonth(L), L = l.setMonth(L, m.value), L = l.setYear(L, g.value), d.value) {
          const H = l.addDays(l.startOfMonth(L), -1);
          l.isAfter(d.value, H) && Y.push("prev");
        }
        if (u.value) {
          const H = l.addDays(l.endOfMonth(L), 1);
          l.isAfter(H, u.value) && Y.push("next");
        }
      }
      return Y;
    }), P = x(() => e.allowedYears || N), A = x(() => e.allowedMonths || V);
    function D(Y, L) {
      const H = e.allowedDates;
      if (typeof H != "function") return !0;
      const j = l.getDiff(L, Y, "days");
      for (let U = 0; U < j; U++)
        if (H(l.addDays(Y, U))) return !0;
      return !1;
    }
    function N(Y) {
      if (typeof e.allowedDates == "function") {
        const L = l.parseISO(`${Y}-01-01`);
        return D(L, l.endOfYear(L));
      }
      if (Array.isArray(e.allowedDates) && e.allowedDates.length) {
        for (const L of e.allowedDates)
          if (l.getYear(l.date(L)) === Y) return !0;
        return !1;
      }
      return !0;
    }
    function V(Y) {
      if (typeof e.allowedDates == "function") {
        const L = String(Y + 1).padStart(2, "0"), H = l.parseISO(`${g.value}-${L}-01`);
        return D(H, l.endOfMonth(H));
      }
      if (Array.isArray(e.allowedDates) && e.allowedDates.length) {
        for (const L of e.allowedDates)
          if (l.getYear(l.date(L)) === g.value && l.getMonth(l.date(L)) === Y) return !0;
        return !1;
      }
      return !0;
    }
    function I() {
      m.value < 11 ? m.value++ : (g.value++, m.value = 0, ee()), J();
    }
    function w() {
      m.value > 0 ? m.value-- : (g.value--, m.value = 11, ee()), J();
    }
    function T() {
      s.value = "month";
    }
    function M() {
      s.value = s.value === "months" ? "month" : "months";
    }
    function W() {
      s.value = s.value === "year" ? "month" : "year";
    }
    function J() {
      s.value === "months" && M();
    }
    function ee() {
      s.value === "year" && W();
    }
    return me(r, (Y, L) => {
      const H = ht(L), j = ht(Y);
      if (!j.length) return;
      const U = l.date(H[H.length - 1]), F = l.date(j[j.length - 1]), oe = l.getMonth(F), ve = l.getYear(F);
      oe !== m.value && (m.value = oe, J()), ve !== g.value && (g.value = ve, ee()), p.value = l.isBefore(U, F);
    }), re(() => {
      const Y = ui.filterProps(e), L = zu.filterProps(e), H = ju.filterProps(e), j = Wu.filterProps(e), U = tt(Uu.filterProps(e), ["modelValue"]), F = tt(Gu.filterProps(e), ["modelValue"]), oe = {
        color: f.value,
        header: y.value,
        transition: E.value
      };
      return b(ui, Q(Y, {
        color: f.value,
        class: ["v-date-picker", `v-date-picker--${s.value}`, {
          "v-date-picker--show-week": e.showWeek
        }, o.value, e.class],
        style: e.style
      }), {
        title: () => {
          var ve;
          return ((ve = a.title) == null ? void 0 : ve.call(a)) ?? S("div", {
            class: "v-date-picker__title"
          }, [i(e.title)]);
        },
        header: () => a.header ? b(Be, {
          defaults: {
            VDatePickerHeader: {
              ...oe
            }
          }
        }, {
          default: () => {
            var ve;
            return [(ve = a.header) == null ? void 0 : ve.call(a, oe)];
          }
        }) : b(ju, Q({
          key: "header"
        }, H, oe, {
          onClick: s.value !== "month" ? T : void 0
        }), {
          prepend: a.prepend,
          append: a.append
        }),
        default: () => S(ye, null, [b(zu, Q(L, {
          disabled: k.value,
          text: _.value,
          "onClick:next": I,
          "onClick:prev": w,
          "onClick:month": M,
          "onClick:year": W
        }), null), b(eo, {
          hideOnLeave: !0
        }, {
          default: () => [s.value === "months" ? b(Uu, Q({
            key: "date-picker-months"
          }, U, {
            modelValue: m.value,
            "onUpdate:modelValue": [(ve) => m.value = ve, J],
            min: d.value,
            max: u.value,
            year: g.value,
            allowedMonths: A.value
          }), {
            month: a.month
          }) : s.value === "year" ? b(Gu, Q({
            key: "date-picker-years"
          }, F, {
            modelValue: g.value,
            "onUpdate:modelValue": [(ve) => g.value = ve, ee],
            min: d.value,
            max: u.value,
            allowedYears: P.value
          }), {
            year: a.year
          }) : b(Wu, Q({
            key: "date-picker-month"
          }, j, {
            modelValue: r.value,
            "onUpdate:modelValue": (ve) => r.value = ve,
            month: m.value,
            "onUpdate:month": [(ve) => m.value = ve, J],
            year: g.value,
            "onUpdate:year": [(ve) => g.value = ve, ee],
            min: d.value,
            max: u.value
          }), {
            day: a.day
          })]
        })]),
        actions: a.actions
      });
    }), {};
  }
}), oI = z({
  actionText: String,
  bgColor: String,
  color: String,
  icon: Ve,
  image: String,
  justify: {
    type: String,
    default: "center"
  },
  headline: String,
  title: String,
  text: String,
  textWidth: {
    type: [Number, String],
    default: 500
  },
  href: String,
  to: String,
  ...ke(),
  ...kt(),
  ...sa({
    size: void 0
  }),
  ...We()
}, "VEmptyState"), rI = ne()({
  name: "VEmptyState",
  props: oI(),
  emits: {
    "click:action": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      themeClasses: l
    } = Ye(e), {
      backgroundColorClasses: i,
      backgroundColorStyles: o
    } = Xe(() => e.bgColor), {
      dimensionStyles: r
    } = Ct(e), {
      displayClasses: s
    } = Vn();
    function d(u) {
      n("click:action", u);
    }
    return re(() => {
      var g, p, y;
      const u = !!(a.actions || e.actionText), c = !!(a.headline || e.headline), f = !!(a.title || e.title), v = !!(a.text || e.text), m = !!(a.media || e.image || e.icon), h = e.size || (e.image ? 200 : 96);
      return S("div", {
        class: le(["v-empty-state", {
          [`v-empty-state--${e.justify}`]: !0
        }, l.value, i.value, s.value, e.class]),
        style: he([o.value, r.value, e.style])
      }, [m && S("div", {
        key: "media",
        class: "v-empty-state__media"
      }, [a.media ? b(Be, {
        key: "media-defaults",
        defaults: {
          VImg: {
            src: e.image,
            height: h
          },
          VIcon: {
            size: h,
            icon: e.icon
          }
        }
      }, {
        default: () => [a.media()]
      }) : S(ye, null, [e.image ? b(Sa, {
        key: "image",
        src: e.image,
        height: h
      }, null) : e.icon ? b(Ue, {
        key: "icon",
        color: e.color,
        size: h,
        icon: e.icon
      }, null) : void 0])]), c && S("div", {
        key: "headline",
        class: "v-empty-state__headline"
      }, [((g = a.headline) == null ? void 0 : g.call(a)) ?? e.headline]), f && S("div", {
        key: "title",
        class: "v-empty-state__title"
      }, [((p = a.title) == null ? void 0 : p.call(a)) ?? e.title]), v && S("div", {
        key: "text",
        class: "v-empty-state__text",
        style: {
          maxWidth: pe(e.textWidth)
        }
      }, [((y = a.text) == null ? void 0 : y.call(a)) ?? e.text]), a.default && S("div", {
        key: "content",
        class: "v-empty-state__content"
      }, [a.default()]), u && S("div", {
        key: "actions",
        class: "v-empty-state__actions"
      }, [b(Be, {
        defaults: {
          VBtn: {
            class: "v-empty-state__action-btn",
            color: e.color ?? "surface-variant",
            href: e.href,
            text: e.actionText,
            to: e.to
          }
        }
      }, {
        default: () => {
          var _;
          return [((_ = a.actions) == null ? void 0 : _.call(a, {
            props: {
              onClick: d
            }
          })) ?? b(Le, {
            onClick: d
          }, null)];
        }
      })])]);
    }), {};
  }
}), co = Symbol.for("vuetify:v-expansion-panel"), ip = z({
  ...ke(),
  ...ad()
}, "VExpansionPanelText"), Ku = ne()({
  name: "VExpansionPanelText",
  props: ip(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Me(co);
    if (!a) throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
    const {
      hasContent: l,
      onAfterLeave: i
    } = ld(e, a.isSelected);
    return re(() => b(Wr, {
      onAfterLeave: i
    }, {
      default: () => {
        var o;
        return [dt(S("div", {
          class: le(["v-expansion-panel-text", e.class]),
          style: he(e.style)
        }, [n.default && l.value && S("div", {
          class: "v-expansion-panel-text__wrapper"
        }, [(o = n.default) == null ? void 0 : o.call(n)])]), [[Nn, a.isSelected.value]])];
      }
    })), {};
  }
}), op = z({
  color: String,
  expandIcon: {
    type: Ve,
    default: "$expand"
  },
  collapseIcon: {
    type: Ve,
    default: "$collapse"
  },
  hideActions: Boolean,
  focusable: Boolean,
  static: Boolean,
  ripple: {
    type: [Boolean, Object],
    default: !1
  },
  readonly: Boolean,
  ...ke(),
  ...kt()
}, "VExpansionPanelTitle"), Yu = ne()({
  name: "VExpansionPanelTitle",
  directives: {
    vRipple: en
  },
  props: op(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Me(co);
    if (!a) throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
    const {
      backgroundColorClasses: l,
      backgroundColorStyles: i
    } = Xe(() => e.color), {
      dimensionStyles: o
    } = Ct(e), r = x(() => ({
      collapseIcon: e.collapseIcon,
      disabled: a.disabled.value,
      expanded: a.isSelected.value,
      expandIcon: e.expandIcon,
      readonly: e.readonly
    })), s = R(() => a.isSelected.value ? e.collapseIcon : e.expandIcon);
    return re(() => {
      var d;
      return dt(S("button", {
        class: le(["v-expansion-panel-title", {
          "v-expansion-panel-title--active": a.isSelected.value,
          "v-expansion-panel-title--focusable": e.focusable,
          "v-expansion-panel-title--static": e.static
        }, l.value, e.class]),
        style: he([i.value, o.value, e.style]),
        type: "button",
        tabindex: a.disabled.value ? -1 : void 0,
        disabled: a.disabled.value,
        "aria-expanded": a.isSelected.value,
        onClick: e.readonly ? void 0 : a.toggle
      }, [S("span", {
        class: "v-expansion-panel-title__overlay"
      }, null), (d = n.default) == null ? void 0 : d.call(n, r.value), !e.hideActions && b(Be, {
        defaults: {
          VIcon: {
            icon: s.value
          }
        }
      }, {
        default: () => {
          var u;
          return [S("span", {
            class: "v-expansion-panel-title__icon"
          }, [((u = n.actions) == null ? void 0 : u.call(n, r.value)) ?? b(Ue, null, null)])];
        }
      })]), [[en, e.ripple]]);
    }), {};
  }
}), rp = z({
  title: String,
  text: String,
  bgColor: String,
  ...Pt(),
  ...Nl(),
  ...ft(),
  ...Oe(),
  ...op(),
  ...ip()
}, "VExpansionPanel"), sI = ne()({
  name: "VExpansionPanel",
  props: rp(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Dl(e, co), {
      backgroundColorClasses: l,
      backgroundColorStyles: i
    } = Xe(() => e.bgColor), {
      elevationClasses: o
    } = Rt(e), {
      roundedClasses: r
    } = yt(e), s = R(() => (a == null ? void 0 : a.disabled.value) || e.disabled), d = x(() => a.group.items.value.reduce((f, v, m) => (a.group.selected.value.includes(v.id) && f.push(m), f), [])), u = x(() => {
      const f = a.group.items.value.findIndex((v) => v.id === a.id);
      return !a.isSelected.value && d.value.some((v) => v - f === 1);
    }), c = x(() => {
      const f = a.group.items.value.findIndex((v) => v.id === a.id);
      return !a.isSelected.value && d.value.some((v) => v - f === -1);
    });
    return at(co, a), re(() => {
      const f = !!(n.text || e.text), v = !!(n.title || e.title), m = Yu.filterProps(e), h = Ku.filterProps(e);
      return b(e.tag, {
        class: le(["v-expansion-panel", {
          "v-expansion-panel--active": a.isSelected.value,
          "v-expansion-panel--before-active": u.value,
          "v-expansion-panel--after-active": c.value,
          "v-expansion-panel--disabled": s.value
        }, r.value, l.value, e.class]),
        style: he([i.value, e.style])
      }, {
        default: () => [S("div", {
          class: le(["v-expansion-panel__shadow", ...o.value])
        }, null), b(Be, {
          defaults: {
            VExpansionPanelTitle: {
              ...m
            },
            VExpansionPanelText: {
              ...h
            }
          }
        }, {
          default: () => {
            var g;
            return [v && b(Yu, {
              key: "title"
            }, {
              default: () => [n.title ? n.title() : e.title]
            }), f && b(Ku, {
              key: "text"
            }, {
              default: () => [n.text ? n.text() : e.text]
            }), (g = n.default) == null ? void 0 : g.call(n)];
          }
        })]
      });
    }), {
      groupItem: a
    };
  }
}), uI = ["default", "accordion", "inset", "popout"], cI = z({
  flat: Boolean,
  ...Il(),
  ...mn(rp(), ["bgColor", "collapseIcon", "color", "eager", "elevation", "expandIcon", "focusable", "hideActions", "readonly", "ripple", "rounded", "tile", "static"]),
  ...We(),
  ...ke(),
  ...Oe(),
  variant: {
    type: String,
    default: "default",
    validator: (e) => uI.includes(e)
  }
}, "VExpansionPanels"), dI = ne()({
  name: "VExpansionPanels",
  props: cI(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      next: a,
      prev: l
    } = Wa(e, co), {
      themeClasses: i
    } = Ye(e), o = R(() => e.variant && `v-expansion-panels--variant-${e.variant}`);
    return gt({
      VExpansionPanel: {
        bgColor: R(() => e.bgColor),
        collapseIcon: R(() => e.collapseIcon),
        color: R(() => e.color),
        eager: R(() => e.eager),
        elevation: R(() => e.elevation),
        expandIcon: R(() => e.expandIcon),
        focusable: R(() => e.focusable),
        hideActions: R(() => e.hideActions),
        readonly: R(() => e.readonly),
        ripple: R(() => e.ripple),
        rounded: R(() => e.rounded),
        static: R(() => e.static)
      }
    }), re(() => b(e.tag, {
      class: le(["v-expansion-panels", {
        "v-expansion-panels--flat": e.flat,
        "v-expansion-panels--tile": e.tile
      }, i.value, o.value, e.class]),
      style: he(e.style)
    }, {
      default: () => {
        var r;
        return [(r = n.default) == null ? void 0 : r.call(n, {
          prev: l,
          next: a
        })];
      }
    })), {
      next: a,
      prev: l
    };
  }
}), fI = z({
  app: Boolean,
  appear: Boolean,
  extended: Boolean,
  layout: Boolean,
  offset: Boolean,
  modelValue: {
    type: Boolean,
    default: !0
  },
  ...tt(Kr({
    active: !0
  }), ["location", "spaced"]),
  ...Cl(),
  ...Va(),
  ...Wn({
    transition: "fab-transition"
  })
}, "VFab"), vI = ne()({
  name: "VFab",
  props: fI(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue"), l = fe(56), i = Z(), {
      resizeRef: o
    } = In((c) => {
      c.length && (l.value = c[0].target.clientHeight);
    }), r = R(() => e.app || e.absolute), s = x(() => {
      var c;
      return r.value ? ((c = e.location) == null ? void 0 : c.split(" ").shift()) ?? "bottom" : !1;
    }), d = x(() => {
      var c;
      return r.value ? ((c = e.location) == null ? void 0 : c.split(" ")[1]) ?? "end" : !1;
    });
    Gt(() => e.app, () => {
      const c = Vl({
        id: e.name,
        order: x(() => parseInt(e.order, 10)),
        position: s,
        layoutSize: x(() => e.layout ? l.value + 24 : 0),
        elementSize: x(() => l.value + 24),
        active: x(() => e.app && a.value),
        absolute: R(() => e.absolute)
      });
      ut(() => {
        i.value = c.layoutItemStyles.value;
      });
    });
    const u = Z();
    return re(() => {
      const c = Le.filterProps(e);
      return S("div", {
        ref: u,
        class: le(["v-fab", {
          "v-fab--absolute": e.absolute,
          "v-fab--app": !!e.app,
          "v-fab--extended": e.extended,
          "v-fab--offset": e.offset,
          [`v-fab--${s.value}`]: r.value,
          [`v-fab--${d.value}`]: r.value
        }, e.class]),
        style: he([e.app ? {
          ...i.value
        } : {
          height: e.absolute ? "100%" : "inherit"
        }, e.style])
      }, [S("div", {
        class: "v-fab__container"
      }, [b(Zt, {
        appear: e.appear,
        transition: e.transition
      }, {
        default: () => [dt(b(Le, Q({
          ref: o
        }, c, {
          active: void 0,
          location: void 0
        }), n), [[Nn, e.active]])]
      })])]);
    }), {};
  }
});
function mI() {
  function e(n) {
    var l, i;
    return [...((l = n.dataTransfer) == null ? void 0 : l.items) ?? []].filter((o) => o.kind === "file").map((o) => o.webkitGetAsEntry()).filter(Boolean).length > 0 || [...((i = n.dataTransfer) == null ? void 0 : i.files) ?? []].length > 0;
  }
  async function t(n) {
    var i, o;
    const a = [], l = [...((i = n.dataTransfer) == null ? void 0 : i.items) ?? []].filter((r) => r.kind === "file").map((r) => r.webkitGetAsEntry()).filter(Boolean);
    if (l.length)
      for (const r of l) {
        const s = await sp(r, up(".", r));
        a.push(...s.map((d) => d.file));
      }
    else
      a.push(...((o = n.dataTransfer) == null ? void 0 : o.files) ?? []);
    return a;
  }
  return {
    handleDrop: t,
    hasFilesOrFolders: e
  };
}
function sp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return new Promise((n, a) => {
    e.isFile ? e.file((i) => n([{
      file: i,
      path: t
    }]), a) : e.isDirectory && e.createReader().readEntries(async (i) => {
      const o = [];
      for (const r of i)
        o.push(...await sp(r, up(t, r)));
      n(o);
    });
  });
}
function up(e, t) {
  return t.isDirectory ? `${e}/${t.name}` : e;
}
const hI = z({
  filterByType: String
}, "file-accept");
function gI(e) {
  const t = x(() => e.filterByType ? yI(e.filterByType) : null);
  function n(a) {
    if (t.value) {
      const l = a.filter(t.value);
      return {
        accepted: l,
        rejected: a.filter((i) => !l.includes(i))
      };
    }
    return {
      accepted: a,
      rejected: []
    };
  }
  return {
    filterAccepted: n
  };
}
function yI(e) {
  const t = e.split(",").map((i) => i.trim().toLowerCase()), n = t.filter((i) => i.startsWith(".")), a = t.filter((i) => i.endsWith("/*")), l = t.filter((i) => !n.includes(i) && !a.includes(i));
  return (i) => {
    var s, d;
    const o = ((s = i.name.split(".").at(-1)) == null ? void 0 : s.toLowerCase()) ?? "", r = ((d = i.type.split("/").at(0)) == null ? void 0 : d.toLowerCase()) ?? "";
    return l.includes(i.type) || n.includes(`.${o}`) || a.includes(`${r}/*`);
  };
}
const bI = z({
  chips: Boolean,
  counter: Boolean,
  counterSizeString: {
    type: String,
    default: "$vuetify.fileInput.counterSize"
  },
  counterString: {
    type: String,
    default: "$vuetify.fileInput.counter"
  },
  hideInput: Boolean,
  multiple: Boolean,
  showSize: {
    type: [Boolean, Number, String],
    default: !1,
    validator: (e) => typeof e == "boolean" || [1e3, 1024].includes(Number(e))
  },
  truncateLength: {
    type: [Number, String],
    default: 22
  },
  ...Pa({
    prependIcon: "$file"
  }),
  modelValue: {
    type: [Array, Object],
    default: (e) => e.multiple ? [] : null,
    validator: (e) => ht(e).every((t) => t != null && typeof t == "object")
  },
  ...hI(),
  ...Io({
    clearable: !0
  })
}, "VFileInput"), pI = ne()({
  name: "VFileInput",
  inheritAttrs: !1,
  props: bI(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    rejected: (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: l
    } = t;
    const {
      t: i
    } = nt(), {
      filterAccepted: o
    } = gI(e), r = Ee(e, "modelValue", e.modelValue, (L) => ht(L), (L) => !e.multiple && Array.isArray(L) ? L[0] : L), {
      isFocused: s,
      focus: d,
      blur: u
    } = Ea(e), c = x(() => typeof e.showSize != "boolean" ? e.showSize : void 0), f = x(() => (r.value ?? []).reduce((L, H) => {
      let {
        size: j = 0
      } = H;
      return L + j;
    }, 0)), v = x(() => qf(f.value, c.value)), m = x(() => (r.value ?? []).map((L) => {
      const {
        name: H = "",
        size: j = 0
      } = L, U = T(H);
      return e.showSize ? `${U} (${qf(j, c.value)})` : U;
    })), h = x(() => {
      var H;
      const L = ((H = r.value) == null ? void 0 : H.length) ?? 0;
      return e.showSize ? i(e.counterSizeString, L, v.value) : i(e.counterString, L);
    }), g = Z(), p = Z(), y = Z(), _ = R(() => s.value || e.active), E = x(() => ["plain", "underlined"].includes(e.variant)), k = fe(!1), {
      handleDrop: P,
      hasFilesOrFolders: A
    } = mI();
    function D() {
      var L;
      y.value !== document.activeElement && ((L = y.value) == null || L.focus()), s.value || d();
    }
    function N(L) {
      var H;
      (H = y.value) == null || H.click();
    }
    function V(L) {
      a("mousedown:control", L);
    }
    function I(L) {
      var H;
      (H = y.value) == null || H.click(), a("click:control", L);
    }
    function w(L) {
      L.stopPropagation(), D(), He(() => {
        r.value = [], bo(e["onClick:clear"], L);
      });
    }
    function T(L) {
      if (L.length < Number(e.truncateLength)) return L;
      const H = Math.floor((Number(e.truncateLength) - 1) / 2);
      return `${L.slice(0, H)}${L.slice(L.length - H)}`;
    }
    function M(L) {
      L.preventDefault(), L.stopImmediatePropagation(), k.value = !0;
    }
    function W(L) {
      L.preventDefault(), k.value = !1;
    }
    async function J(L) {
      if (L.preventDefault(), L.stopImmediatePropagation(), k.value = !1, !y.value || !A(L)) return;
      const H = await P(L);
      Y(H);
    }
    function ee(L) {
      if (!(!L.target || L.repack))
        if (e.filterByType)
          Y([...L.target.files]);
        else {
          const H = L.target;
          r.value = [...H.files ?? []];
        }
    }
    function Y(L) {
      const H = new DataTransfer(), {
        accepted: j,
        rejected: U
      } = o(L);
      U.length && a("rejected", U);
      for (const oe of j)
        H.items.add(oe);
      y.value.files = H.files, r.value = [...H.files];
      const F = new Event("change", {
        bubbles: !0
      });
      F.repack = !0, y.value.dispatchEvent(F);
    }
    return me(r, (L) => {
      (!Array.isArray(L) || !L.length) && y.value && (y.value.value = "");
    }), re(() => {
      const L = !!(l.counter || e.counter), H = !!(L || l.details), [j, U] = za(n), {
        modelValue: F,
        ...oe
      } = Kt.filterProps(e), ve = {
        ...Fa.filterProps(e),
        "onClick:clear": w
      }, B = n.webkitdirectory !== void 0 && n.webkitdirectory !== !1 ? void 0 : e.filterByType ?? String(n.accept);
      return b(Kt, Q({
        ref: g,
        modelValue: e.multiple ? r.value : r.value[0],
        class: ["v-file-input", {
          "v-file-input--chips": !!e.chips,
          "v-file-input--dragging": k.value,
          "v-file-input--hide": e.hideInput,
          "v-input--plain-underlined": E.value
        }, e.class],
        style: e.style,
        "onClick:prepend": N
      }, j, oe, {
        centerAffix: !E.value,
        focused: s.value
      }), {
        ...l,
        default: (G) => {
          let {
            id: ie,
            isDisabled: de,
            isDirty: Se,
            isReadonly: Ce,
            isValid: C,
            hasDetails: O
          } = G;
          return b(Fa, Q({
            ref: p,
            prependIcon: e.prependIcon,
            onMousedown: V,
            onClick: I,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, ve, {
            id: ie.value,
            active: _.value || Se.value,
            dirty: Se.value || e.dirty,
            disabled: de.value,
            focused: s.value,
            details: O.value,
            error: C.value === !1,
            onDragover: M,
            onDrop: J
          }), {
            ...l,
            default: ($) => {
              var te;
              let {
                props: {
                  class: K,
                  ...X
                }
              } = $;
              return S(ye, null, [S("input", Q({
                ref: y,
                type: "file",
                accept: B,
                readonly: Ce.value,
                disabled: de.value,
                multiple: e.multiple,
                name: e.name,
                onClick: (ue) => {
                  ue.stopPropagation(), Ce.value && ue.preventDefault(), D();
                },
                onChange: ee,
                onDragleave: W,
                onFocus: D,
                onBlur: u
              }, X, U), null), S("div", {
                class: le(K)
              }, [!!((te = r.value) != null && te.length) && !e.hideInput && (l.selection ? l.selection({
                fileNames: m.value,
                totalBytes: f.value,
                totalBytesReadable: v.value
              }) : e.chips ? m.value.map((ue) => b(bi, {
                key: ue,
                size: "small",
                text: ue
              }, null)) : m.value.join(", "))])]);
            }
          });
        },
        details: H ? (G) => {
          var ie, de;
          return S(ye, null, [(ie = l.details) == null ? void 0 : ie.call(l, G), L && S(ye, null, [S("span", null, null), b(qr, {
            active: !!((de = r.value) != null && de.length),
            value: h.value,
            disabled: e.disabled
          }, l.counter)])]);
        } : void 0
      });
    }), Lt({}, g, p, y);
  }
}), SI = z({
  app: Boolean,
  color: String,
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...cn(),
  ...ke(),
  ...Pt(),
  ...Cl(),
  ...ft(),
  ...Oe({
    tag: "footer"
  }),
  ...We()
}, "VFooter"), wI = ne()({
  name: "VFooter",
  props: SI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Z(), {
      themeClasses: l
    } = Ye(e), {
      backgroundColorClasses: i,
      backgroundColorStyles: o
    } = Xe(() => e.color), {
      borderClasses: r
    } = hn(e), {
      elevationClasses: s
    } = Rt(e), {
      roundedClasses: d
    } = yt(e), u = fe(32), {
      resizeRef: c
    } = In((v) => {
      v.length && (u.value = v[0].target.clientHeight);
    }), f = x(() => e.height === "auto" ? u.value : parseInt(e.height, 10));
    return Gt(() => e.app, () => {
      const v = Vl({
        id: e.name,
        order: x(() => parseInt(e.order, 10)),
        position: R(() => "bottom"),
        layoutSize: f,
        elementSize: x(() => e.height === "auto" ? void 0 : f.value),
        active: R(() => e.app),
        absolute: R(() => e.absolute)
      });
      ut(() => {
        a.value = v.layoutItemStyles.value;
      });
    }), re(() => b(e.tag, {
      ref: c,
      class: le(["v-footer", l.value, i.value, r.value, s.value, d.value, e.class]),
      style: he([o.value, e.app ? a.value : {
        height: pe(e.height)
      }, e.style])
    }, n)), {};
  }
}), _I = z({
  ...ke(),
  ...NV()
}, "VForm"), xI = ne()({
  name: "VForm",
  props: _I(),
  emits: {
    "update:modelValue": (e) => !0,
    submit: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const l = DV(e), i = Z();
    function o(s) {
      s.preventDefault(), l.reset();
    }
    function r(s) {
      const d = s, u = l.validate();
      d.then = u.then.bind(u), d.catch = u.catch.bind(u), d.finally = u.finally.bind(u), a("submit", d), d.defaultPrevented || u.then((c) => {
        var v;
        let {
          valid: f
        } = c;
        f && ((v = i.value) == null || v.submit());
      }), d.preventDefault();
    }
    return re(() => {
      var s;
      return S("form", {
        ref: i,
        class: le(["v-form", e.class]),
        style: he(e.style),
        novalidate: !0,
        onReset: o,
        onSubmit: r
      }, [(s = n.default) == null ? void 0 : s.call(n, l)]);
    }), Lt(l, i);
  }
}), kI = z({
  disabled: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  ...td()
}, "VHover"), CI = ne()({
  name: "VHover",
  props: kI(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue"), {
      runOpenDelay: l,
      runCloseDelay: i
    } = nd(e, (o) => !e.disabled && (a.value = o));
    return () => {
      var o;
      return (o = n.default) == null ? void 0 : o.call(n, {
        isHovering: a.value,
        props: {
          onMouseenter: l,
          onMouseleave: i
        }
      });
    };
  }
}), VI = z({
  color: String,
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  side: {
    type: String,
    default: "end",
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  mode: {
    type: String,
    default: "intersect",
    validator: (e) => ["intersect", "manual"].includes(e)
  },
  margin: [Number, String],
  loadMoreText: {
    type: String,
    default: "$vuetify.infiniteScroll.loadMore"
  },
  emptyText: {
    type: String,
    default: "$vuetify.infiniteScroll.empty"
  },
  ...kt(),
  ...Oe()
}, "VInfiniteScroll"), Fv = Cn({
  name: "VInfiniteScrollIntersect",
  props: {
    side: {
      type: String,
      required: !0
    },
    rootMargin: String
  },
  emits: {
    intersect: (e, t) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const {
      intersectionRef: a,
      isIntersecting: l
    } = _o();
    return me(l, async (i) => {
      n("intersect", e.side, i);
    }), re(() => S("div", {
      class: "v-infinite-scroll-intersect",
      style: {
        "--v-infinite-margin-size": e.rootMargin
      },
      ref: a
    }, [ze("")])), {};
  }
}), EI = ne()({
  name: "VInfiniteScroll",
  props: VI(),
  emits: {
    load: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const l = Z(), i = fe("ok"), o = fe("ok"), r = x(() => pe(e.margin)), s = fe(!1);
    function d(P) {
      if (!l.value) return;
      const A = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      l.value[A] = P;
    }
    function u() {
      if (!l.value) return 0;
      const P = e.direction === "vertical" ? "scrollTop" : "scrollLeft";
      return l.value[P];
    }
    function c() {
      if (!l.value) return 0;
      const P = e.direction === "vertical" ? "scrollHeight" : "scrollWidth";
      return l.value[P];
    }
    function f() {
      if (!l.value) return 0;
      const P = e.direction === "vertical" ? "clientHeight" : "clientWidth";
      return l.value[P];
    }
    At(() => {
      l.value && (e.side === "start" ? d(c()) : e.side === "both" && d(c() / 2 - f() / 2));
    });
    function v(P, A) {
      P === "start" ? i.value = A : P === "end" ? o.value = A : P === "both" && (i.value = A, o.value = A);
    }
    function m(P) {
      return P === "start" ? i.value : o.value;
    }
    let h = 0;
    function g(P, A) {
      s.value = A, s.value && p(P);
    }
    function p(P) {
      if (e.mode !== "manual" && !s.value) return;
      const A = m(P);
      if (!l.value || ["empty", "loading"].includes(A)) return;
      h = c(), v(P, "loading");
      function D(N) {
        v(P, N), He(() => {
          N === "empty" || N === "error" || (N === "ok" && P === "start" && d(c() - h + u()), e.mode !== "manual" && He(() => {
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(() => {
                window.requestAnimationFrame(() => {
                  p(P);
                });
              });
            });
          }));
        });
      }
      a("load", {
        side: P,
        done: D
      });
    }
    const {
      t: y
    } = nt();
    function _(P, A) {
      var V, I, w, T, M;
      if (e.side !== P && e.side !== "both") return;
      const D = () => p(P), N = {
        side: P,
        props: {
          onClick: D,
          color: e.color
        }
      };
      return A === "error" ? (V = n.error) == null ? void 0 : V.call(n, N) : A === "empty" ? ((I = n.empty) == null ? void 0 : I.call(n, N)) ?? S("div", null, [y(e.emptyText)]) : e.mode === "manual" ? A === "loading" ? ((w = n.loading) == null ? void 0 : w.call(n, N)) ?? b(yl, {
        indeterminate: !0,
        color: e.color
      }, null) : ((T = n["load-more"]) == null ? void 0 : T.call(n, N)) ?? b(Le, {
        variant: "outlined",
        color: e.color,
        onClick: D
      }, {
        default: () => [y(e.loadMoreText)]
      }) : ((M = n.loading) == null ? void 0 : M.call(n, N)) ?? b(yl, {
        indeterminate: !0,
        color: e.color
      }, null);
    }
    const {
      dimensionStyles: E
    } = Ct(e);
    re(() => {
      const P = e.tag, A = e.side === "start" || e.side === "both", D = e.side === "end" || e.side === "both", N = e.mode === "intersect";
      return b(P, {
        ref: l,
        class: le(["v-infinite-scroll", `v-infinite-scroll--${e.direction}`, {
          "v-infinite-scroll--start": A,
          "v-infinite-scroll--end": D
        }]),
        style: he(E.value)
      }, {
        default: () => {
          var V;
          return [S("div", {
            class: "v-infinite-scroll__side"
          }, [_("start", i.value)]), A && N && b(Fv, {
            key: "start",
            side: "start",
            onIntersect: g,
            rootMargin: r.value
          }, null), (V = n.default) == null ? void 0 : V.call(n), D && N && b(Fv, {
            key: "end",
            side: "end",
            onIntersect: g,
            rootMargin: r.value
          }, null), S("div", {
            class: "v-infinite-scroll__side"
          }, [_("end", o.value)])];
        }
      });
    });
    function k(P) {
      const A = P ?? e.side;
      v(A, "ok"), He(() => {
        d(c() - h + u()), e.mode !== "manual" && He(() => {
          window.requestAnimationFrame(() => {
            window.requestAnimationFrame(() => {
              window.requestAnimationFrame(() => {
                A === "both" ? (p("start"), p("end")) : p(A);
              });
            });
          });
        });
      });
    }
    return {
      reset: k
    };
  }
}), cp = Symbol.for("vuetify:v-item-group"), PI = z({
  ...ke(),
  ...Il({
    selectedClass: "v-item--selected"
  }),
  ...Oe(),
  ...We()
}, "VItemGroup"), II = ne()({
  name: "VItemGroup",
  props: PI(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      isSelected: l,
      select: i,
      next: o,
      prev: r,
      selected: s
    } = Wa(e, cp);
    return () => b(e.tag, {
      class: le(["v-item-group", a.value, e.class]),
      style: he(e.style)
    }, {
      default: () => {
        var d;
        return [(d = n.default) == null ? void 0 : d.call(n, {
          isSelected: l,
          select: i,
          next: o,
          prev: r,
          selected: s.value
        })];
      }
    });
  }
}), NI = ne()({
  name: "VItem",
  props: Nl(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      isSelected: a,
      select: l,
      toggle: i,
      selectedClass: o,
      value: r,
      disabled: s
    } = Dl(e, cp);
    return () => {
      var d;
      return (d = n.default) == null ? void 0 : d.call(n, {
        isSelected: a.value,
        selectedClass: o.value,
        select: l,
        toggle: i,
        value: r.value,
        disabled: s.value
      });
    };
  }
}), DI = z({
  color: String,
  ...cn(),
  ...ke(),
  ...ft(),
  ...Oe({
    tag: "kbd"
  }),
  ...We(),
  ...Pt()
}, "VKbd"), AI = ne()({
  name: "VKbd",
  props: DI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      borderClasses: l
    } = hn(e), {
      roundedClasses: i
    } = yt(e), {
      backgroundColorClasses: o,
      backgroundColorStyles: r
    } = Xe(() => e.color), {
      elevationClasses: s
    } = Rt(e);
    return re(() => b(e.tag, {
      class: le(["v-kbd", a.value, o.value, l.value, s.value, i.value, e.class]),
      style: he([r.value, e.style])
    }, n)), {};
  }
}), TI = z({
  ...ke(),
  ...kt(),
  ...Hg()
}, "VLayout"), OI = ne()({
  name: "VLayout",
  props: TI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutClasses: a,
      layoutStyles: l,
      getLayoutItem: i,
      items: o,
      layoutRef: r
    } = jg(e), {
      dimensionStyles: s
    } = Ct(e);
    return re(() => {
      var d;
      return S("div", {
        ref: r,
        class: le([a.value, e.class]),
        style: he([s.value, l.value, e.style])
      }, [(d = n.default) == null ? void 0 : d.call(n)]);
    }), {
      getLayoutItem: i,
      items: o
    };
  }
}), $I = z({
  position: {
    type: String,
    required: !0
  },
  size: {
    type: [Number, String],
    default: 300
  },
  modelValue: Boolean,
  ...ke(),
  ...Cl()
}, "VLayoutItem"), BI = ne()({
  name: "VLayoutItem",
  props: $I(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      layoutItemStyles: a
    } = Vl({
      id: e.name,
      order: x(() => parseInt(e.order, 10)),
      position: R(() => e.position),
      elementSize: R(() => e.size),
      layoutSize: R(() => e.size),
      active: R(() => e.modelValue),
      absolute: R(() => e.absolute)
    });
    return () => {
      var l;
      return S("div", {
        class: le(["v-layout-item", e.class]),
        style: he([a.value, e.style])
      }, [(l = n.default) == null ? void 0 : l.call(n)]);
    };
  }
}), MI = z({
  modelValue: Boolean,
  options: {
    type: Object,
    // For more information on types, navigate to:
    // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
    default: () => ({
      root: void 0,
      rootMargin: void 0,
      threshold: void 0
    })
  },
  ...ke(),
  ...kt(),
  ...Oe(),
  ...Wn({
    transition: "fade-transition"
  })
}, "VLazy"), RI = ne()({
  name: "VLazy",
  directives: {
    vIntersect: Hn
  },
  props: MI(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: a
    } = Ct(e), l = Ee(e, "modelValue");
    function i(o) {
      l.value || (l.value = o);
    }
    return re(() => dt(b(e.tag, {
      class: le(["v-lazy", e.class]),
      style: he([a.value, e.style])
    }, {
      default: () => [l.value && b(Zt, {
        transition: e.transition,
        appear: !0
      }, {
        default: () => {
          var o;
          return [(o = n.default) == null ? void 0 : o.call(n)];
        }
      })]
    }), [[Hn, {
      handler: i,
      options: e.options
    }, null]])), {};
  }
}), LI = z({
  locale: String,
  fallbackLocale: String,
  messages: Object,
  rtl: {
    type: Boolean,
    default: void 0
  },
  ...ke()
}, "VLocaleProvider"), FI = ne()({
  name: "VLocaleProvider",
  props: LI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      rtlClasses: a
    } = yk(e);
    return re(() => {
      var l;
      return S("div", {
        class: le(["v-locale-provider", a.value, e.class]),
        style: he(e.style)
      }, [(l = n.default) == null ? void 0 : l.call(n)]);
    }), {};
  }
}), HI = z({
  scrollable: Boolean,
  ...ke(),
  ...kt(),
  ...Oe({
    tag: "main"
  })
}, "VMain"), zI = ne()({
  name: "VMain",
  props: HI(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: a
    } = Ct(e), {
      mainStyles: l
    } = zg(), {
      ssrBootStyles: i
    } = El();
    return re(() => b(e.tag, {
      class: le(["v-main", {
        "v-main--scrollable": e.scrollable
      }, e.class]),
      style: he([l.value, i.value, a.value, e.style])
    }, {
      default: () => {
        var o, r;
        return [e.scrollable ? S("div", {
          class: "v-main__scroller"
        }, [(o = n.default) == null ? void 0 : o.call(n)]) : (r = n.default) == null ? void 0 : r.call(n)];
      }
    })), {};
  }
});
function jI(e) {
  let {
    rootEl: t,
    isSticky: n,
    layoutItemStyles: a
  } = e;
  const l = fe(!1), i = fe(0), o = x(() => {
    const d = typeof l.value == "boolean" ? "top" : l.value;
    return [n.value ? {
      top: "auto",
      bottom: "auto",
      height: void 0
    } : void 0, l.value ? {
      [d]: pe(i.value)
    } : {
      top: a.value.top
    }];
  });
  At(() => {
    me(n, (d) => {
      d ? window.addEventListener("scroll", s, {
        passive: !0
      }) : window.removeEventListener("scroll", s);
    }, {
      immediate: !0
    });
  }), Wt(() => {
    window.removeEventListener("scroll", s);
  });
  let r = 0;
  function s() {
    const d = r > window.scrollY ? "up" : "down", u = t.value.getBoundingClientRect(), c = parseFloat(a.value.top ?? 0), f = window.scrollY - Math.max(0, i.value - c), v = u.height + Math.max(i.value, c) - window.scrollY - window.innerHeight, m = parseFloat(getComputedStyle(t.value).getPropertyValue("--v-body-scroll-y")) || 0;
    u.height < window.innerHeight - c ? (l.value = "top", i.value = c) : d === "up" && l.value === "bottom" || d === "down" && l.value === "top" ? (i.value = window.scrollY + u.top - m, l.value = !0) : d === "down" && v <= 0 ? (i.value = 0, l.value = "bottom") : d === "up" && f <= 0 && (m ? l.value !== "top" && (i.value = -f + m + c, l.value = "top") : (i.value = u.top + f, l.value = "top")), r = window.scrollY;
  }
  return {
    isStuck: l,
    stickyStyles: o
  };
}
const WI = 100, UI = 20;
function Hv(e) {
  return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * 1.41421356237;
}
function zv(e) {
  if (e.length < 2)
    return 0;
  if (e.length === 2)
    return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t);
  let t = 0;
  for (let n = e.length - 1; n > 0; n--) {
    if (e[n].t === e[n - 1].t)
      continue;
    const a = Hv(t), l = (e[n].d - e[n - 1].d) / (e[n].t - e[n - 1].t);
    t += (l - a) * Math.abs(l), n === e.length - 1 && (t *= 0.5);
  }
  return Hv(t) * 1e3;
}
function GI() {
  const e = {};
  function t(l) {
    Array.from(l.changedTouches).forEach((i) => {
      (e[i.identifier] ?? (e[i.identifier] = new vg(UI))).push([l.timeStamp, i]);
    });
  }
  function n(l) {
    Array.from(l.changedTouches).forEach((i) => {
      delete e[i.identifier];
    });
  }
  function a(l) {
    var d;
    const i = (d = e[l]) == null ? void 0 : d.values().reverse();
    if (!i)
      throw new Error(`No samples for touch id ${l}`);
    const o = i[0], r = [], s = [];
    for (const u of i) {
      if (o[0] - u[0] > WI) break;
      r.push({
        t: u[0],
        d: u[1].clientX
      }), s.push({
        t: u[0],
        d: u[1].clientY
      });
    }
    return {
      x: zv(r),
      y: zv(s),
      get direction() {
        const {
          x: u,
          y: c
        } = this, [f, v] = [Math.abs(u), Math.abs(c)];
        return f > v && u >= 0 ? "right" : f > v && u <= 0 ? "left" : v > f && c >= 0 ? "down" : v > f && c <= 0 ? "up" : KI();
      }
    };
  }
  return {
    addMovement: t,
    endTouch: n,
    getVelocity: a
  };
}
function KI() {
  throw new Error();
}
function YI(e) {
  let {
    el: t,
    isActive: n,
    isTemporary: a,
    width: l,
    touchless: i,
    position: o
  } = e;
  At(() => {
    window.addEventListener("touchstart", y, {
      passive: !0
    }), window.addEventListener("touchmove", _, {
      passive: !1
    }), window.addEventListener("touchend", E, {
      passive: !0
    });
  }), Wt(() => {
    window.removeEventListener("touchstart", y), window.removeEventListener("touchmove", _), window.removeEventListener("touchend", E);
  });
  const r = x(() => ["left", "right"].includes(o.value)), {
    addMovement: s,
    endTouch: d,
    getVelocity: u
  } = GI();
  let c = !1;
  const f = fe(!1), v = fe(0), m = fe(0);
  let h;
  function g(P, A) {
    return (o.value === "left" ? P : o.value === "right" ? document.documentElement.clientWidth - P : o.value === "top" ? P : o.value === "bottom" ? document.documentElement.clientHeight - P : Hl()) - (A ? l.value : 0);
  }
  function p(P) {
    let A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const D = o.value === "left" ? (P - m.value) / l.value : o.value === "right" ? (document.documentElement.clientWidth - P - m.value) / l.value : o.value === "top" ? (P - m.value) / l.value : o.value === "bottom" ? (document.documentElement.clientHeight - P - m.value) / l.value : Hl();
    return A ? ot(D) : D;
  }
  function y(P) {
    if (i.value) return;
    const A = P.changedTouches[0].clientX, D = P.changedTouches[0].clientY, N = 25, V = o.value === "left" ? A < N : o.value === "right" ? A > document.documentElement.clientWidth - N : o.value === "top" ? D < N : o.value === "bottom" ? D > document.documentElement.clientHeight - N : Hl(), I = n.value && (o.value === "left" ? A < l.value : o.value === "right" ? A > document.documentElement.clientWidth - l.value : o.value === "top" ? D < l.value : o.value === "bottom" ? D > document.documentElement.clientHeight - l.value : Hl());
    (V || I || n.value && a.value) && (h = [A, D], m.value = g(r.value ? A : D, n.value), v.value = p(r.value ? A : D), c = m.value > -20 && m.value < 80, d(P), s(P));
  }
  function _(P) {
    const A = P.changedTouches[0].clientX, D = P.changedTouches[0].clientY;
    if (c) {
      if (!P.cancelable) {
        c = !1;
        return;
      }
      const V = Math.abs(A - h[0]), I = Math.abs(D - h[1]);
      (r.value ? V > I && V > 3 : I > V && I > 3) ? (f.value = !0, c = !1) : (r.value ? I : V) > 3 && (c = !1);
    }
    if (!f.value) return;
    P.preventDefault(), s(P);
    const N = p(r.value ? A : D, !1);
    v.value = Math.max(0, Math.min(1, N)), N > 1 ? m.value = g(r.value ? A : D, !0) : N < 0 && (m.value = g(r.value ? A : D, !1));
  }
  function E(P) {
    if (c = !1, !f.value) return;
    s(P), f.value = !1;
    const A = u(P.changedTouches[0].identifier), D = Math.abs(A.x), N = Math.abs(A.y);
    (r.value ? D > N && D > 400 : N > D && N > 3) ? n.value = A.direction === ({
      left: "right",
      right: "left",
      top: "down",
      bottom: "up"
    }[o.value] || Hl()) : n.value = v.value > 0.5;
  }
  const k = x(() => f.value ? {
    transform: o.value === "left" ? `translateX(calc(-100% + ${v.value * l.value}px))` : o.value === "right" ? `translateX(calc(100% - ${v.value * l.value}px))` : o.value === "top" ? `translateY(calc(-100% + ${v.value * l.value}px))` : o.value === "bottom" ? `translateY(calc(100% - ${v.value * l.value}px))` : Hl(),
    transition: "none"
  } : void 0);
  return Gt(f, () => {
    var D, N;
    const P = ((D = t.value) == null ? void 0 : D.style.transform) ?? null, A = ((N = t.value) == null ? void 0 : N.style.transition) ?? null;
    ut(() => {
      var V, I, w, T;
      (I = t.value) == null || I.style.setProperty("transform", ((V = k.value) == null ? void 0 : V.transform) || "none"), (T = t.value) == null || T.style.setProperty("transition", ((w = k.value) == null ? void 0 : w.transition) || null);
    }), Dt(() => {
      var V, I;
      (V = t.value) == null || V.style.setProperty("transform", P), (I = t.value) == null || I.style.setProperty("transition", A);
    });
  }), {
    isDragging: f,
    dragProgress: v,
    dragStyles: k
  };
}
function Hl() {
  throw new Error();
}
const qI = ["start", "end", "left", "right", "top", "bottom"], XI = z({
  color: String,
  disableResizeWatcher: Boolean,
  disableRouteWatcher: Boolean,
  expandOnHover: Boolean,
  floating: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  },
  permanent: Boolean,
  rail: {
    type: Boolean,
    default: null
  },
  railWidth: {
    type: [Number, String],
    default: 56
  },
  scrim: {
    type: [Boolean, String],
    default: !0
  },
  image: String,
  temporary: Boolean,
  persistent: Boolean,
  touchless: Boolean,
  width: {
    type: [Number, String],
    default: 256
  },
  location: {
    type: String,
    default: "start",
    validator: (e) => qI.includes(e)
  },
  sticky: Boolean,
  ...cn(),
  ...ke(),
  ...td(),
  ...kl({
    mobile: null
  }),
  ...Pt(),
  ...Cl(),
  ...ft(),
  ...Oe({
    tag: "nav"
  }),
  ...We()
}, "VNavigationDrawer"), JI = ne()({
  name: "VNavigationDrawer",
  props: XI(),
  emits: {
    "update:modelValue": (e) => !0,
    "update:rail": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: l
    } = t;
    const {
      isRtl: i
    } = Et(), {
      themeClasses: o
    } = Ye(e), {
      borderClasses: r
    } = hn(e), {
      backgroundColorClasses: s,
      backgroundColorStyles: d
    } = Xe(() => e.color), {
      elevationClasses: u
    } = Rt(e), {
      displayClasses: c,
      mobile: f
    } = Vn(e), {
      roundedClasses: v
    } = yt(e), m = ey(), h = Ee(e, "modelValue", null, (H) => !!H), {
      ssrBootStyles: g
    } = El(), {
      scopeId: p
    } = Tl(), y = Z(), _ = fe(!1), {
      runOpenDelay: E,
      runCloseDelay: k
    } = nd(e, (H) => {
      _.value = H;
    }), P = x(() => e.rail && e.expandOnHover && _.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width)), A = x(() => yu(e.location, i.value)), D = R(() => e.persistent), N = x(() => !e.permanent && (f.value || e.temporary)), V = x(() => e.sticky && !N.value && A.value !== "bottom");
    Gt(() => e.expandOnHover && e.rail != null, () => {
      me(_, (H) => a("update:rail", !H));
    }), Gt(() => !e.disableResizeWatcher, () => {
      me(N, (H) => !e.permanent && He(() => h.value = !H));
    }), Gt(() => !e.disableRouteWatcher && !!m, () => {
      me(m.currentRoute, () => N.value && (h.value = !1));
    }), me(() => e.permanent, (H) => {
      H && (h.value = !0);
    }), e.modelValue == null && !N.value && (h.value = e.permanent || !f.value);
    const {
      isDragging: I,
      dragProgress: w
    } = YI({
      el: y,
      isActive: h,
      isTemporary: N,
      width: P,
      touchless: R(() => e.touchless),
      position: A
    }), T = x(() => {
      const H = N.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : P.value;
      return I.value ? H * w.value : H;
    }), {
      layoutItemStyles: M,
      layoutItemScrimStyles: W
    } = Vl({
      id: e.name,
      order: x(() => parseInt(e.order, 10)),
      position: A,
      layoutSize: T,
      elementSize: P,
      active: vl(h),
      disableTransitions: R(() => I.value),
      absolute: x(() => (
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        e.absolute || V.value && typeof J.value != "string"
      ))
    }), {
      isStuck: J,
      stickyStyles: ee
    } = jI({
      rootEl: y,
      isSticky: V,
      layoutItemStyles: M
    }), Y = Xe(() => typeof e.scrim == "string" ? e.scrim : null), L = x(() => ({
      ...I.value ? {
        opacity: w.value * 0.2,
        transition: "none"
      } : void 0,
      ...W.value
    }));
    return gt({
      VList: {
        bgColor: "transparent"
      }
    }), re(() => {
      const H = l.image || e.image;
      return S(ye, null, [b(e.tag, Q({
        ref: y,
        onMouseenter: E,
        onMouseleave: k,
        class: ["v-navigation-drawer", `v-navigation-drawer--${A.value}`, {
          "v-navigation-drawer--expand-on-hover": e.expandOnHover,
          "v-navigation-drawer--floating": e.floating,
          "v-navigation-drawer--is-hovering": _.value,
          "v-navigation-drawer--rail": e.rail,
          "v-navigation-drawer--temporary": N.value,
          "v-navigation-drawer--persistent": D.value,
          "v-navigation-drawer--active": h.value,
          "v-navigation-drawer--sticky": V.value
        }, o.value, s.value, r.value, c.value, u.value, v.value, e.class],
        style: [d.value, M.value, g.value, ee.value, e.style]
      }, p, n), {
        default: () => {
          var j, U, F;
          return [H && S("div", {
            key: "image",
            class: "v-navigation-drawer__img"
          }, [l.image ? b(Be, {
            key: "image-defaults",
            disabled: !e.image,
            defaults: {
              VImg: {
                alt: "",
                cover: !0,
                height: "inherit",
                src: e.image
              }
            }
          }, l.image) : b(Sa, {
            key: "image-img",
            alt: "",
            cover: !0,
            height: "inherit",
            src: e.image
          }, null)]), l.prepend && S("div", {
            class: "v-navigation-drawer__prepend"
          }, [(j = l.prepend) == null ? void 0 : j.call(l)]), S("div", {
            class: "v-navigation-drawer__content"
          }, [(U = l.default) == null ? void 0 : U.call(l)]), l.append && S("div", {
            class: "v-navigation-drawer__append"
          }, [(F = l.append) == null ? void 0 : F.call(l)])];
        }
      }), b(Ma, {
        name: "fade-transition"
      }, {
        default: () => [N.value && (I.value || h.value) && !!e.scrim && S("div", Q({
          class: ["v-navigation-drawer__scrim", Y.backgroundColorClasses.value],
          style: [L.value, Y.backgroundColorStyles.value],
          onClick: () => {
            D.value || (h.value = !1);
          }
        }, p), null)]
      })]);
    }), {
      isStuck: J
    };
  }
}), ZI = Cn({
  name: "VNoSsr",
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = zy();
    return () => {
      var l;
      return a.value && ((l = n.default) == null ? void 0 : l.call(n));
    };
  }
}), QI = 50, eN = 500;
function tN(e) {
  let {
    toggleUpDown: t
  } = e, n = -1, a = -1;
  Dt(i);
  function l(r) {
    i(), o(r), window.addEventListener("pointerup", i), document.addEventListener("blur", i), n = window.setTimeout(() => {
      a = window.setInterval(() => o(r), QI);
    }, eN);
  }
  function i() {
    window.clearTimeout(n), window.clearInterval(a), window.removeEventListener("pointerup", i), document.removeEventListener("blur", i);
  }
  function o(r) {
    t(r === "up");
  }
  return {
    holdStart: l,
    holdStop: i
  };
}
const nN = z({
  controlVariant: {
    type: String,
    default: "default"
  },
  inset: Boolean,
  hideInput: Boolean,
  modelValue: {
    type: Number,
    default: null
  },
  min: {
    type: Number,
    default: Number.MIN_SAFE_INTEGER
  },
  max: {
    type: Number,
    default: Number.MAX_SAFE_INTEGER
  },
  step: {
    type: Number,
    default: 1
  },
  precision: {
    type: Number,
    default: 0
  },
  minFractionDigits: {
    type: Number,
    default: null
  },
  decimalSeparator: {
    type: String,
    validator: (e) => !e || e.length === 1
  },
  ...tt(No(), ["modelValue", "validationValue"])
}, "VNumberInput"), aN = ne()({
  name: "VNumberInput",
  props: {
    ...nN()
  },
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Z(), {
      holdStart: l,
      holdStop: i
    } = tN({
      toggleUpDown: N
    }), o = yi(e), r = x(() => o.isDisabled.value || o.isReadonly.value), s = fe(e.focused), {
      decimalSeparator: d
    } = nt(), u = x(() => {
      var j;
      return ((j = e.decimalSeparator) == null ? void 0 : j[0]) || d.value;
    });
    function c(j) {
      let U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e.precision, F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      const oe = U == null ? String(j) : j.toFixed(U);
      if (s.value && F)
        return Number(oe).toString().replace(".", u.value);
      if (e.minFractionDigits === null || U !== null && U < e.minFractionDigits)
        return oe.replace(".", u.value);
      let [ve, _e] = oe.split(".");
      return _e = (_e ?? "").padEnd(e.minFractionDigits, "0").replace(new RegExp(`(?<=\\d{${e.minFractionDigits}})0+$`, "g"), ""), [ve, _e].filter(Boolean).join(u.value);
    }
    const f = Ee(e, "modelValue", null, (j) => j ?? null, (j) => j == null ? j ?? null : ot(Number(j), e.min, e.max)), v = fe(null);
    ut(() => {
      s.value && !r.value && Number(v.value) === f.value || (f.value == null ? v.value = null : isNaN(f.value) || (v.value = c(f.value)));
    });
    const m = x({
      get: () => v.value,
      set(j) {
        if (j === null || j === "") {
          f.value = null, v.value = null;
          return;
        }
        const U = Number(j.replace(u.value, "."));
        !isNaN(U) && U <= e.max && U >= e.min && (f.value = U, v.value = j);
      }
    }), h = x(() => r.value ? !1 : (f.value ?? 0) + e.step <= e.max), g = x(() => r.value ? !1 : (f.value ?? 0) - e.step >= e.min), p = x(() => e.hideInput ? "stacked" : e.controlVariant), y = R(() => p.value === "split" ? "$plus" : "$collapse"), _ = R(() => p.value === "split" ? "$minus" : "$expand"), E = R(() => p.value === "split" ? "default" : "small"), k = R(() => p.value === "stacked" ? "auto" : "100%"), P = {
      props: {
        onClick: w,
        onPointerup: T,
        onPointerdown: M,
        onPointercancel: T
      }
    }, A = {
      props: {
        onClick: w,
        onPointerup: T,
        onPointerdown: W,
        onPointercancel: T
      }
    };
    me(() => e.precision, () => ee()), me(() => e.minFractionDigits, () => ee()), At(() => {
      J();
    });
    function D(j) {
      if (j == null) return 0;
      const U = j.toString(), F = U.indexOf(".");
      return ~F ? U.length - F : 0;
    }
    function N() {
      let j = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      if (r.value) return;
      if (f.value == null) {
        m.value = c(ot(0, e.min, e.max));
        return;
      }
      let U = Math.max(D(f.value), D(e.step));
      e.precision != null && (U = Math.max(U, e.precision)), j ? h.value && (m.value = c(f.value + e.step, U)) : g.value && (m.value = c(f.value - e.step, U));
    }
    function V(j) {
      var G;
      if (!j.data) return;
      const U = j.target, {
        value: F,
        selectionStart: oe,
        selectionEnd: ve
      } = U ?? {}, _e = F ? F.slice(0, oe) + j.data + F.slice(ve) : j.data, B = Dx(_e, e.precision, u.value);
      if (new RegExp(`^-?\\d*${yr(u.value)}?\\d*$`).test(_e) || (j.preventDefault(), U.value = B), e.precision != null) {
        if (((G = _e.split(u.value)[1]) == null ? void 0 : G.length) > e.precision) {
          j.preventDefault(), U.value = B;
          const ie = (oe ?? 0) + j.data.length;
          U.setSelectionRange(ie, ie);
        }
        e.precision === 0 && _e.includes(u.value) && (j.preventDefault(), U.value = B);
      }
    }
    async function I(j) {
      ["Enter", "ArrowLeft", "ArrowRight", "Backspace", "Delete", "Tab"].includes(j.key) || j.ctrlKey || ["ArrowDown", "ArrowUp"].includes(j.key) && (j.preventDefault(), j.stopPropagation(), J(), await He(), j.key === "ArrowDown" ? N(!1) : N());
    }
    function w(j) {
      j.stopPropagation();
    }
    function T(j) {
      const U = j.currentTarget;
      U == null || U.releasePointerCapture(j.pointerId), j.preventDefault(), i();
    }
    function M(j) {
      const U = j.currentTarget;
      U == null || U.setPointerCapture(j.pointerId), j.preventDefault(), j.stopPropagation(), l("up");
    }
    function W(j) {
      const U = j.currentTarget;
      U == null || U.setPointerCapture(j.pointerId), j.preventDefault(), j.stopPropagation(), l("down");
    }
    function J() {
      if (r.value || !a.value) return;
      const j = a.value.value, U = Number(j.replace(u.value, "."));
      j && !isNaN(U) ? m.value = c(ot(U, e.min, e.max)) : m.value = null;
    }
    function ee() {
      r.value || (m.value = f.value !== null && !isNaN(f.value) ? c(f.value, e.precision, !1) : null);
    }
    function Y() {
      if (!r.value) {
        if (f.value === null || isNaN(f.value)) {
          m.value = null;
          return;
        }
        m.value = f.value.toString().replace(".", u.value);
      }
    }
    function L() {
      Y();
    }
    function H() {
      J();
    }
    return re(() => {
      const {
        modelValue: j,
        type: U,
        ...F
      } = wa.filterProps(e);
      function oe() {
        return n.increment ? b(Be, {
          key: "increment-defaults",
          defaults: {
            VBtn: {
              disabled: !h.value,
              height: k.value,
              size: E.value,
              icon: y.value,
              variant: "text"
            }
          }
        }, {
          default: () => [n.increment(P)]
        }) : b(Le, {
          "aria-hidden": "true",
          "data-testid": "increment",
          disabled: !h.value,
          height: k.value,
          icon: y.value,
          key: "increment-btn",
          onClick: w,
          onPointerdown: M,
          onPointerup: T,
          onPointercancel: T,
          size: E.value,
          variant: "text",
          tabindex: "-1"
        }, null);
      }
      function ve() {
        return n.decrement ? b(Be, {
          key: "decrement-defaults",
          defaults: {
            VBtn: {
              disabled: !g.value,
              height: k.value,
              size: E.value,
              icon: _.value,
              variant: "text"
            }
          }
        }, {
          default: () => [n.decrement(A)]
        }) : b(Le, {
          "aria-hidden": "true",
          "data-testid": "decrement",
          disabled: !g.value,
          height: k.value,
          icon: _.value,
          key: "decrement-btn",
          onClick: w,
          onPointerdown: W,
          onPointerup: T,
          onPointercancel: T,
          size: E.value,
          variant: "text",
          tabindex: "-1"
        }, null);
      }
      function _e() {
        return S("div", {
          class: "v-number-input__control"
        }, [ve(), b(Sn, {
          vertical: p.value !== "stacked"
        }, null), oe()]);
      }
      function B() {
        return !e.hideInput && !e.inset ? b(Sn, {
          vertical: !0
        }, null) : void 0;
      }
      const G = p.value === "split" ? S("div", {
        class: "v-number-input__control"
      }, [b(Sn, {
        vertical: !0
      }, null), oe()]) : e.reverse || p.value === "hidden" ? void 0 : S(ye, null, [B(), _e()]), ie = n["append-inner"] || G, de = p.value === "split" ? S("div", {
        class: "v-number-input__control"
      }, [ve(), b(Sn, {
        vertical: !0
      }, null)]) : e.reverse && p.value !== "hidden" ? S(ye, null, [_e(), B()]) : void 0, Se = n["prepend-inner"] || de;
      return b(wa, Q({
        ref: a
      }, F, {
        modelValue: m.value,
        "onUpdate:modelValue": (Ce) => m.value = Ce,
        focused: s.value,
        "onUpdate:focused": (Ce) => s.value = Ce,
        validationValue: f.value,
        onBeforeinput: V,
        onFocus: L,
        onBlur: H,
        onKeydown: I,
        class: ["v-number-input", {
          "v-number-input--default": p.value === "default",
          "v-number-input--hide-input": e.hideInput,
          "v-number-input--inset": e.inset,
          "v-number-input--reverse": e.reverse,
          "v-number-input--split": p.value === "split",
          "v-number-input--stacked": p.value === "stacked"
        }, e.class],
        style: e.style,
        inputmode: "decimal"
      }), {
        ...n,
        "append-inner": ie ? function() {
          var $;
          for (var Ce = arguments.length, C = new Array(Ce), O = 0; O < Ce; O++)
            C[O] = arguments[O];
          return S(ye, null, [($ = n["append-inner"]) == null ? void 0 : $.call(n, ...C), G]);
        } : void 0,
        "prepend-inner": Se ? function() {
          var $;
          for (var Ce = arguments.length, C = new Array(Ce), O = 0; O < Ce; O++)
            C[O] = arguments[O];
          return S(ye, null, [de, ($ = n["prepend-inner"]) == null ? void 0 : $.call(n, ...C)]);
        } : void 0
      });
    }), Lt({}, a);
  }
}), lN = z({
  autofocus: Boolean,
  divider: String,
  focusAll: Boolean,
  label: {
    type: String,
    default: "$vuetify.input.otp"
  },
  length: {
    type: [Number, String],
    default: 6
  },
  modelValue: {
    type: [Number, String],
    default: void 0
  },
  placeholder: String,
  type: {
    type: String,
    default: "number"
  },
  ...kt(),
  ...Eo(),
  ...mn(Io({
    variant: "outlined"
  }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])
}, "VOtpInput"), iN = ne()({
  name: "VOtpInput",
  props: lN(),
  emits: {
    finish: (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: l
    } = t;
    const {
      dimensionStyles: i
    } = Ct(e), {
      isFocused: o,
      focus: r,
      blur: s
    } = Ea(e), d = Ee(e, "modelValue", "", (V) => V == null ? [] : String(V).split(""), (V) => V.join("")), {
      t: u
    } = nt(), c = x(() => Number(e.length)), f = x(() => Array(c.value).fill(0)), v = Z(-1), m = Z(), h = Z([]), g = x(() => h.value[v.value]);
    let p = !1;
    Gt(() => e.autofocus, () => {
      const V = Jl();
      V.run(() => {
        const {
          intersectionRef: I,
          isIntersecting: w
        } = _o();
        ut(() => {
          I.value = h.value[0];
        }), me(w, (T) => {
          var M;
          T && ((M = I.value) == null || M.focus(), V.stop());
        });
      });
    });
    function y() {
      if (N(g.value.value)) {
        g.value.value = "";
        return;
      }
      if (p) return;
      const V = d.value.slice(), I = g.value.value;
      V[v.value] = I;
      let w = null;
      v.value > d.value.length ? w = d.value.length + 1 : v.value + 1 !== c.value && (w = "next"), d.value = V, w && cl(m.value, w);
    }
    function _() {
      p = !1, y();
    }
    function E(V) {
      const I = d.value.slice(), w = v.value;
      let T = null;
      ["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(V.key) && (V.preventDefault(), V.key === "ArrowLeft" ? T = "prev" : V.key === "ArrowRight" ? T = "next" : ["Backspace", "Delete"].includes(V.key) && (I[v.value] = "", d.value = I, v.value > 0 && V.key === "Backspace" ? T = "prev" : requestAnimationFrame(() => {
        var M;
        (M = h.value[w]) == null || M.select();
      })), requestAnimationFrame(() => {
        T != null && cl(m.value, T);
      }));
    }
    function k(V, I) {
      var M;
      I.preventDefault(), I.stopPropagation();
      const w = ((M = I == null ? void 0 : I.clipboardData) == null ? void 0 : M.getData("Text").trim().slice(0, c.value)) ?? "", T = w.length - 1 === -1 ? V : w.length - 1;
      N(w) || (d.value = w.split(""), v.value = T);
    }
    function P() {
      d.value = [];
    }
    function A(V, I) {
      r(), v.value = I;
    }
    function D() {
      s(), v.value = -1;
    }
    function N(V) {
      return e.type === "number" && /[^0-9]/g.test(V);
    }
    return gt({
      VField: {
        color: R(() => e.color),
        bgColor: R(() => e.color),
        baseColor: R(() => e.baseColor),
        disabled: R(() => e.disabled),
        error: R(() => e.error),
        variant: R(() => e.variant)
      }
    }, {
      scoped: !0
    }), me(d, (V) => {
      V.length === c.value && a("finish", V.join(""));
    }, {
      deep: !0
    }), me(v, (V) => {
      V < 0 || He(() => {
        var I;
        (I = h.value[V]) == null || I.select();
      });
    }), re(() => {
      var w;
      const [V, I] = za(n);
      return S("div", Q({
        class: ["v-otp-input", {
          "v-otp-input--divided": !!e.divider
        }, e.class],
        style: [e.style]
      }, V), [S("div", {
        ref: m,
        class: "v-otp-input__content",
        style: he([i.value])
      }, [f.value.map((T, M) => S(ye, null, [e.divider && M !== 0 && S("span", {
        class: "v-otp-input__divider"
      }, [e.divider]), b(Fa, {
        focused: o.value && e.focusAll || v.value === M,
        key: M
      }, {
        ...l,
        loader: void 0,
        default: () => S("input", {
          ref: (W) => h.value[M] = W,
          "aria-label": u(e.label, M + 1),
          autofocus: M === 0 && e.autofocus,
          autocomplete: "one-time-code",
          class: le(["v-otp-input__field"]),
          disabled: e.disabled,
          inputmode: e.type === "number" ? "numeric" : "text",
          min: e.type === "number" ? 0 : void 0,
          maxlength: M === 0 ? c.value : "1",
          placeholder: e.placeholder,
          type: e.type === "number" ? "text" : e.type,
          value: d.value[M],
          onInput: y,
          onFocus: (W) => A(W, M),
          onBlur: D,
          onKeydown: E,
          onCompositionstart: () => p = !0,
          onCompositionend: _,
          onPaste: (W) => k(M, W)
        }, null)
      })])), S("input", Q({
        class: "v-otp-input-input",
        type: "hidden"
      }, I, {
        value: d.value.join("")
      }), null), b(oa, {
        contained: !0,
        contentClass: "v-otp-input__loader",
        modelValue: !!e.loading,
        persistent: !0
      }, {
        default: () => {
          var T;
          return [((T = l.loader) == null ? void 0 : T.call(l)) ?? b(yl, {
            color: typeof e.loading == "boolean" ? void 0 : e.loading,
            indeterminate: !0,
            size: "24",
            width: "2"
          }, null)];
        }
      }), (w = l.default) == null ? void 0 : w.call(l)])]);
    }), {
      blur: () => {
        var V;
        (V = h.value) == null || V.some((I) => I.blur());
      },
      focus: () => {
        var V;
        (V = h.value) == null || V[0].focus();
      },
      reset: P,
      isFocused: o
    };
  }
});
function oN(e) {
  return Math.floor(Math.abs(e)) * Math.sign(e);
}
const rN = z({
  scale: {
    type: [Number, String],
    default: 0.5
  },
  ...ke()
}, "VParallax"), sN = ne()({
  name: "VParallax",
  props: rN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      intersectionRef: a,
      isIntersecting: l
    } = _o(), {
      resizeRef: i,
      contentRect: o
    } = In(), {
      height: r
    } = Vn(), s = Z();
    ut(() => {
      var v;
      a.value = i.value = (v = s.value) == null ? void 0 : v.$el;
    });
    let d;
    me(l, (v) => {
      v ? (d = Oc(a.value), d = d === document.scrollingElement ? document : d, d.addEventListener("scroll", f, {
        passive: !0
      }), f()) : d.removeEventListener("scroll", f);
    }), Wt(() => {
      d == null || d.removeEventListener("scroll", f);
    }), me(r, f), me(() => {
      var v;
      return (v = o.value) == null ? void 0 : v.height;
    }, f);
    const u = x(() => 1 - ot(Number(e.scale)));
    let c = -1;
    function f() {
      !l.value || aa() || (cancelAnimationFrame(c), c = requestAnimationFrame(() => {
        var k;
        const v = ((k = s.value) == null ? void 0 : k.$el).querySelector(".v-img__img");
        if (!v) return;
        const m = d instanceof Document ? document.documentElement.clientHeight : d.clientHeight, h = d instanceof Document ? window.scrollY : d.scrollTop, g = a.value.getBoundingClientRect().top + h, p = o.value.height, y = g + (p - m) / 2, _ = oN((h - y) * u.value), E = Math.max(1, (u.value * (m - p) + p) / p);
        v.style.setProperty("transform", `translateY(${_}px) scale(${E})`);
      }));
    }
    return re(() => b(Sa, {
      class: le(["v-parallax", {
        "v-parallax--active": l.value
      }, e.class]),
      style: he(e.style),
      ref: s,
      cover: !0,
      onLoadstart: f,
      onLoad: f
    }, n)), {};
  }
}), uN = z({
  ...Yr({
    falseIcon: "$radioOff",
    trueIcon: "$radioOn"
  })
}, "VRadio"), cN = ne()({
  name: "VRadio",
  props: uN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      const a = La.filterProps(e);
      return b(La, Q(a, {
        class: ["v-radio", e.class],
        style: e.style,
        type: "radio"
      }), n);
    }), {};
  }
}), dN = z({
  height: {
    type: [Number, String],
    default: "auto"
  },
  ...Pa(),
  ...tt(Yc(), ["multiple"]),
  trueIcon: {
    type: Ve,
    default: "$radioOn"
  },
  falseIcon: {
    type: Ve,
    default: "$radioOff"
  },
  type: {
    type: String,
    default: "radio"
  }
}, "VRadioGroup"), fN = ne()({
  name: "VRadioGroup",
  inheritAttrs: !1,
  props: dN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const l = Yt(), i = x(() => e.id || `radio-group-${l}`), o = Ee(e, "modelValue"), r = Z();
    return re(() => {
      const [s, d] = za(n), u = Kt.filterProps(e), c = La.filterProps(e), f = a.label ? a.label({
        label: e.label,
        props: {
          for: i.value
        }
      }) : e.label;
      return b(Kt, Q({
        ref: r,
        class: ["v-radio-group", e.class],
        style: e.style
      }, s, u, {
        modelValue: o.value,
        "onUpdate:modelValue": (v) => o.value = v,
        id: i.value
      }), {
        ...a,
        default: (v) => {
          let {
            id: m,
            messagesId: h,
            isDisabled: g,
            isReadonly: p
          } = v;
          return S(ye, null, [f && b(gi, {
            id: m.value
          }, {
            default: () => [f]
          }), b(cy, Q(c, {
            id: m.value,
            "aria-describedby": h.value,
            defaultsTarget: "VRadio",
            trueIcon: e.trueIcon,
            falseIcon: e.falseIcon,
            type: e.type,
            disabled: g.value,
            readonly: p.value,
            "aria-labelledby": f ? m.value : void 0,
            multiple: !1
          }, d, {
            modelValue: o.value,
            "onUpdate:modelValue": (y) => o.value = y
          }), a)]);
        }
      });
    }), Lt({}, r);
  }
}), vN = z({
  ...Eo(),
  ...Pa(),
  ...fb(),
  strict: Boolean,
  modelValue: {
    type: Array,
    default: () => [0, 0]
  }
}, "VRangeSlider"), mN = ne()({
  name: "VRangeSlider",
  props: vN(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    end: (e) => !0,
    start: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const l = Z(), i = Z(), o = Z(), {
      rtlClasses: r
    } = Et();
    function s(V) {
      if (!l.value || !i.value) return;
      const I = Mu(V, l.value.$el, e.direction), w = Mu(V, i.value.$el, e.direction), T = Math.abs(I), M = Math.abs(w);
      return T < M || T === M && I < 0 ? l.value.$el : i.value.$el;
    }
    const d = vb(e), u = Ee(e, "modelValue", void 0, (V) => V != null && V.length ? V.map((I) => d.roundValue(I)) : [0, 0]), {
      activeThumbRef: c,
      hasLabels: f,
      max: v,
      min: m,
      mousePressed: h,
      onSliderMousedown: g,
      onSliderTouchstart: p,
      position: y,
      trackContainerRef: _,
      readonly: E
    } = mb({
      props: e,
      steps: d,
      onSliderStart: () => {
        a("start", u.value);
      },
      onSliderEnd: (V) => {
        var T;
        let {
          value: I
        } = V;
        const w = c.value === ((T = l.value) == null ? void 0 : T.$el) ? [I, u.value[1]] : [u.value[0], I];
        !e.strict && w[0] < w[1] && (u.value = w), a("end", u.value);
      },
      onSliderMove: (V) => {
        var M, W, J, ee;
        let {
          value: I
        } = V;
        const [w, T] = u.value;
        !e.strict && w === T && w !== m.value && (c.value = I > w ? (M = i.value) == null ? void 0 : M.$el : (W = l.value) == null ? void 0 : W.$el, (J = c.value) == null || J.focus()), c.value === ((ee = l.value) == null ? void 0 : ee.$el) ? u.value = [Math.min(I, T), T] : u.value = [w, Math.max(w, I)];
      },
      getActiveThumb: s
    }), {
      isFocused: k,
      focus: P,
      blur: A
    } = Ea(e), D = x(() => y(u.value[0])), N = x(() => y(u.value[1]));
    return re(() => {
      const V = Kt.filterProps(e), I = !!(e.label || n.label || n.prepend);
      return b(Kt, Q({
        class: ["v-slider", "v-range-slider", {
          "v-slider--has-labels": !!n["tick-label"] || f.value,
          "v-slider--focused": k.value,
          "v-slider--pressed": h.value,
          "v-slider--disabled": e.disabled
        }, r.value, e.class],
        style: e.style,
        ref: o
      }, V, {
        focused: k.value
      }), {
        ...n,
        prepend: I ? (w) => {
          var T, M;
          return S(ye, null, [((T = n.label) == null ? void 0 : T.call(n, w)) ?? (e.label ? b(gi, {
            class: "v-slider__label",
            text: e.label
          }, null) : void 0), (M = n.prepend) == null ? void 0 : M.call(n, w)]);
        } : void 0,
        default: (w) => {
          var W, J;
          let {
            id: T,
            messagesId: M
          } = w;
          return S("div", {
            class: "v-slider__container",
            onMousedown: E.value ? void 0 : g,
            onTouchstartPassive: E.value ? void 0 : p
          }, [S("input", {
            id: `${T.value}_start`,
            name: e.name || T.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: u.value[0]
          }, null), S("input", {
            id: `${T.value}_stop`,
            name: e.name || T.value,
            disabled: !!e.disabled,
            readonly: !!e.readonly,
            tabindex: "-1",
            value: u.value[1]
          }, null), b(hb, {
            ref: _,
            start: D.value,
            stop: N.value
          }, {
            "tick-label": n["tick-label"]
          }), b(Ru, {
            ref: l,
            "aria-describedby": M.value,
            focused: k && c.value === ((W = l.value) == null ? void 0 : W.$el),
            modelValue: u.value[0],
            "onUpdate:modelValue": (ee) => u.value = [ee, u.value[1]],
            onFocus: (ee) => {
              var Y, L, H, j;
              P(), c.value = (Y = l.value) == null ? void 0 : Y.$el, v.value !== m.value && u.value[0] === u.value[1] && u.value[1] === m.value && ee.relatedTarget !== ((L = i.value) == null ? void 0 : L.$el) && ((H = l.value) == null || H.$el.blur(), (j = i.value) == null || j.$el.focus());
            },
            onBlur: () => {
              A(), c.value = void 0;
            },
            min: m.value,
            max: u.value[1],
            position: D.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          }), b(Ru, {
            ref: i,
            "aria-describedby": M.value,
            focused: k && c.value === ((J = i.value) == null ? void 0 : J.$el),
            modelValue: u.value[1],
            "onUpdate:modelValue": (ee) => u.value = [u.value[0], ee],
            onFocus: (ee) => {
              var Y, L, H, j;
              P(), c.value = (Y = i.value) == null ? void 0 : Y.$el, v.value !== m.value && u.value[0] === u.value[1] && u.value[0] === v.value && ee.relatedTarget !== ((L = l.value) == null ? void 0 : L.$el) && ((H = i.value) == null || H.$el.blur(), (j = l.value) == null || j.$el.focus());
            },
            onBlur: () => {
              A(), c.value = void 0;
            },
            min: u.value[0],
            max: v.value,
            position: N.value,
            ripple: e.ripple
          }, {
            "thumb-label": n["thumb-label"]
          })]);
        }
      });
    }), Lt({
      focus: () => {
        var V;
        return (V = l.value) == null ? void 0 : V.$el.focus();
      }
    }, o);
  }
}), hN = z({
  name: String,
  itemAriaLabel: {
    type: String,
    default: "$vuetify.rating.ariaLabel.item"
  },
  activeColor: String,
  color: String,
  clearable: Boolean,
  disabled: Boolean,
  emptyIcon: {
    type: Ve,
    default: "$ratingEmpty"
  },
  fullIcon: {
    type: Ve,
    default: "$ratingFull"
  },
  halfIncrements: Boolean,
  hover: Boolean,
  length: {
    type: [Number, String],
    default: 5
  },
  readonly: Boolean,
  modelValue: {
    type: [Number, String],
    default: 0
  },
  itemLabels: Array,
  itemLabelPosition: {
    type: String,
    default: "top",
    validator: (e) => ["top", "bottom"].includes(e)
  },
  ripple: Boolean,
  ...ke(),
  ...Tt(),
  ...sa(),
  ...Oe(),
  ...We()
}, "VRating"), gN = ne()({
  name: "VRating",
  props: hN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      t: a
    } = nt(), {
      themeClasses: l
    } = Ye(e), i = Ee(e, "modelValue"), o = x(() => ot(parseFloat(i.value), 0, Number(e.length))), r = x(() => bn(Number(e.length), 1)), s = x(() => r.value.flatMap((g) => e.halfIncrements ? [g - 0.5, g] : [g])), d = fe(-1), u = x(() => s.value.map((g) => {
      const p = e.hover && d.value > -1, y = o.value >= g, _ = d.value >= g, k = (p ? _ : y) ? e.fullIcon : e.emptyIcon, P = e.activeColor ?? e.color, A = y || _ ? P : e.color;
      return {
        isFilled: y,
        isHovered: _,
        icon: k,
        color: A
      };
    })), c = x(() => [0, ...s.value].map((g) => {
      function p() {
        d.value = g;
      }
      function y() {
        d.value = -1;
      }
      function _() {
        e.disabled || e.readonly || (i.value = o.value === g && e.clearable ? 0 : g);
      }
      return {
        onMouseenter: e.hover ? p : void 0,
        onMouseleave: e.hover ? y : void 0,
        onClick: _
      };
    })), f = Yt(), v = x(() => e.name ?? `v-rating-${f}`);
    function m(g) {
      var N, V;
      let {
        value: p,
        index: y,
        showStar: _ = !0
      } = g;
      const {
        onMouseenter: E,
        onMouseleave: k,
        onClick: P
      } = c.value[y + 1], A = `${v.value}-${String(p).replace(".", "-")}`, D = {
        color: (N = u.value[y]) == null ? void 0 : N.color,
        density: e.density,
        disabled: e.disabled,
        icon: (V = u.value[y]) == null ? void 0 : V.icon,
        ripple: e.ripple,
        size: e.size,
        variant: "plain"
      };
      return S(ye, null, [S("label", {
        for: A,
        class: le({
          "v-rating__item--half": e.halfIncrements && p % 1 > 0,
          "v-rating__item--full": e.halfIncrements && p % 1 === 0
        }),
        onMouseenter: E,
        onMouseleave: k,
        onClick: P
      }, [S("span", {
        class: "v-rating__hidden"
      }, [a(e.itemAriaLabel, p, e.length)]), _ ? n.item ? n.item({
        ...u.value[y],
        props: D,
        value: p,
        index: y,
        rating: o.value
      }) : b(Le, Q({
        "aria-label": a(e.itemAriaLabel, p, e.length)
      }, D), null) : void 0]), S("input", {
        class: "v-rating__hidden",
        name: v.value,
        id: A,
        type: "radio",
        value: p,
        checked: o.value === p,
        tabindex: -1,
        readonly: e.readonly,
        disabled: e.disabled
      }, null)]);
    }
    function h(g) {
      return n["item-label"] ? n["item-label"](g) : g.label ? S("span", null, [g.label]) : S("span", null, [ze("")]);
    }
    return re(() => {
      var p;
      const g = !!((p = e.itemLabels) != null && p.length) || n["item-label"];
      return b(e.tag, {
        class: le(["v-rating", {
          "v-rating--hover": e.hover,
          "v-rating--readonly": e.readonly
        }, l.value, e.class]),
        style: he(e.style)
      }, {
        default: () => [b(m, {
          value: 0,
          index: -1,
          showStar: !1
        }, null), r.value.map((y, _) => {
          var E, k;
          return S("div", {
            class: "v-rating__wrapper"
          }, [g && e.itemLabelPosition === "top" ? h({
            value: y,
            index: _,
            label: (E = e.itemLabels) == null ? void 0 : E[_]
          }) : void 0, S("div", {
            class: "v-rating__item"
          }, [e.halfIncrements ? S(ye, null, [b(m, {
            value: y - 0.5,
            index: _ * 2
          }, null), b(m, {
            value: y,
            index: _ * 2 + 1
          }, null)]) : b(m, {
            value: y,
            index: _
          }, null)]), g && e.itemLabelPosition === "bottom" ? h({
            value: y,
            index: _,
            label: (k = e.itemLabels) == null ? void 0 : k[_]
          }) : void 0]);
        })]
      });
    }), {};
  }
}), yN = {
  actions: "button@2",
  article: "heading, paragraph",
  avatar: "avatar",
  button: "button",
  card: "image, heading",
  "card-avatar": "image, list-item-avatar",
  chip: "chip",
  "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
  "date-picker-options": "text, avatar@2",
  "date-picker-days": "avatar@28",
  divider: "divider",
  heading: "heading",
  image: "image",
  "list-item": "text",
  "list-item-avatar": "avatar, text",
  "list-item-two-line": "sentences",
  "list-item-avatar-two-line": "avatar, sentences",
  "list-item-three-line": "paragraph",
  "list-item-avatar-three-line": "avatar, paragraph",
  ossein: "ossein",
  paragraph: "text@3",
  sentences: "text@2",
  subtitle: "text",
  table: "table-heading, table-thead, table-tbody, table-tfoot",
  "table-heading": "chip, text",
  "table-thead": "heading@6",
  "table-tbody": "table-row-divider@6",
  "table-row-divider": "table-row, divider",
  "table-row": "text@6",
  "table-tfoot": "text@2, avatar@2",
  text: "text"
};
function bN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return S("div", {
    class: le(["v-skeleton-loader__bone", `v-skeleton-loader__${e}`])
  }, [t]);
}
function jv(e) {
  const [t, n] = e.split("@");
  return Array.from({
    length: n
  }).map(() => us(t));
}
function us(e) {
  let t = [];
  if (!e) return t;
  const n = yN[e];
  if (e !== n) {
    if (e.includes(",")) return Wv(e);
    if (e.includes("@")) return jv(e);
    n.includes(",") ? t = Wv(n) : n.includes("@") ? t = jv(n) : n && t.push(us(n));
  }
  return [bN(e, t)];
}
function Wv(e) {
  return e.replace(/\s/g, "").split(",").map(us);
}
const pN = z({
  boilerplate: Boolean,
  color: String,
  loading: Boolean,
  loadingText: {
    type: String,
    default: "$vuetify.loading"
  },
  type: {
    type: [String, Array],
    default: "ossein"
  },
  ...kt(),
  ...Pt(),
  ...We()
}, "VSkeletonLoader"), SN = ne()({
  name: "VSkeletonLoader",
  inheritAttrs: !1,
  props: pN(),
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const {
      backgroundColorClasses: l,
      backgroundColorStyles: i
    } = Xe(() => e.color), {
      dimensionStyles: o
    } = Ct(e), {
      elevationClasses: r
    } = Rt(e), {
      themeClasses: s
    } = Ye(e), {
      t: d
    } = nt(), u = x(() => us(ht(e.type).join(",")));
    return re(() => {
      var v;
      const c = !a.default || e.loading, f = e.boilerplate || !c ? {} : {
        ariaLive: "polite",
        ariaLabel: d(e.loadingText),
        role: "alert"
      };
      return S(ye, null, [c ? S("div", Q({
        class: ["v-skeleton-loader", {
          "v-skeleton-loader--boilerplate": e.boilerplate
        }, s.value, l.value, r.value],
        style: [i.value, o.value]
      }, f, n), [u.value]) : (v = a.default) == null ? void 0 : v.call(a)]);
    }), {};
  }
}), wN = ne()({
  name: "VSlideGroupItem",
  props: Nl(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Dl(e, py);
    return () => {
      var l;
      return (l = n.default) == null ? void 0 : l.call(n, {
        isSelected: a.isSelected.value,
        select: a.select,
        toggle: a.toggle,
        selectedClass: a.selectedClass.value
      });
    };
  }
});
function _N(e) {
  const t = fe(e());
  let n = -1;
  function a() {
    clearInterval(n);
  }
  function l() {
    a(), He(() => t.value = e());
  }
  function i(o) {
    const r = o ? getComputedStyle(o) : {
      transitionDuration: 0.2
    }, s = parseFloat(r.transitionDuration) * 1e3 || 200;
    if (a(), t.value <= 0) return;
    const d = performance.now();
    n = window.setInterval(() => {
      const u = performance.now() - d + s;
      t.value = Math.max(e() - u, 0), t.value <= 0 && a();
    }, s);
  }
  return Dt(a), {
    clear: a,
    time: t,
    start: i,
    reset: l
  };
}
const dp = z({
  multiLine: Boolean,
  text: String,
  timer: [Boolean, String],
  timeout: {
    type: [Number, String],
    default: 5e3
  },
  vertical: Boolean,
  ...Va({
    location: "bottom"
  }),
  ...mi(),
  ...ft(),
  ...Dn(),
  ...We(),
  ...tt(Po({
    transition: "v-snackbar-transition"
  }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy", "stickToTarget"])
}, "VSnackbar"), qu = ne()({
  name: "VSnackbar",
  props: dp(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue"), {
      positionClasses: l
    } = hi(e), {
      scopeId: i
    } = Tl(), {
      themeClasses: o
    } = Ye(e), {
      colorClasses: r,
      colorStyles: s,
      variantClasses: d
    } = Pl(e), {
      roundedClasses: u
    } = yt(e), c = _N(() => Number(e.timeout)), f = Z(), v = Z(), m = fe(!1), h = fe(0), g = Z(), p = Me(Qi, void 0);
    Gt(() => !!p, () => {
      const I = zg();
      ut(() => {
        g.value = I.mainStyles.value;
      });
    }), me(a, _), me(() => e.timeout, _), At(() => {
      a.value && _();
    });
    let y = -1;
    function _() {
      c.reset(), window.clearTimeout(y);
      const I = Number(e.timeout);
      if (!a.value || I === -1) return;
      const w = Ec(v.value);
      c.start(w), y = window.setTimeout(() => {
        a.value = !1;
      }, I);
    }
    function E() {
      c.reset(), window.clearTimeout(y);
    }
    function k() {
      m.value = !0, E();
    }
    function P() {
      m.value = !1, _();
    }
    function A(I) {
      h.value = I.touches[0].clientY;
    }
    function D(I) {
      Math.abs(h.value - I.changedTouches[0].clientY) > 50 && (a.value = !1);
    }
    function N() {
      m.value && P();
    }
    const V = x(() => e.location.split(" ").reduce((I, w) => (I[`v-snackbar--${w}`] = !0, I), {}));
    return re(() => {
      const I = oa.filterProps(e), w = !!(n.default || n.text || e.text);
      return b(oa, Q({
        ref: f,
        class: ["v-snackbar", {
          "v-snackbar--active": a.value,
          "v-snackbar--multi-line": e.multiLine && !e.vertical,
          "v-snackbar--timer": !!e.timer,
          "v-snackbar--vertical": e.vertical
        }, V.value, l.value, e.class],
        style: [g.value, e.style]
      }, I, {
        modelValue: a.value,
        "onUpdate:modelValue": (T) => a.value = T,
        contentProps: Q({
          class: ["v-snackbar__wrapper", o.value, r.value, u.value, d.value],
          style: [s.value],
          onPointerenter: k,
          onPointerleave: P
        }, I.contentProps),
        persistent: !0,
        noClickAnimation: !0,
        scrim: !1,
        scrollStrategy: "none",
        _disableGlobalStack: !0,
        onTouchstartPassive: A,
        onTouchend: D,
        onAfterLeave: N
      }, i), {
        default: () => {
          var T, M;
          return [ja(!1, "v-snackbar"), e.timer && !m.value && S("div", {
            key: "timer",
            class: "v-snackbar__timer"
          }, [b(Ur, {
            ref: v,
            color: typeof e.timer == "string" ? e.timer : "info",
            max: e.timeout,
            modelValue: c.time.value
          }, null)]), w && S("div", {
            key: "content",
            class: "v-snackbar__content",
            role: "status",
            "aria-live": "polite"
          }, [((T = n.text) == null ? void 0 : T.call(n)) ?? e.text, (M = n.default) == null ? void 0 : M.call(n)]), n.actions && b(Be, {
            defaults: {
              VBtn: {
                variant: "text",
                ripple: !1,
                slim: !0
              }
            }
          }, {
            default: () => [S("div", {
              class: "v-snackbar__actions"
            }, [n.actions({
              isActive: a
            })])]
          })];
        },
        activator: n.activator
      });
    }), Lt({}, f);
  }
}), xN = z({
  // TODO: Port this to Snackbar on dev
  closable: [Boolean, String],
  closeText: {
    type: String,
    default: "$vuetify.dismiss"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  ...tt(dp(), ["modelValue"])
}, "VSnackbarQueue"), kN = ne()({
  name: "VSnackbarQueue",
  props: xN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      t: l
    } = nt(), i = fe(!1), o = fe(!1), r = fe();
    me(() => e.modelValue.length, (f, v) => {
      !o.value && f > v && d();
    }), me(i, (f) => {
      f && (o.value = !0);
    });
    function s() {
      e.modelValue.length ? d() : (r.value = void 0, o.value = !1);
    }
    function d() {
      const [f, ...v] = e.modelValue;
      n("update:modelValue", v), r.value = typeof f == "string" ? {
        text: f
      } : f, He(() => {
        i.value = !0;
      });
    }
    function u() {
      i.value = !1;
    }
    const c = x(() => ({
      color: typeof e.closable == "string" ? e.closable : void 0,
      text: l(e.closeText)
    }));
    re(() => {
      const f = !!(e.closable || a.actions), {
        modelValue: v,
        ...m
      } = qu.filterProps(e);
      return S(ye, null, [o.value && !!r.value && (a.default ? b(Be, {
        defaults: {
          VSnackbar: r.value
        }
      }, {
        default: () => [a.default({
          item: r.value
        })]
      }) : b(qu, Q(m, r.value, {
        modelValue: i.value,
        "onUpdate:modelValue": (h) => i.value = h,
        onAfterLeave: s
      }), {
        text: a.text ? () => {
          var h;
          return (h = a.text) == null ? void 0 : h.call(a, {
            item: r.value
          });
        } : void 0,
        actions: f ? () => S(ye, null, [a.actions ? b(Be, {
          defaults: {
            VBtn: c.value
          }
        }, {
          default: () => [a.actions({
            item: r.value,
            props: {
              onClick: u
            }
          })]
        }) : b(Le, Q(c.value, {
          onClick: u
        }), null)]) : void 0
      }))]);
    });
  }
}), fp = z({
  autoDraw: Boolean,
  autoDrawDuration: [Number, String],
  autoDrawEasing: {
    type: String,
    default: "ease"
  },
  color: String,
  gradient: {
    type: Array,
    default: () => []
  },
  gradientDirection: {
    type: String,
    validator: (e) => ["top", "bottom", "left", "right"].includes(e),
    default: "top"
  },
  height: {
    type: [String, Number],
    default: 75
  },
  labels: {
    type: Array,
    default: () => []
  },
  labelSize: {
    type: [Number, String],
    default: 7
  },
  lineWidth: {
    type: [String, Number],
    default: 4
  },
  id: String,
  itemValue: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  min: [String, Number],
  max: [String, Number],
  padding: {
    type: [String, Number],
    default: 8
  },
  showLabels: Boolean,
  smooth: [Boolean, String, Number],
  width: {
    type: [Number, String],
    default: 300
  }
}, "Line"), vp = z({
  autoLineWidth: Boolean,
  ...fp()
}, "VBarline"), Uv = ne()({
  name: "VBarline",
  props: vp(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Yt(), l = x(() => e.id || `barline-${a}`), i = x(() => Number(e.autoDrawDuration) || 500), o = x(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), r = x(() => parseFloat(e.lineWidth) || 4), s = x(() => Math.max(e.modelValue.length * r.value, Number(e.width))), d = x(() => ({
      minX: 0,
      maxX: s.value,
      minY: 0,
      maxY: parseInt(e.height, 10)
    })), u = x(() => e.modelValue.map((g) => xt(g, e.itemValue, g)));
    function c(g, p) {
      const {
        minX: y,
        maxX: _,
        minY: E,
        maxY: k
      } = p, P = g.length;
      let A = e.max != null ? Number(e.max) : Math.max(...g), D = e.min != null ? Number(e.min) : Math.min(...g);
      D > 0 && e.min == null && (D = 0), A < 0 && e.max == null && (A = 0);
      const N = _ / (P === 1 ? 2 : P), V = (k - E) / (A - D || 1), I = k - Math.abs(D * V);
      return g.map((w, T) => {
        const M = Math.abs(V * w);
        return {
          x: y + T * N,
          y: I - M + +(w < 0) * M,
          height: M,
          value: w
        };
      });
    }
    const f = x(() => {
      const g = [], p = c(u.value, d.value), y = p.length;
      for (let _ = 0; g.length < y; _++) {
        const E = p[_];
        let k = e.labels[_];
        k || (k = typeof E == "object" ? E.value : E), g.push({
          x: E.x,
          value: String(k)
        });
      }
      return g;
    }), v = x(() => c(u.value, d.value)), m = x(() => v.value.length === 1 ? (d.value.maxX - r.value) / 2 : (Math.abs(v.value[0].x - v.value[1].x) - r.value) / 2), h = x(() => typeof e.smooth == "boolean" ? e.smooth ? 2 : 0 : Number(e.smooth));
    re(() => {
      const g = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return S("svg", {
        display: "block"
      }, [S("defs", null, [S("linearGradient", {
        id: l.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [g.map((p, y) => S("stop", {
        offset: y / Math.max(g.length - 1, 1),
        "stop-color": p || "currentColor"
      }, null))])]), S("clipPath", {
        id: `${l.value}-clip`
      }, [v.value.map((p) => S("rect", {
        x: p.x + m.value,
        y: p.y,
        width: r.value,
        height: p.height,
        rx: h.value,
        ry: h.value
      }, [e.autoDraw && !aa() && S(ye, null, [S("animate", {
        attributeName: "y",
        from: p.y + p.height,
        to: p.y,
        dur: `${i.value}ms`,
        fill: "freeze"
      }, null), S("animate", {
        attributeName: "height",
        from: "0",
        to: p.height,
        dur: `${i.value}ms`,
        fill: "freeze"
      }, null)])]))]), o.value && S("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [f.value.map((p, y) => {
        var _;
        return S("text", {
          x: p.x + m.value + r.value / 2,
          y: parseInt(e.height, 10) - 2 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((_ = n.label) == null ? void 0 : _.call(n, {
          index: y,
          value: p.value
        })) ?? p.value]);
      })]), S("g", {
        "clip-path": `url(#${l.value}-clip)`,
        fill: `url(#${l.value})`
      }, [S("rect", {
        x: 0,
        y: 0,
        width: Math.max(e.modelValue.length * r.value, Number(e.width)),
        height: e.height
      }, null)])]);
    });
  }
});
function CN(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
  if (e.length === 0) return "";
  const l = e.shift(), i = e[e.length - 1];
  return (n ? `M${l.x} ${a - l.x + 2} L${l.x} ${l.y}` : `M${l.x} ${l.y}`) + e.map((o, r) => {
    const s = e[r + 1], d = e[r - 1] || l, u = s && VN(s, o, d);
    if (!s || u)
      return `L${o.x} ${o.y}`;
    const c = Math.min(Gv(d, o), Gv(s, o)), v = c / 2 < t ? c / 2 : t, m = Kv(d, o, v), h = Kv(s, o, v);
    return `L${m.x} ${m.y}S${o.x} ${o.y} ${h.x} ${h.y}`;
  }).join("") + (n ? `L${i.x} ${a - l.x + 2} Z` : "");
}
function zo(e) {
  return parseInt(e, 10);
}
function VN(e, t, n) {
  return zo(e.x + n.x) === zo(2 * t.x) && zo(e.y + n.y) === zo(2 * t.y);
}
function Gv(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function Kv(e, t, n) {
  const a = {
    x: e.x - t.x,
    y: e.y - t.y
  }, l = Math.sqrt(a.x * a.x + a.y * a.y), i = {
    x: a.x / l,
    y: a.y / l
  };
  return {
    x: t.x + i.x * n,
    y: t.y + i.y * n
  };
}
const mp = z({
  fill: Boolean,
  ...fp()
}, "VTrendline"), Yv = ne()({
  name: "VTrendline",
  props: mp(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Yt(), l = x(() => e.id || `trendline-${a}`), i = x(() => Number(e.autoDrawDuration) || (e.fill ? 500 : 2e3)), o = Z(0), r = Z(null);
    function s(g, p) {
      const {
        minX: y,
        maxX: _,
        minY: E,
        maxY: k
      } = p;
      g.length === 1 && (g = [g[0], g[0]]);
      const P = g.length, A = e.max != null ? Number(e.max) : Math.max(...g), D = e.min != null ? Number(e.min) : Math.min(...g), N = (_ - y) / (P - 1), V = (k - E) / (A - D || 1);
      return g.map((I, w) => ({
        x: y + w * N,
        y: k - (I - D) * V,
        value: I
      }));
    }
    const d = x(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), u = x(() => parseFloat(e.lineWidth) || 4), c = x(() => Number(e.width)), f = x(() => {
      const g = Number(e.padding);
      return {
        minX: g,
        maxX: c.value - g,
        minY: g,
        maxY: parseInt(e.height, 10) - g
      };
    }), v = x(() => e.modelValue.map((g) => xt(g, e.itemValue, g))), m = x(() => {
      const g = [], p = s(v.value, f.value), y = p.length;
      for (let _ = 0; g.length < y; _++) {
        const E = p[_];
        let k = e.labels[_];
        k || (k = typeof E == "object" ? E.value : E), g.push({
          x: E.x,
          value: String(k)
        });
      }
      return g;
    });
    me(() => e.modelValue, async () => {
      if (await He(), !e.autoDraw || !r.value || aa()) return;
      const g = r.value, p = g.getTotalLength();
      e.fill ? (g.style.transformOrigin = "bottom center", g.style.transition = "none", g.style.transform = "scaleY(0)", g.getBoundingClientRect(), g.style.transition = `transform ${i.value}ms ${e.autoDrawEasing}`, g.style.transform = "scaleY(1)") : (g.style.strokeDasharray = `${p}`, g.style.strokeDashoffset = `${p}`, g.getBoundingClientRect(), g.style.transition = `stroke-dashoffset ${i.value}ms ${e.autoDrawEasing}`, g.style.strokeDashoffset = "0"), o.value = p;
    }, {
      immediate: !0
    });
    function h(g) {
      const p = typeof e.smooth == "boolean" ? e.smooth ? 8 : 0 : Number(e.smooth);
      return CN(s(v.value, f.value), p, g, parseInt(e.height, 10));
    }
    re(() => {
      var p;
      const g = e.gradient.slice().length ? e.gradient.slice().reverse() : [""];
      return S("svg", {
        display: "block",
        "stroke-width": parseFloat(e.lineWidth) ?? 4
      }, [S("defs", null, [S("linearGradient", {
        id: l.value,
        gradientUnits: "userSpaceOnUse",
        x1: e.gradientDirection === "left" ? "100%" : "0",
        y1: e.gradientDirection === "top" ? "100%" : "0",
        x2: e.gradientDirection === "right" ? "100%" : "0",
        y2: e.gradientDirection === "bottom" ? "100%" : "0"
      }, [g.map((y, _) => S("stop", {
        offset: _ / Math.max(g.length - 1, 1),
        "stop-color": y || "currentColor"
      }, null))])]), d.value && S("g", {
        key: "labels",
        style: {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [m.value.map((y, _) => {
        var E;
        return S("text", {
          x: y.x + u.value / 2 + u.value / 2,
          y: parseInt(e.height, 10) - 4 + (parseInt(e.labelSize, 10) || 7 * 0.75),
          "font-size": Number(e.labelSize) || 7
        }, [((E = n.label) == null ? void 0 : E.call(n, {
          index: _,
          value: y.value
        })) ?? y.value]);
      })]), S("path", {
        ref: r,
        d: h(e.fill),
        fill: e.fill ? `url(#${l.value})` : "none",
        stroke: e.fill ? "none" : `url(#${l.value})`
      }, null), e.fill && S("path", {
        d: h(!1),
        fill: "none",
        stroke: e.color ?? ((p = e.gradient) == null ? void 0 : p[0])
      }, null)]);
    });
  }
}), EN = z({
  type: {
    type: String,
    default: "trend"
  },
  ...vp(),
  ...mp()
}, "VSparkline"), PN = ne()({
  name: "VSparkline",
  props: EN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      textColorClasses: a,
      textColorStyles: l
    } = jt(() => e.color), i = x(() => !!(e.showLabels || e.labels.length > 0 || n != null && n.label)), o = x(() => {
      let r = parseInt(e.height, 10);
      return i.value && (r += parseInt(e.labelSize, 10) * 1.5), r;
    });
    re(() => {
      const r = e.type === "trend" ? Yv : Uv, s = e.type === "trend" ? Yv.filterProps(e) : Uv.filterProps(e);
      return b(r, Q({
        key: e.type,
        class: a.value,
        style: l.value,
        viewBox: `0 0 ${e.width} ${parseInt(o.value, 10)}`
      }, s), n);
    });
  }
}), IN = z({
  ...ke(),
  ...Uy({
    offset: 8,
    minWidth: 0,
    openDelay: 0,
    closeDelay: 100,
    location: "top center",
    transition: "scale-transition"
  })
}, "VSpeedDial"), NN = ne()({
  name: "VSpeedDial",
  props: IN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue"), l = Z(), i = x(() => {
      var d;
      const [r, s = "center"] = ((d = e.location) == null ? void 0 : d.split(" ")) ?? [];
      return `${r} ${s}`;
    }), o = x(() => ({
      [`v-speed-dial__content--${i.value.replace(" ", "-")}`]: !0
    }));
    return re(() => {
      const r = si.filterProps(e);
      return b(si, Q(r, {
        modelValue: a.value,
        "onUpdate:modelValue": (s) => a.value = s,
        class: e.class,
        style: e.style,
        contentClass: ["v-speed-dial__content", o.value, e.contentClass],
        location: i.value,
        ref: l,
        transition: "fade-transition"
      }), {
        ...n,
        default: (s) => b(Be, {
          defaults: {
            VBtn: {
              size: "small"
            }
          }
        }, {
          default: () => [b(Zt, {
            appear: !0,
            group: !0,
            transition: e.transition
          }, {
            default: () => {
              var d;
              return [(d = n.default) == null ? void 0 : d.call(n, s)];
            }
          })]
        })
      });
    }), {};
  }
}), Cd = Symbol.for("vuetify:v-stepper"), hp = z({
  color: String,
  disabled: {
    type: [Boolean, String],
    default: !1
  },
  prevText: {
    type: String,
    default: "$vuetify.stepper.prev"
  },
  nextText: {
    type: String,
    default: "$vuetify.stepper.next"
  }
}, "VStepperActions"), gp = ne()({
  name: "VStepperActions",
  props: hp(),
  emits: {
    "click:prev": () => !0,
    "click:next": () => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      t: l
    } = nt();
    function i() {
      n("click:prev");
    }
    function o() {
      n("click:next");
    }
    return re(() => {
      const r = {
        onClick: i
      }, s = {
        onClick: o
      };
      return S("div", {
        class: "v-stepper-actions"
      }, [b(Be, {
        defaults: {
          VBtn: {
            disabled: ["prev", !0].includes(e.disabled),
            text: l(e.prevText),
            variant: "text"
          }
        }
      }, {
        default: () => {
          var d;
          return [((d = a.prev) == null ? void 0 : d.call(a, {
            props: r
          })) ?? b(Le, r, null)];
        }
      }), b(Be, {
        defaults: {
          VBtn: {
            color: e.color,
            disabled: ["next", !0].includes(e.disabled),
            text: l(e.nextText),
            variant: "tonal"
          }
        }
      }, {
        default: () => {
          var d;
          return [((d = a.next) == null ? void 0 : d.call(a, {
            props: s
          })) ?? b(Le, s, null)];
        }
      })]);
    }), {};
  }
}), yp = Ca("v-stepper-header"), DN = z({
  color: String,
  title: String,
  subtitle: String,
  complete: Boolean,
  completeIcon: {
    type: Ve,
    default: "$complete"
  },
  editable: Boolean,
  editIcon: {
    type: Ve,
    default: "$edit"
  },
  error: Boolean,
  errorIcon: {
    type: Ve,
    default: "$error"
  },
  icon: Ve,
  ripple: {
    type: [Boolean, Object],
    default: !0
  },
  rules: {
    type: Array,
    default: () => []
  }
}, "StepperItem"), AN = z({
  ...DN(),
  ...Nl()
}, "VStepperItem"), bp = ne()({
  name: "VStepperItem",
  directives: {
    vRipple: en
  },
  props: AN(),
  emits: {
    "group:selected": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Dl(e, Cd, !0), l = x(() => (a == null ? void 0 : a.value.value) ?? e.value), i = x(() => e.rules.every((f) => f() === !0)), o = x(() => !e.disabled && e.editable), r = x(() => !e.disabled && e.editable), s = x(() => e.error || !i.value), d = x(() => e.complete || e.rules.length > 0 && i.value), u = x(() => s.value ? e.errorIcon : d.value ? e.completeIcon : a.isSelected.value && e.editable ? e.editIcon : e.icon), c = x(() => ({
      canEdit: r.value,
      hasError: s.value,
      hasCompleted: d.value,
      title: e.title,
      subtitle: e.subtitle,
      step: l.value,
      value: e.value
    }));
    return re(() => {
      var g, p, y;
      const f = (!a || a.isSelected.value || d.value || r.value) && !s.value && !e.disabled, v = !!(e.title != null || n.title), m = !!(e.subtitle != null || n.subtitle);
      function h() {
        a == null || a.toggle();
      }
      return dt(S("button", {
        class: le(["v-stepper-item", {
          "v-stepper-item--complete": d.value,
          "v-stepper-item--disabled": e.disabled,
          "v-stepper-item--error": s.value
        }, a == null ? void 0 : a.selectedClass.value]),
        disabled: !e.editable,
        type: "button",
        onClick: h
      }, [o.value && ja(!0, "v-stepper-item"), b(kn, {
        key: "stepper-avatar",
        class: "v-stepper-item__avatar",
        color: f ? e.color : void 0,
        size: 24
      }, {
        default: () => {
          var _;
          return [((_ = n.icon) == null ? void 0 : _.call(n, c.value)) ?? (u.value ? b(Ue, {
            icon: u.value
          }, null) : l.value)];
        }
      }), S("div", {
        class: "v-stepper-item__content"
      }, [v && S("div", {
        key: "title",
        class: "v-stepper-item__title"
      }, [((g = n.title) == null ? void 0 : g.call(n, c.value)) ?? e.title]), m && S("div", {
        key: "subtitle",
        class: "v-stepper-item__subtitle"
      }, [((p = n.subtitle) == null ? void 0 : p.call(n, c.value)) ?? e.subtitle]), (y = n.default) == null ? void 0 : y.call(n, c.value)])]), [[en, e.editable && e.ripple, null]]);
    }), {};
  }
}), TN = z({
  ...tt(Jr(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VStepperWindow"), pp = ne()({
  name: "VStepperWindow",
  props: TN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Me(Cd, null), l = Ee(e, "modelValue"), i = x({
      get() {
        var o;
        return l.value != null || !a ? l.value : (o = a.items.value.find((r) => a.selected.value.includes(r.id))) == null ? void 0 : o.value;
      },
      set(o) {
        l.value = o;
      }
    });
    return re(() => {
      const o = bl.filterProps(e);
      return b(bl, Q({
        _as: "VStepperWindow"
      }, o, {
        modelValue: i.value,
        "onUpdate:modelValue": (r) => i.value = r,
        class: ["v-stepper-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), ON = z({
  ...Zr()
}, "VStepperWindowItem"), Sp = ne()({
  name: "VStepperWindowItem",
  props: ON(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      const a = pl.filterProps(e);
      return b(pl, Q({
        _as: "VStepperWindowItem"
      }, a, {
        class: ["v-stepper-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
}), $N = z({
  altLabels: Boolean,
  bgColor: String,
  completeIcon: Ve,
  editIcon: Ve,
  editable: Boolean,
  errorIcon: Ve,
  hideActions: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: String,
    default: "title"
  },
  itemValue: {
    type: String,
    default: "value"
  },
  nonLinear: Boolean,
  flat: Boolean,
  ...kl()
}, "Stepper"), BN = z({
  ...$N(),
  ...Il({
    mandatory: "force",
    selectedClass: "v-stepper-item--selected"
  }),
  ...cd(),
  ...mn(hp(), ["prevText", "nextText"])
}, "VStepper"), MN = ne()({
  name: "VStepper",
  props: BN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      items: a,
      next: l,
      prev: i,
      selected: o
    } = Wa(e, Cd), {
      displayClasses: r,
      mobile: s
    } = Vn(e), {
      completeIcon: d,
      editIcon: u,
      errorIcon: c,
      color: f,
      editable: v,
      prevText: m,
      nextText: h
    } = ci(e), g = x(() => e.items.map((_, E) => {
      const k = xt(_, e.itemTitle, _), P = xt(_, e.itemValue, E + 1);
      return {
        title: k,
        value: P,
        raw: _
      };
    })), p = x(() => a.value.findIndex((_) => o.value.includes(_.id))), y = x(() => e.disabled ? e.disabled : p.value === 0 ? "prev" : p.value === a.value.length - 1 ? "next" : !1);
    return gt({
      VStepperItem: {
        editable: v,
        errorIcon: c,
        completeIcon: d,
        editIcon: u,
        prevText: m,
        nextText: h
      },
      VStepperActions: {
        color: f,
        disabled: y,
        prevText: m,
        nextText: h
      }
    }), re(() => {
      const _ = ro.filterProps(e), E = !!(n.header || e.items.length), k = e.items.length > 0, P = !e.hideActions && !!(k || n.actions);
      return b(ro, Q(_, {
        color: e.bgColor,
        class: ["v-stepper", {
          "v-stepper--alt-labels": e.altLabels,
          "v-stepper--flat": e.flat,
          "v-stepper--non-linear": e.nonLinear,
          "v-stepper--mobile": s.value
        }, r.value, e.class],
        style: e.style
      }), {
        default: () => {
          var A, D;
          return [E && b(yp, {
            key: "stepper-header"
          }, {
            default: () => [g.value.map((N, V) => {
              let {
                raw: I,
                ...w
              } = N;
              return S(ye, null, [!!V && b(Sn, null, null), b(bp, w, {
                default: n[`header-item.${w.value}`] ?? n.header,
                icon: n.icon,
                title: n.title,
                subtitle: n.subtitle
              })]);
            })]
          }), k && b(pp, {
            key: "stepper-window"
          }, {
            default: () => [g.value.map((N) => b(Sp, {
              value: N.value
            }, {
              default: () => {
                var V, I;
                return ((V = n[`item.${N.value}`]) == null ? void 0 : V.call(n, N)) ?? ((I = n.item) == null ? void 0 : I.call(n, N));
              }
            }))]
          }), (A = n.default) == null ? void 0 : A.call(n, {
            prev: i,
            next: l
          }), P && (((D = n.actions) == null ? void 0 : D.call(n, {
            next: l,
            prev: i
          })) ?? b(gp, {
            key: "stepper-actions",
            "onClick:prev": i,
            "onClick:next": l
          }, n))];
        }
      });
    }), {
      prev: i,
      next: l
    };
  }
}), RN = z({
  indeterminate: Boolean,
  inset: Boolean,
  flat: Boolean,
  loading: {
    type: [Boolean, String],
    default: !1
  },
  ...Pa(),
  ...Yr()
}, "VSwitch"), LN = ne()({
  name: "VSwitch",
  inheritAttrs: !1,
  props: RN(),
  emits: {
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:indeterminate": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const l = Ee(e, "indeterminate"), i = Ee(e, "modelValue"), {
      loaderClasses: o
    } = xo(e), {
      isFocused: r,
      focus: s,
      blur: d
    } = Ea(e), u = Z(), c = Z(), f = Vc && window.matchMedia("(forced-colors: active)").matches, v = R(() => typeof e.loading == "string" && e.loading !== "" ? e.loading : e.color), m = Yt(), h = R(() => e.id || `switch-${m}`);
    function g() {
      l.value && (l.value = !1);
    }
    function p(y) {
      var _, E;
      y.stopPropagation(), y.preventDefault(), (E = (_ = u.value) == null ? void 0 : _.input) == null || E.click();
    }
    return re(() => {
      const [y, _] = za(n), E = Kt.filterProps(e), k = La.filterProps(e);
      return b(Kt, Q({
        ref: c,
        class: ["v-switch", {
          "v-switch--flat": e.flat
        }, {
          "v-switch--inset": e.inset
        }, {
          "v-switch--indeterminate": l.value
        }, o.value, e.class]
      }, y, E, {
        modelValue: i.value,
        "onUpdate:modelValue": (P) => i.value = P,
        id: h.value,
        focused: r.value,
        style: e.style
      }), {
        ...a,
        default: (P) => {
          let {
            id: A,
            messagesId: D,
            isDisabled: N,
            isReadonly: V,
            isValid: I
          } = P;
          const w = {
            model: i,
            isValid: I
          };
          return b(La, Q({
            ref: u
          }, k, {
            modelValue: i.value,
            "onUpdate:modelValue": [(T) => i.value = T, g],
            id: A.value,
            "aria-describedby": D.value,
            type: "checkbox",
            "aria-checked": l.value ? "mixed" : void 0,
            disabled: N.value,
            readonly: V.value,
            onFocus: s,
            onBlur: d
          }, _), {
            ...a,
            default: (T) => {
              let {
                backgroundColorClasses: M,
                backgroundColorStyles: W
              } = T;
              return S("div", {
                class: le(["v-switch__track", f ? void 0 : M.value]),
                style: he(W.value),
                onClick: p
              }, [a["track-true"] && S("div", {
                key: "prepend",
                class: "v-switch__track-true"
              }, [a["track-true"](w)]), a["track-false"] && S("div", {
                key: "append",
                class: "v-switch__track-false"
              }, [a["track-false"](w)])]);
            },
            input: (T) => {
              let {
                inputNode: M,
                icon: W,
                backgroundColorClasses: J,
                backgroundColorStyles: ee
              } = T;
              return S(ye, null, [M, S("div", {
                class: le(["v-switch__thumb", {
                  "v-switch__thumb--filled": W || e.loading
                }, e.inset || f ? void 0 : J.value]),
                style: he(e.inset ? void 0 : ee.value)
              }, [a.thumb ? b(Be, {
                defaults: {
                  VIcon: {
                    icon: W,
                    size: "x-small"
                  }
                }
              }, {
                default: () => [a.thumb({
                  ...w,
                  icon: W
                })]
              }) : b(jc, null, {
                default: () => [e.loading ? b(ko, {
                  name: "v-switch",
                  active: !0,
                  color: I.value === !1 ? void 0 : v.value
                }, {
                  default: (Y) => a.loader ? a.loader(Y) : b(yl, {
                    active: Y.isActive,
                    color: Y.color,
                    indeterminate: !0,
                    size: "16",
                    width: "2"
                  }, null)
                }) : W && b(Ue, {
                  key: String(W),
                  icon: W,
                  size: "x-small"
                }, null)]
              })])]);
            }
          });
        }
      });
    }), Lt({}, c);
  }
}), FN = z({
  color: String,
  height: [Number, String],
  window: Boolean,
  ...ke(),
  ...Pt(),
  ...Cl(),
  ...ft(),
  ...Oe(),
  ...We()
}, "VSystemBar"), HN = ne()({
  name: "VSystemBar",
  props: FN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      backgroundColorClasses: l,
      backgroundColorStyles: i
    } = Xe(() => e.color), {
      elevationClasses: o
    } = Rt(e), {
      roundedClasses: r
    } = yt(e), {
      ssrBootStyles: s
    } = El(), d = x(() => e.height ?? (e.window ? 32 : 24)), {
      layoutItemStyles: u
    } = Vl({
      id: e.name,
      order: x(() => parseInt(e.order, 10)),
      position: fe("top"),
      layoutSize: d,
      elementSize: d,
      active: x(() => !0),
      absolute: R(() => e.absolute)
    });
    return re(() => b(e.tag, {
      class: le(["v-system-bar", {
        "v-system-bar--window": e.window
      }, a.value, l.value, o.value, r.value, e.class]),
      style: he([i.value, u.value, s.value, e.style])
    }, n)), {};
  }
}), Vd = Symbol.for("vuetify:v-tabs"), wp = z({
  fixed: Boolean,
  sliderColor: String,
  hideSlider: Boolean,
  direction: {
    type: String,
    default: "horizontal"
  },
  ...tt(Kr({
    selectedClass: "v-tab--selected",
    variant: "text"
  }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab"), _p = ne()({
  name: "VTab",
  props: wp(),
  setup(e, t) {
    let {
      slots: n,
      attrs: a
    } = t;
    const {
      textColorClasses: l,
      textColorStyles: i
    } = jt(() => e.sliderColor), o = Z(), r = Z(), s = x(() => e.direction === "horizontal"), d = x(() => {
      var c, f;
      return ((f = (c = o.value) == null ? void 0 : c.group) == null ? void 0 : f.isSelected.value) ?? !1;
    });
    function u(c) {
      var v, m;
      let {
        value: f
      } = c;
      if (f) {
        const h = (m = (v = o.value) == null ? void 0 : v.$el.parentElement) == null ? void 0 : m.querySelector(".v-tab--selected .v-tab__slider"), g = r.value;
        if (!h || !g) return;
        const p = getComputedStyle(h).color, y = h.getBoundingClientRect(), _ = g.getBoundingClientRect(), E = s.value ? "x" : "y", k = s.value ? "X" : "Y", P = s.value ? "right" : "bottom", A = s.value ? "width" : "height", D = y[E], N = _[E], V = D > N ? y[P] - _[P] : y[E] - _[E], I = Math.sign(V) > 0 ? s.value ? "right" : "bottom" : Math.sign(V) < 0 ? s.value ? "left" : "top" : "center", T = (Math.abs(V) + (Math.sign(V) < 0 ? y[A] : _[A])) / Math.max(y[A], _[A]) || 0, M = y[A] / _[A] || 0, W = 1.5;
        ga(g, {
          backgroundColor: [p, "currentcolor"],
          transform: [`translate${k}(${V}px) scale${k}(${M})`, `translate${k}(${V / W}px) scale${k}(${(T - 1) / W + 1})`, "none"],
          transformOrigin: Array(3).fill(I)
        }, {
          duration: 225,
          easing: qi
        });
      }
    }
    return re(() => {
      const c = Le.filterProps(e);
      return b(Le, Q({
        symbol: Vd,
        ref: o,
        class: ["v-tab", e.class],
        style: e.style,
        tabindex: d.value ? 0 : -1,
        role: "tab",
        "aria-selected": String(d.value),
        active: !1
      }, c, a, {
        block: e.fixed,
        maxWidth: e.fixed ? 300 : void 0,
        "onGroup:selected": u
      }), {
        ...n,
        default: () => {
          var f;
          return S(ye, null, [((f = n.default) == null ? void 0 : f.call(n)) ?? e.text, !e.hideSlider && S("div", {
            ref: r,
            class: le(["v-tab__slider", l.value]),
            style: he(i.value)
          }, null)]);
        }
      });
    }), Lt({}, o);
  }
}), zN = z({
  ...tt(Jr(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VTabsWindow"), xp = ne()({
  name: "VTabsWindow",
  props: zN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Me(Vd, null), l = Ee(e, "modelValue"), i = x({
      get() {
        var o;
        return l.value != null || !a ? l.value : (o = a.items.value.find((r) => a.selected.value.includes(r.id))) == null ? void 0 : o.value;
      },
      set(o) {
        l.value = o;
      }
    });
    return re(() => {
      const o = bl.filterProps(e);
      return b(bl, Q({
        _as: "VTabsWindow"
      }, o, {
        modelValue: i.value,
        "onUpdate:modelValue": (r) => i.value = r,
        class: ["v-tabs-window", e.class],
        style: e.style,
        mandatory: !1,
        touch: !1
      }), n);
    }), {};
  }
}), jN = z({
  ...Zr()
}, "VTabsWindowItem"), kp = ne()({
  name: "VTabsWindowItem",
  props: jN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return re(() => {
      const a = pl.filterProps(e);
      return b(pl, Q({
        _as: "VTabsWindowItem"
      }, a, {
        class: ["v-tabs-window-item", e.class],
        style: e.style
      }), n);
    }), {};
  }
});
function WN(e) {
  return e ? e.map((t) => Ki(t) ? t : {
    text: t,
    value: t
  }) : [];
}
const UN = z({
  alignTabs: {
    type: String,
    default: "start"
  },
  color: String,
  fixedTabs: Boolean,
  items: {
    type: Array,
    default: () => []
  },
  stacked: Boolean,
  bgColor: String,
  grow: Boolean,
  height: {
    type: [Number, String],
    default: void 0
  },
  hideSlider: Boolean,
  sliderColor: String,
  ...mn(wp(), ["spaced"]),
  ...qc({
    mandatory: "force",
    selectedClass: "v-tab-item--selected"
  }),
  ...Tt(),
  ...Oe()
}, "VTabs"), GN = ne()({
  name: "VTabs",
  props: UN(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      slots: a
    } = t;
    const l = Ee(e, "modelValue"), i = x(() => WN(e.items)), {
      densityClasses: o
    } = tn(e), {
      backgroundColorClasses: r,
      backgroundColorStyles: s
    } = Xe(() => e.bgColor), {
      scopeId: d
    } = Tl();
    return gt({
      VTab: {
        color: R(() => e.color),
        direction: R(() => e.direction),
        stacked: R(() => e.stacked),
        fixed: R(() => e.fixedTabs),
        sliderColor: R(() => e.sliderColor),
        hideSlider: R(() => e.hideSlider)
      }
    }), re(() => {
      const u = lo.filterProps(e), c = !!(a.window || e.items.length > 0);
      return S(ye, null, [b(lo, Q(u, {
        modelValue: l.value,
        "onUpdate:modelValue": (f) => l.value = f,
        class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
          "v-tabs--fixed-tabs": e.fixedTabs,
          "v-tabs--grow": e.grow,
          "v-tabs--stacked": e.stacked
        }, o.value, r.value, e.class],
        style: [{
          "--v-tabs-height": pe(e.height)
        }, s.value, e.style],
        role: "tablist",
        symbol: Vd
      }, d, n), {
        default: () => {
          var f;
          return [((f = a.default) == null ? void 0 : f.call(a)) ?? i.value.map((v) => {
            var m;
            return ((m = a.tab) == null ? void 0 : m.call(a, {
              item: v
            })) ?? b(_p, Q(v, {
              key: v.text,
              value: v.value,
              spaced: e.spaced
            }), {
              default: a[`tab.${v.value}`] ? () => {
                var h;
                return (h = a[`tab.${v.value}`]) == null ? void 0 : h.call(a, {
                  item: v
                });
              } : void 0
            });
          })];
        }
      }), c && b(xp, Q({
        modelValue: l.value,
        "onUpdate:modelValue": (f) => l.value = f,
        key: "tabs-window"
      }, d), {
        default: () => {
          var f;
          return [i.value.map((v) => {
            var m;
            return ((m = a.item) == null ? void 0 : m.call(a, {
              item: v
            })) ?? b(kp, {
              value: v.value
            }, {
              default: () => {
                var h;
                return (h = a[`item.${v.value}`]) == null ? void 0 : h.call(a, {
                  item: v
                });
              }
            });
          }), (f = a.window) == null ? void 0 : f.call(a)];
        }
      })]);
    }), {};
  }
}), KN = z({
  autoGrow: Boolean,
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  noResize: Boolean,
  rows: {
    type: [Number, String],
    default: 5,
    validator: (e) => !isNaN(parseFloat(e))
  },
  maxRows: {
    type: [Number, String],
    validator: (e) => !isNaN(parseFloat(e))
  },
  suffix: String,
  modelModifiers: Object,
  ...Gy(),
  ...Pa(),
  ...Io()
}, "VTextarea"), YN = ne()({
  name: "VTextarea",
  directives: {
    vIntersect: Hn
  },
  inheritAttrs: !1,
  props: KN(),
  emits: {
    "click:control": (e) => !0,
    "mousedown:control": (e) => !0,
    "update:focused": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:rows": (e) => !0
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: a,
      slots: l
    } = t;
    const i = Ee(e, "modelValue"), {
      isFocused: o,
      focus: r,
      blur: s
    } = Ea(e), {
      onIntersect: d
    } = Yy(e), u = x(() => typeof e.counterValue == "function" ? e.counterValue(i.value) : (i.value || "").toString().length), c = x(() => {
      if (n.maxlength) return n.maxlength;
      if (!(!e.counter || typeof e.counter != "number" && typeof e.counter != "string"))
        return e.counter;
    }), f = Z(), v = Z(), m = fe(""), h = Z(), g = Ky(e), p = x(() => e.persistentPlaceholder || o.value || e.active);
    function y() {
      var w;
      g.isSuppressing.value && g.update(), h.value !== document.activeElement && ((w = h.value) == null || w.focus()), o.value || r();
    }
    function _(w) {
      y(), a("click:control", w);
    }
    function E(w) {
      a("mousedown:control", w);
    }
    function k(w) {
      w.stopPropagation(), y(), He(() => {
        i.value = "", bo(e["onClick:clear"], w);
      });
    }
    function P(w) {
      var M;
      const T = w.target;
      if (i.value = T.value, (M = e.modelModifiers) != null && M.trim) {
        const W = [T.selectionStart, T.selectionEnd];
        He(() => {
          T.selectionStart = W[0], T.selectionEnd = W[1];
        });
      }
    }
    const A = Z(), D = Z(Number(e.rows)), N = x(() => ["plain", "underlined"].includes(e.variant));
    ut(() => {
      e.autoGrow || (D.value = Number(e.rows));
    });
    function V() {
      e.autoGrow && He(() => {
        if (!A.value || !v.value) return;
        const w = getComputedStyle(A.value), T = getComputedStyle(v.value.$el), M = parseFloat(w.getPropertyValue("--v-field-padding-top")) + parseFloat(w.getPropertyValue("--v-input-padding-top")) + parseFloat(w.getPropertyValue("--v-field-padding-bottom")), W = A.value.scrollHeight, J = parseFloat(w.lineHeight), ee = Math.max(parseFloat(e.rows) * J + M, parseFloat(T.getPropertyValue("--v-input-control-height"))), Y = parseFloat(e.maxRows) * J + M || 1 / 0, L = ot(W ?? 0, ee, Y);
        D.value = Math.floor((L - M) / J), m.value = pe(L);
      });
    }
    At(V), me(i, V), me(() => e.rows, V), me(() => e.maxRows, V), me(() => e.density, V), me(D, (w) => {
      a("update:rows", w);
    });
    let I;
    return me(A, (w) => {
      w ? (I = new ResizeObserver(V), I.observe(A.value)) : I == null || I.disconnect();
    }), Wt(() => {
      I == null || I.disconnect();
    }), re(() => {
      const w = !!(l.counter || e.counter || e.counterValue), T = !!(w || l.details), [M, W] = za(n), {
        modelValue: J,
        ...ee
      } = Kt.filterProps(e), Y = {
        ...Fa.filterProps(e),
        "onClick:clear": k
      };
      return b(Kt, Q({
        ref: f,
        modelValue: i.value,
        "onUpdate:modelValue": (L) => i.value = L,
        class: ["v-textarea v-text-field", {
          "v-textarea--prefixed": e.prefix,
          "v-textarea--suffixed": e.suffix,
          "v-text-field--prefixed": e.prefix,
          "v-text-field--suffixed": e.suffix,
          "v-textarea--auto-grow": e.autoGrow,
          "v-textarea--no-resize": e.noResize || e.autoGrow,
          "v-input--plain-underlined": N.value
        }, e.class],
        style: e.style
      }, M, ee, {
        centerAffix: D.value === 1 && !N.value,
        focused: o.value
      }), {
        ...l,
        default: (L) => {
          let {
            id: H,
            isDisabled: j,
            isDirty: U,
            isReadonly: F,
            isValid: oe,
            hasDetails: ve
          } = L;
          return b(Fa, Q({
            ref: v,
            style: {
              "--v-textarea-control-height": m.value
            },
            onClick: _,
            onMousedown: E,
            "onClick:prependInner": e["onClick:prependInner"],
            "onClick:appendInner": e["onClick:appendInner"]
          }, Y, {
            id: H.value,
            active: p.value || U.value,
            centerAffix: D.value === 1 && !N.value,
            dirty: U.value || e.dirty,
            disabled: j.value,
            focused: o.value,
            details: ve.value,
            error: oe.value === !1
          }), {
            ...l,
            default: (_e) => {
              let {
                props: {
                  class: B,
                  ...G
                }
              } = _e;
              return S(ye, null, [e.prefix && S("span", {
                class: "v-text-field__prefix"
              }, [e.prefix]), dt(S("textarea", Q({
                ref: h,
                class: B,
                value: i.value,
                onInput: P,
                autofocus: e.autofocus,
                readonly: F.value,
                disabled: j.value,
                placeholder: e.placeholder,
                rows: e.rows,
                name: g.fieldName.value,
                autocomplete: g.fieldAutocomplete.value,
                onFocus: y,
                onBlur: s
              }, G, W), null), [[Hn, {
                handler: d
              }, null, {
                once: !0
              }]]), e.autoGrow && dt(S("textarea", {
                class: le([B, "v-textarea__sizer"]),
                id: `${G.id}-sizer`,
                "onUpdate:modelValue": (ie) => i.value = ie,
                ref: A,
                readonly: !0,
                "aria-hidden": "true"
              }, null), [[$0, i.value]]), e.suffix && S("span", {
                class: "v-text-field__suffix"
              }, [e.suffix])]);
            }
          });
        },
        details: T ? (L) => {
          var H;
          return S(ye, null, [(H = l.details) == null ? void 0 : H.call(l, L), w && S(ye, null, [S("span", null, null), b(qr, {
            active: e.persistentCounter || o.value,
            value: u.value,
            max: c.value,
            disabled: e.disabled
          }, l.counter)])]);
        } : void 0
      });
    }), Lt({}, f, v, h);
  }
}), qN = z({
  withBackground: Boolean,
  ...ke(),
  ...We(),
  ...Oe()
}, "VThemeProvider"), XN = ne()({
  name: "VThemeProvider",
  props: qN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e);
    return () => {
      var l;
      return e.withBackground ? b(e.tag, {
        class: le(["v-theme-provider", a.value, e.class]),
        style: he(e.style)
      }, {
        default: () => {
          var i;
          return [(i = n.default) == null ? void 0 : i.call(n)];
        }
      }) : (l = n.default) == null ? void 0 : l.call(n);
    };
  }
}), JN = z({
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  icon: Ve,
  iconColor: String,
  lineColor: String,
  ...ke(),
  ...ft(),
  ...sa(),
  ...Pt()
}, "VTimelineDivider"), ZN = ne()({
  name: "VTimelineDivider",
  props: JN(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      sizeClasses: a,
      sizeStyles: l
    } = vi(e, "v-timeline-divider__dot"), {
      backgroundColorStyles: i,
      backgroundColorClasses: o
    } = Xe(() => e.dotColor), {
      roundedClasses: r
    } = yt(e, "v-timeline-divider__dot"), {
      elevationClasses: s
    } = Rt(e), {
      backgroundColorClasses: d,
      backgroundColorStyles: u
    } = Xe(() => e.lineColor);
    return re(() => S("div", {
      class: le(["v-timeline-divider", {
        "v-timeline-divider--fill-dot": e.fillDot
      }, e.class]),
      style: he(e.style)
    }, [S("div", {
      class: le(["v-timeline-divider__before", d.value]),
      style: he(u.value)
    }, null), !e.hideDot && S("div", {
      key: "dot",
      class: le(["v-timeline-divider__dot", s.value, r.value, a.value]),
      style: he(l.value)
    }, [S("div", {
      class: le(["v-timeline-divider__inner-dot", o.value, r.value]),
      style: he(i.value)
    }, [n.default ? b(Be, {
      key: "icon-defaults",
      disabled: !e.icon,
      defaults: {
        VIcon: {
          color: e.iconColor,
          icon: e.icon,
          size: e.size
        }
      }
    }, n.default) : b(Ue, {
      key: "icon",
      color: e.iconColor,
      icon: e.icon,
      size: e.size
    }, null)])]), S("div", {
      class: le(["v-timeline-divider__after", d.value]),
      style: he(u.value)
    }, null)])), {};
  }
}), Cp = z({
  density: String,
  dotColor: String,
  fillDot: Boolean,
  hideDot: Boolean,
  hideOpposite: {
    type: Boolean,
    default: void 0
  },
  icon: Ve,
  iconColor: String,
  lineInset: [Number, String],
  side: {
    type: String,
    validator: (e) => e == null || ["start", "end"].includes(e)
  },
  ...ke(),
  ...kt(),
  ...Pt(),
  ...ft(),
  ...sa(),
  ...Oe()
}, "VTimelineItem"), QN = ne()({
  name: "VTimelineItem",
  props: Cp(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      dimensionStyles: a
    } = Ct(e), l = fe(0), i = Z();
    return me(i, (o) => {
      var r;
      o && (l.value = ((r = o.$el.querySelector(".v-timeline-divider__dot")) == null ? void 0 : r.getBoundingClientRect().width) ?? 0);
    }, {
      flush: "post"
    }), re(() => {
      var o, r;
      return S("div", {
        class: le(["v-timeline-item", {
          "v-timeline-item--fill-dot": e.fillDot,
          "v-timeline-item--side-start": e.side === "start",
          "v-timeline-item--side-end": e.side === "end"
        }, e.class]),
        style: he([{
          "--v-timeline-dot-size": pe(l.value),
          "--v-timeline-line-inset": e.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${pe(e.lineInset)})` : pe(0)
        }, e.style])
      }, [S("div", {
        class: "v-timeline-item__body",
        style: he(a.value)
      }, [(o = n.default) == null ? void 0 : o.call(n)]), b(ZN, {
        ref: i,
        hideDot: e.hideDot,
        icon: e.icon,
        iconColor: e.iconColor,
        size: e.size,
        elevation: e.elevation,
        dotColor: e.dotColor,
        fillDot: e.fillDot,
        rounded: e.rounded
      }, {
        default: n.icon
      }), e.density !== "compact" && S("div", {
        class: "v-timeline-item__opposite"
      }, [!e.hideOpposite && ((r = n.opposite) == null ? void 0 : r.call(n))])]);
    }), {};
  }
}), eD = z({
  align: {
    type: String,
    default: "center",
    validator: (e) => ["center", "start"].includes(e)
  },
  direction: {
    type: String,
    default: "vertical",
    validator: (e) => ["vertical", "horizontal"].includes(e)
  },
  justify: {
    type: String,
    default: "auto",
    validator: (e) => ["auto", "center"].includes(e)
  },
  side: {
    type: String,
    validator: (e) => e == null || ["start", "end"].includes(e)
  },
  lineThickness: {
    type: [String, Number],
    default: 2
  },
  lineColor: String,
  truncateLine: {
    type: String,
    validator: (e) => ["start", "end", "both"].includes(e)
  },
  ...mn(Cp({
    lineInset: 0
  }), ["dotColor", "fillDot", "hideOpposite", "iconColor", "lineInset", "size"]),
  ...ke(),
  ...Tt(),
  ...Oe(),
  ...We()
}, "VTimeline"), tD = ne()({
  name: "VTimeline",
  props: eD(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      themeClasses: a
    } = Ye(e), {
      densityClasses: l
    } = tn(e), {
      rtlClasses: i
    } = Et();
    gt({
      VTimelineDivider: {
        lineColor: R(() => e.lineColor)
      },
      VTimelineItem: {
        density: R(() => e.density),
        dotColor: R(() => e.dotColor),
        fillDot: R(() => e.fillDot),
        hideOpposite: R(() => e.hideOpposite),
        iconColor: R(() => e.iconColor),
        lineColor: R(() => e.lineColor),
        lineInset: R(() => e.lineInset),
        size: R(() => e.size)
      }
    });
    const o = x(() => {
      const s = e.side ? e.side : e.density !== "default" ? "end" : null;
      return s && `v-timeline--side-${s}`;
    }), r = x(() => {
      const s = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
      switch (e.truncateLine) {
        case "both":
          return s;
        case "start":
          return s[0];
        case "end":
          return s[1];
        default:
          return null;
      }
    });
    return re(() => b(e.tag, {
      class: le(["v-timeline", `v-timeline--${e.direction}`, `v-timeline--align-${e.align}`, `v-timeline--justify-${e.justify}`, r.value, {
        "v-timeline--inset-line": !!e.lineInset
      }, a.value, l.value, o.value, i.value, e.class]),
      style: he([{
        "--v-timeline-line-thickness": pe(e.lineThickness)
      }, e.style])
    }, n)), {};
  }
});
function nl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  return String(e).padStart(t, "0");
}
const nD = z({
  allowedValues: Function,
  ampm: Boolean,
  color: String,
  disabled: Boolean,
  displayedValue: null,
  double: Boolean,
  format: {
    type: Function,
    default: (e) => e
  },
  max: {
    type: Number,
    required: !0
  },
  min: {
    type: Number,
    required: !0
  },
  scrollable: Boolean,
  readonly: Boolean,
  rotate: {
    type: Number,
    default: 0
  },
  step: {
    type: Number,
    default: 1
  },
  modelValue: {
    type: Number
  }
}, "VTimePickerClock"), Xu = ne()({
  name: "VTimePickerClock",
  props: nD(),
  emits: {
    change: (e) => !0,
    input: (e) => !0
  },
  setup(e, t) {
    let {
      emit: n
    } = t;
    const a = Z(null), l = Z(null), i = Z(void 0), o = Z(!1), r = Z(null), s = Z(null), d = dg((L) => n("change", L), 750), {
      textColorClasses: u,
      textColorStyles: c
    } = jt(() => e.color), {
      backgroundColorClasses: f,
      backgroundColorStyles: v
    } = Xe(() => e.color), m = x(() => e.max - e.min + 1), h = x(() => e.double ? m.value / 2 : m.value), g = x(() => 360 / h.value), p = x(() => g.value * Math.PI / 180), y = x(() => e.modelValue == null ? e.min : e.modelValue), _ = x(() => 0.62), E = x(() => {
      const L = [];
      for (let H = e.min; H <= e.max; H = H + e.step)
        L.push(H);
      return L;
    });
    me(() => e.modelValue, (L) => {
      i.value = L;
    });
    function k(L) {
      i.value !== L && (i.value = L), n("input", L);
    }
    function P(L) {
      return !e.allowedValues || e.allowedValues(L);
    }
    function A(L) {
      if (!e.scrollable || e.disabled) return;
      L.preventDefault();
      const H = Math.sign(-L.deltaY || 1);
      let j = y.value;
      do
        j = j + H, j = (j - e.min + m.value) % m.value + e.min;
      while (!P(j) && j !== y.value);
      j !== e.displayedValue && k(j), d(j);
    }
    function D(L) {
      return e.double && L - e.min >= h.value;
    }
    function N(L) {
      return D(L) ? _.value : 1;
    }
    function V(L) {
      const H = e.rotate * Math.PI / 180;
      return {
        x: Math.sin((L - e.min) * p.value + H) * N(L),
        y: -Math.cos((L - e.min) * p.value + H) * N(L)
      };
    }
    function I(L, H) {
      const j = (Math.round(L / g.value) + (H ? h.value : 0)) % m.value + e.min;
      return L < 360 - g.value / 2 ? j : H ? e.max - h.value + 1 : e.min;
    }
    function w(L) {
      const {
        x: H,
        y: j
      } = V(L);
      return {
        left: `${Math.round(50 + H * 50)}%`,
        top: `${Math.round(50 + j * 50)}%`
      };
    }
    function T(L, H) {
      const j = H.x - L.x, U = H.y - L.y;
      return Math.sqrt(j * j + U * U);
    }
    function M(L, H) {
      const j = 2 * Math.atan2(H.y - L.y - T(L, H), H.x - L.x);
      return Math.abs(j * 180 / Math.PI);
    }
    function W(L) {
      r.value === null && (r.value = L), s.value = L, k(L);
    }
    function J(L) {
      var Ce, C;
      if (L.preventDefault(), !o.value && L.type !== "click" || !a.value) return;
      const {
        width: H,
        top: j,
        left: U
      } = (Ce = a.value) == null ? void 0 : Ce.getBoundingClientRect(), {
        width: F
      } = ((C = l.value) == null ? void 0 : C.getBoundingClientRect()) ?? {
        width: 0
      }, {
        clientX: oe,
        clientY: ve
      } = "touches" in L ? L.touches[0] : L, _e = {
        x: H / 2,
        y: -H / 2
      }, B = {
        x: oe - U,
        y: j - ve
      }, G = Math.round(M(_e, B) - e.rotate + 360) % 360, ie = e.double && T(_e, B) < (F + F * _.value) / 4, de = Math.ceil(15 / g.value);
      let Se;
      for (let O = 0; O < de; O++)
        if (Se = I(G + O * g.value, ie), P(Se) || (Se = I(G - O * g.value, ie), P(Se))) return W(Se);
    }
    function ee(L) {
      e.disabled || (L.preventDefault(), window.addEventListener("mousemove", J), window.addEventListener("touchmove", J), window.addEventListener("mouseup", Y), window.addEventListener("touchend", Y), r.value = null, s.value = null, o.value = !0, J(L));
    }
    function Y(L) {
      L.stopPropagation(), window.removeEventListener("mousemove", J), window.removeEventListener("touchmove", J), window.removeEventListener("mouseup", Y), window.removeEventListener("touchend", Y), o.value = !1, s.value !== null && P(s.value) && n("change", s.value);
    }
    re(() => S("div", {
      class: le([{
        "v-time-picker-clock": !0,
        "v-time-picker-clock--indeterminate": e.modelValue == null,
        "v-time-picker-clock--readonly": e.readonly
      }]),
      onMousedown: ee,
      onTouchstart: ee,
      onWheel: A,
      ref: a
    }, [S("div", {
      class: "v-time-picker-clock__inner",
      ref: l
    }, [S("div", {
      class: le([{
        "v-time-picker-clock__hand": !0,
        "v-time-picker-clock__hand--inner": D(e.modelValue)
      }, u.value]),
      style: he([{
        transform: `rotate(${e.rotate + g.value * (y.value - e.min)}deg) scaleY(${N(y.value)})`
      }, c.value])
    }, null), E.value.map((L) => {
      const H = L === y.value;
      return S("div", {
        class: le([{
          "v-time-picker-clock__item": !0,
          "v-time-picker-clock__item--active": H,
          "v-time-picker-clock__item--disabled": e.disabled || !P(L)
        }, H && f.value]),
        style: he([w(L), H && v.value])
      }, [S("span", null, [e.format(L)])]);
    })])]));
  }
}), aD = z({
  ampm: Boolean,
  color: String,
  disabled: Boolean,
  hour: Number,
  minute: Number,
  second: Number,
  period: String,
  readonly: Boolean,
  useSeconds: Boolean,
  value: Number,
  viewMode: String
}, "VTimePickerControls"), Ju = ne()({
  name: "VTimePickerControls",
  props: aD(),
  emits: {
    "update:period": (e) => !0,
    "update:viewMode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      t: l
    } = nt();
    return re(() => {
      let i = e.hour;
      return e.ampm && (i = i ? (i - 1) % 12 + 1 : 12), S("div", {
        class: "v-time-picker-controls"
      }, [S("div", {
        class: le({
          "v-time-picker-controls__time": !0,
          "v-time-picker-controls__time--with-seconds": e.useSeconds
        })
      }, [b(Le, {
        active: e.viewMode === "hour",
        color: e.viewMode === "hour" ? e.color : void 0,
        disabled: e.disabled,
        variant: "tonal",
        class: le({
          "v-time-picker-controls__time__btn": !0,
          "v-time-picker-controls__time--with-ampm__btn": e.ampm,
          "v-time-picker-controls__time--with-seconds__btn": e.useSeconds
        }),
        text: e.hour == null ? "--" : nl(`${i}`),
        onClick: () => n("update:viewMode", "hour")
      }, null), S("span", {
        class: le(["v-time-picker-controls__time__separator", {
          "v-time-picker-controls--with-seconds__time__separator": e.useSeconds
        }])
      }, [ze(":")]), b(Le, {
        active: e.viewMode === "minute",
        color: e.viewMode === "minute" ? e.color : void 0,
        class: le({
          "v-time-picker-controls__time__btn": !0,
          "v-time-picker-controls__time__btn__active": e.viewMode === "minute",
          "v-time-picker-controls__time--with-ampm__btn": e.ampm,
          "v-time-picker-controls__time--with-seconds__btn": e.useSeconds
        }),
        disabled: e.disabled,
        variant: "tonal",
        text: e.minute == null ? "--" : nl(e.minute),
        onClick: () => n("update:viewMode", "minute")
      }, null), e.useSeconds && S("span", {
        class: le(["v-time-picker-controls__time__separator", {
          "v-time-picker-controls--with-seconds__time__separator": e.useSeconds
        }]),
        key: "secondsDivider"
      }, [ze(":")]), e.useSeconds && b(Le, {
        key: "secondsVal",
        active: e.viewMode === "second",
        color: e.viewMode === "second" ? e.color : void 0,
        variant: "tonal",
        onClick: () => n("update:viewMode", "second"),
        class: le({
          "v-time-picker-controls__time__btn": !0,
          "v-time-picker-controls__time__btn__active": e.viewMode === "second",
          "v-time-picker-controls__time--with-seconds__btn": e.useSeconds
        }),
        disabled: e.disabled,
        text: e.second == null ? "--" : nl(e.second)
      }, null), e.ampm && S("div", {
        class: "v-time-picker-controls__ampm"
      }, [b(Le, {
        active: e.period === "am",
        color: e.period === "am" ? e.color : void 0,
        class: le({
          "v-time-picker-controls__ampm__am": !0,
          "v-time-picker-controls__ampm__btn": !0,
          "v-time-picker-controls__ampm__btn__active": e.period === "am"
        }),
        disabled: e.disabled,
        text: l("$vuetify.timePicker.am"),
        variant: e.disabled && e.period === "am" ? "elevated" : "tonal",
        onClick: () => e.period !== "am" ? n("update:period", "am") : null
      }, null), b(Le, {
        active: e.period === "pm",
        color: e.period === "pm" ? e.color : void 0,
        class: le({
          "v-time-picker-controls__ampm__pm": !0,
          "v-time-picker-controls__ampm__btn": !0,
          "v-time-picker-controls__ampm__btn__active": e.period === "pm"
        }),
        disabled: e.disabled,
        text: l("$vuetify.timePicker.pm"),
        variant: e.disabled && e.period === "pm" ? "elevated" : "tonal",
        onClick: () => e.period !== "pm" ? n("update:period", "pm") : null
      }, null)])])]);
    }), {};
  }
}), lD = bn(24), Vp = bn(12), iD = Vp.map((e) => e + 12);
bn(60);
const oD = z({
  allowedHours: [Function, Array],
  allowedMinutes: [Function, Array],
  allowedSeconds: [Function, Array],
  disabled: Boolean,
  format: {
    type: String,
    default: "ampm"
  },
  max: String,
  min: String,
  viewMode: {
    type: String,
    default: "hour"
  },
  period: {
    type: String,
    default: "am",
    validator: (e) => ["am", "pm"].includes(e)
  },
  modelValue: null,
  readonly: Boolean,
  scrollable: Boolean,
  useSeconds: Boolean,
  ...tt(Qr({
    title: "$vuetify.timePicker.title"
  }), ["landscape"])
}, "VTimePicker"), rD = ne()({
  name: "VTimePicker",
  props: oD(),
  emits: {
    "update:hour": (e) => !0,
    "update:minute": (e) => !0,
    "update:period": (e) => !0,
    "update:second": (e) => !0,
    "update:modelValue": (e) => !0,
    "update:viewMode": (e) => !0
  },
  setup(e, t) {
    let {
      emit: n,
      slots: a
    } = t;
    const {
      t: l
    } = nt(), i = Z(null), o = Z(null), r = Z(null), s = Z(null), d = Z(null), u = Z(null), c = Ee(e, "period", "am"), f = Ee(e, "viewMode", "hour"), v = Z(null), m = Z(null), h = x(() => {
      let w;
      if (e.allowedHours instanceof Array ? w = (W) => e.allowedHours.includes(W) : w = e.allowedHours, !e.min && !e.max) return w;
      const T = e.min ? Number(e.min.split(":")[0]) : 0, M = e.max ? Number(e.max.split(":")[0]) : 23;
      return (W) => W >= Number(T) && W <= Number(M) && (!w || w(W));
    }), g = x(() => {
      let w;
      const T = !h.value || i.value === null || h.value(i.value);
      if (e.allowedMinutes instanceof Array ? w = (H) => e.allowedMinutes.includes(H) : w = e.allowedMinutes, !e.min && !e.max)
        return T ? w : () => !1;
      const [M, W] = e.min ? e.min.split(":").map(Number) : [0, 0], [J, ee] = e.max ? e.max.split(":").map(Number) : [23, 59], Y = M * 60 + Number(W), L = J * 60 + Number(ee);
      return (H) => {
        const j = 60 * i.value + H;
        return j >= Y && j <= L && T && (!w || w(H));
      };
    }), p = x(() => {
      let w;
      const M = (!h.value || i.value === null || h.value(i.value)) && (!g.value || o.value === null || g.value(o.value));
      if (e.allowedSeconds instanceof Array ? w = (F) => e.allowedSeconds.includes(F) : w = e.allowedSeconds, !e.min && !e.max)
        return M ? w : () => !1;
      const [W, J, ee] = e.min ? e.min.split(":").map(Number) : [0, 0, 0], [Y, L, H] = e.max ? e.max.split(":").map(Number) : [23, 59, 59], j = W * 3600 + J * 60 + Number(ee || 0), U = Y * 3600 + L * 60 + Number(H || 0);
      return (F) => {
        const oe = 3600 * i.value + 60 * o.value + F;
        return oe >= j && oe <= U && M && (!w || w(F));
      };
    }), y = x(() => e.format === "ampm");
    me(() => e.period, (w) => N(w)), me(() => e.modelValue, (w) => A(w)), At(() => {
      A(e.modelValue);
    });
    function _() {
      return i.value != null && o.value != null && (!e.useSeconds || r.value != null) ? `${nl(i.value)}:${nl(o.value)}` + (e.useSeconds ? `:${nl(r.value)}` : "") : null;
    }
    function E() {
      const w = _();
      w !== null && n("update:modelValue", w);
    }
    function k(w) {
      return w ? (w - 1) % 12 + 1 : 12;
    }
    function P(w, T) {
      return w % 12 + (T === "pm" ? 12 : 0);
    }
    function A(w) {
      if (w == null || w === "")
        i.value = null, o.value = null, r.value = null;
      else if (w instanceof Date)
        i.value = w.getHours(), o.value = w.getMinutes(), r.value = w.getSeconds();
      else {
        const [T, , M, , W, J] = w.trim().toLowerCase().match(/^(\d+):(\d+)(:(\d+))?([ap]m)?$/) || new Array(6);
        i.value = J ? P(parseInt(T, 10), J) : parseInt(T, 10), o.value = parseInt(M, 10), r.value = parseInt(W || 0, 10);
      }
      c.value = i.value == null || i.value < 12 ? "am" : "pm";
    }
    function D(w, T) {
      const M = h.value;
      if (!M) return T;
      const W = y.value ? T < 12 ? Vp : iD : lD;
      return ((W.find((ee) => M((ee + T) % W.length + W[0])) || 0) + T) % W.length + W[0];
    }
    function N(w) {
      if (c.value = w, i.value != null) {
        const T = i.value + (c.value === "am" ? -12 : 12);
        i.value = D("hour", T);
      }
      return n("update:period", w), E(), !0;
    }
    function V(w) {
      f.value === "hour" ? i.value = y.value ? P(w, c.value) : w : f.value === "minute" ? o.value = w : r.value = w;
    }
    function I(w) {
      switch (f.value || "hour") {
        case "hour":
          n("update:hour", w);
          break;
        case "minute":
          n("update:minute", w);
          break;
        case "second":
          n("update:second", w);
          break;
      }
      const T = i.value !== null && o.value !== null && (e.useSeconds ? r.value !== null : !0);
      f.value === "hour" ? f.value = "minute" : e.useSeconds && f.value === "minute" && (f.value = "second"), !(i.value === s.value && o.value === d.value && (!e.useSeconds || r.value === u.value) || _() === null) && (s.value = i.value, d.value = o.value, e.useSeconds && (u.value = r.value), T && E());
    }
    re(() => {
      const w = ui.filterProps(e), T = Ju.filterProps(e), M = Xu.filterProps(tt(e, ["format", "modelValue", "min", "max"]));
      return b(ui, Q(w, {
        color: void 0,
        class: ["v-time-picker", e.class],
        style: e.style
      }), {
        title: () => {
          var W;
          return ((W = a.title) == null ? void 0 : W.call(a)) ?? S("div", {
            class: "v-time-picker__title"
          }, [l(e.title)]);
        },
        header: () => b(Ju, Q(T, {
          ampm: y.value,
          hour: i.value,
          minute: o.value,
          period: c.value,
          second: r.value,
          viewMode: f.value,
          "onUpdate:period": (W) => N(W),
          "onUpdate:viewMode": (W) => f.value = W,
          ref: v
        }), null),
        default: () => b(Xu, Q(M, {
          allowedValues: f.value === "hour" ? h.value : f.value === "minute" ? g.value : p.value,
          double: f.value === "hour" && !y.value,
          format: f.value === "hour" ? y.value ? k : (W) => W : (W) => nl(W, 2),
          max: f.value === "hour" ? y.value && c.value === "am" ? 11 : 23 : 59,
          min: f.value === "hour" && y.value && c.value === "pm" ? 12 : 0,
          size: 20,
          step: f.value === "hour" ? 1 : 5,
          modelValue: f.value === "hour" ? i.value : f.value === "minute" ? o.value : r.value,
          onChange: I,
          onInput: V,
          ref: m
        }), null),
        actions: a.actions
      });
    });
  }
}), sD = z({
  ...ke(),
  ...Dn({
    variant: "text"
  })
}, "VToolbarItems"), uD = ne()({
  name: "VToolbarItems",
  props: sD(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return gt({
      VBtn: {
        color: R(() => e.color),
        height: "inherit",
        variant: R(() => e.variant)
      }
    }), re(() => {
      var a;
      return S("div", {
        class: le(["v-toolbar-items", e.class]),
        style: he(e.style)
      }, [(a = n.default) == null ? void 0 : a.call(n)]);
    }), {};
  }
}), cD = z({
  id: String,
  interactive: Boolean,
  text: String,
  ...tt(Po({
    closeOnBack: !1,
    location: "end",
    locationStrategy: "connected",
    eager: !0,
    minWidth: 0,
    offset: 10,
    openOnClick: !1,
    openOnHover: !0,
    origin: "auto",
    scrim: !1,
    scrollStrategy: "reposition",
    transition: null
  }), ["absolute", "persistent"])
}, "VTooltip"), Ep = ne()({
  name: "VTooltip",
  props: cD(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Ee(e, "modelValue"), {
      scopeId: l
    } = Tl(), i = Yt(), o = R(() => e.id || `v-tooltip-${i}`), r = Z(), s = x(() => e.location.split(" ").length > 1 ? e.location : e.location + " center"), d = x(() => e.origin === "auto" || e.origin === "overlap" || e.origin.split(" ").length > 1 || e.location.split(" ").length > 1 ? e.origin : e.origin + " center"), u = R(() => e.transition != null ? e.transition : a.value ? "scale-transition" : "fade-transition"), c = x(() => Q({
      "aria-describedby": o.value
    }, e.activatorProps));
    return re(() => {
      const f = oa.filterProps(e);
      return b(oa, Q({
        ref: r,
        class: ["v-tooltip", {
          "v-tooltip--interactive": e.interactive
        }, e.class],
        style: e.style,
        id: o.value
      }, f, {
        modelValue: a.value,
        "onUpdate:modelValue": (v) => a.value = v,
        transition: u.value,
        absolute: !0,
        location: s.value,
        origin: d.value,
        persistent: !0,
        role: "tooltip",
        activatorProps: c.value,
        _disableGlobalStack: !0
      }, l), {
        activator: n.activator,
        default: function() {
          var g;
          for (var v = arguments.length, m = new Array(v), h = 0; h < v; h++)
            m[h] = arguments[h];
          return ((g = n.default) == null ? void 0 : g.call(n, ...m)) ?? e.text;
        }
      });
    }), Lt({}, r);
  }
}), dD = z({
  ...tt(Iy({
    collapseIcon: "$treeviewCollapse",
    expandIcon: "$treeviewExpand"
  }), ["subgroup"])
}, "VTreeviewGroup"), Zu = ne()({
  name: "VTreeviewGroup",
  props: dD(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = Z(), l = x(() => {
      var o;
      return (o = a.value) != null && o.isOpen ? e.collapseIcon : e.expandIcon;
    }), i = x(() => ({
      VTreeviewItem: {
        prependIcon: void 0,
        appendIcon: void 0,
        toggleIcon: l.value
      }
    }));
    return re(() => {
      const o = oo.filterProps(e);
      return b(oo, Q(o, {
        ref: a,
        class: ["v-treeview-group", e.class],
        subgroup: !0
      }), {
        ...n,
        activator: n.activator ? (r) => S(ye, null, [b(Be, {
          defaults: i.value
        }, {
          default: () => {
            var s;
            return [(s = n.activator) == null ? void 0 : s.call(n, r)];
          }
        })]) : void 0
      });
    }), {};
  }
}), Pp = Symbol.for("vuetify:v-treeview"), Ip = z({
  loading: Boolean,
  hideActions: Boolean,
  hasCustomPrepend: Boolean,
  indentLines: Array,
  toggleIcon: Ve,
  ...Ay({
    slim: !0
  })
}, "VTreeviewItem"), Qu = ne()({
  name: "VTreeviewItem",
  props: Ip(),
  emits: {
    toggleExpand: (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const l = Me(Pp, {
      visibleIds: Z()
    }).visibleIds, i = Z(), o = x(() => {
      var f, v;
      return ((f = i.value) == null ? void 0 : f.root.activatable.value) && ((v = i.value) == null ? void 0 : v.isGroupActivator);
    }), r = x(() => {
      var f, v;
      return ((f = i.value) == null ? void 0 : f.link.isClickable.value) || e.value != null && !!((v = i.value) != null && v.list);
    }), s = x(() => !e.disabled && e.link !== !1 && (e.link || r.value || o.value)), d = x(() => {
      var f;
      return l.value && !l.value.has(Pe((f = i.value) == null ? void 0 : f.id));
    });
    function u(f) {
      var v, m;
      s.value && o.value && ((m = i.value) == null || m.activate(!((v = i.value) != null && v.isActivated), f));
    }
    function c(f) {
      f.preventDefault(), f.stopPropagation(), a("toggleExpand", f);
    }
    return re(() => {
      var m;
      const f = zn.filterProps(e), v = n.prepend || e.toggleIcon || e.indentLines || e.prependIcon || e.prependAvatar;
      return b(zn, Q({
        ref: i
      }, f, {
        active: ((m = i.value) == null ? void 0 : m.isActivated) || void 0,
        class: ["v-treeview-item", {
          "v-treeview-item--activatable-group-activator": o.value,
          "v-treeview-item--filtered": d.value
        }, e.class],
        ripple: !1,
        onClick: u
      }), {
        ...n,
        prepend: v ? (h) => {
          var g;
          return S(ye, null, [e.indentLines && e.indentLines.length > 0 ? S("div", {
            key: "indent-lines",
            class: "v-treeview-indent-lines",
            style: {
              "--v-indent-parts": e.indentLines.length
            }
          }, [e.indentLines.map((p) => S("div", {
            class: le(`v-treeview-indent-line v-treeview-indent-line--${p}`)
          }, null))]) : "", !e.hideActions && b(Qc, {
            start: !0
          }, {
            default: () => [e.toggleIcon ? S(ye, null, [n.toggle ? b(Be, {
              key: "prepend-defaults",
              defaults: {
                VBtn: {
                  density: "compact",
                  icon: e.toggleIcon,
                  variant: "text",
                  loading: e.loading
                },
                VProgressCircular: {
                  indeterminate: "disable-shrink",
                  size: 20,
                  width: 2
                }
              }
            }, {
              default: () => [n.toggle({
                ...h,
                loading: e.loading,
                props: {
                  onClick: c
                }
              })]
            }) : b(Le, {
              key: "prepend-toggle",
              density: "compact",
              icon: e.toggleIcon,
              loading: e.loading,
              variant: "text",
              onClick: c
            }, {
              loader: () => b(yl, {
                indeterminate: "disable-shrink",
                size: "20",
                width: "2"
              }, null)
            })]) : S("div", {
              class: "v-treeview-item__level"
            }, null)]
          }), e.hasCustomPrepend ? b(Be, {
            key: "prepend-defaults",
            defaults: {
              VAvatar: {
                density: e.density,
                image: e.appendAvatar
              },
              VIcon: {
                density: e.density,
                icon: e.appendIcon
              },
              VListItemAction: {
                start: !0
              }
            }
          }, {
            default: () => {
              var p;
              return [(p = n.prepend) == null ? void 0 : p.call(n, h)];
            }
          }) : S(ye, null, [(g = n.prepend) == null ? void 0 : g.call(n, h), e.prependAvatar && b(kn, {
            key: "prepend-avatar",
            density: e.density,
            image: e.prependAvatar
          }, null), e.prependIcon && b(Ue, {
            key: "prepend-icon",
            density: e.density,
            icon: e.prependIcon
          }, null)])]);
        } : void 0
      });
    }), Lt({}, i);
  }
}), Np = z({
  fluid: Boolean,
  disabled: Boolean,
  loadChildren: Function,
  loadingIcon: {
    type: String,
    default: "$loading"
  },
  items: Array,
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  indeterminateIcon: {
    type: Ve,
    default: "$checkboxIndeterminate"
  },
  falseIcon: Ve,
  trueIcon: Ve,
  returnObject: Boolean,
  activatable: Boolean,
  selectable: Boolean,
  selectedColor: String,
  selectStrategy: [String, Function, Object],
  index: Number,
  isLastGroup: Boolean,
  separateRoots: Boolean,
  parentIndentLines: Array,
  indentLinesVariant: String,
  path: {
    type: Array,
    default: () => []
  },
  ...mn(Ip(), ["hideActions"]),
  ...Tt()
}, "VTreeviewChildren"), Vr = ne()({
  name: "VTreeviewChildren",
  props: Np(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = It(/* @__PURE__ */ new Set()), l = Z([]), i = x(() => !e.disabled && (e.openOnClick != null ? e.openOnClick : e.selectable && !e.activatable));
    async function o(s) {
      var d, u;
      try {
        if (!((d = e.items) != null && d.length) || !e.loadChildren) return;
        ((u = s == null ? void 0 : s.children) == null ? void 0 : u.length) === 0 && (a.add(s.value), await e.loadChildren(s.raw));
      } finally {
        a.delete(s.value);
      }
    }
    function r(s, d) {
      e.selectable && s(d);
    }
    return () => {
      var s, d;
      return ((s = n.default) == null ? void 0 : s.call(n)) ?? ((d = e.items) == null ? void 0 : d.map((u, c, f) => {
        var D, N;
        const {
          children: v,
          props: m
        } = u, h = a.has(u.value), g = !!((D = f.at(c + 1)) != null && D.children), p = ((N = e.path) == null ? void 0 : N.length) ?? 0, y = f.length - 1 === c, _ = {
          index: c,
          depth: p,
          isFirst: c === 0,
          isLast: y,
          path: [...e.path, c],
          hideAction: e.hideActions
        }, E = dk({
          depth: p,
          isLast: y,
          isLastGroup: e.isLastGroup,
          leafLinks: !e.hideActions && !e.fluid,
          separateRoots: e.separateRoots,
          parentIndentLines: e.parentIndentLines,
          variant: e.indentLinesVariant
        }), k = {
          toggle: n.toggle ? (V) => {
            var I;
            return (I = n.toggle) == null ? void 0 : I.call(n, {
              ...V,
              ..._,
              item: u.raw,
              internalItem: u,
              loading: h
            });
          } : void 0,
          prepend: (V) => {
            var I;
            return S(ye, null, [e.selectable && (!v || v && !["leaf", "single-leaf"].includes(e.selectStrategy)) && b(Qc, {
              start: !0
            }, {
              default: () => [b(ia, {
                key: u.value,
                modelValue: V.isSelected,
                disabled: e.disabled,
                loading: h,
                color: e.selectedColor,
                density: e.density,
                indeterminate: V.isIndeterminate,
                indeterminateIcon: e.indeterminateIcon,
                falseIcon: e.falseIcon,
                trueIcon: e.trueIcon,
                "onUpdate:modelValue": (w) => r(V.select, w),
                onClick: (w) => w.stopPropagation(),
                onKeydown: (w) => {
                  ["Enter", "Space"].includes(w.key) && (w.stopPropagation(), r(V.select, V.isSelected));
                }
              }, null)]
            }), (I = n.prepend) == null ? void 0 : I.call(n, {
              ...V,
              ..._,
              item: u.raw,
              internalItem: u
            })]);
          },
          append: n.append ? (V) => {
            var I;
            return (I = n.append) == null ? void 0 : I.call(n, {
              ...V,
              ..._,
              item: u.raw,
              internalItem: u
            });
          } : void 0,
          title: n.title ? (V) => {
            var I;
            return (I = n.title) == null ? void 0 : I.call(n, {
              ...V,
              item: u.raw,
              internalItem: u
            });
          } : void 0,
          subtitle: n.subtitle ? (V) => {
            var I;
            return (I = n.subtitle) == null ? void 0 : I.call(n, {
              ...V,
              item: u.raw,
              internalItem: u
            });
          } : void 0
        }, P = Zu.filterProps(m), A = Vr.filterProps({
          ...e,
          ..._
        });
        return v ? b(Zu, Q(P, {
          value: e.returnObject ? u.raw : P == null ? void 0 : P.value,
          rawId: P == null ? void 0 : P.value
        }), {
          activator: (V) => {
            let {
              props: I
            } = V;
            const w = {
              ...m,
              ...I,
              value: m == null ? void 0 : m.value,
              onToggleExpand: [() => o(u), I.onClick],
              onClick: i.value ? [() => o(u), I.onClick] : () => {
                var T, M;
                return r((T = l.value[c]) == null ? void 0 : T.select, !((M = l.value[c]) != null && M.isSelected));
              }
            };
            return Ro(n.header, {
              props: w,
              item: u.raw,
              internalItem: u,
              loading: h
            }, () => b(Qu, Q({
              ref: (T) => l.value[c] = T
            }, w, {
              hasCustomPrepend: !!n.prepend,
              hideActions: e.hideActions,
              indentLines: E.node,
              value: e.returnObject ? u.raw : m.value,
              loading: h
            }), k));
          },
          default: () => b(Vr, Q(A, {
            items: v,
            indentLinesVariant: e.indentLinesVariant,
            parentIndentLines: E.children,
            isLastGroup: g,
            returnObject: e.returnObject
          }), n)
        }) : Ro(n.item, {
          props: m,
          item: u.raw,
          internalItem: u
        }, () => u.type === "divider" ? Ro(n.divider, {
          props: u.raw
        }, () => b(Sn, u.props, null)) : u.type === "subheader" ? Ro(n.subheader, {
          props: u.raw
        }, () => b(pi, u.props, null)) : b(Qu, Q(m, {
          hasCustomPrepend: !!n.prepend,
          hideActions: e.hideActions,
          indentLines: E.leaf,
          value: e.returnObject ? Pe(u.raw) : m.value
        }), k));
      }));
    };
  }
});
function Dp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  for (const n of e)
    t.push(n), n.children && Dp(n.children, t);
  return t;
}
const fD = z({
  openAll: Boolean,
  indentLines: [Boolean, String],
  search: String,
  ...Si({
    filterKeys: ["title"]
  }),
  ...tt(Np(), ["index", "path", "indentLinesVariant", "parentIndentLines", "isLastGroup"]),
  ...tt(Ry({
    collapseIcon: "$treeviewCollapse",
    expandIcon: "$treeviewExpand",
    slim: !0
  }), ["nav", "openStrategy"]),
  modelValue: Array
}, "VTreeview"), vD = ne()({
  name: "VTreeview",
  props: fD(),
  emits: {
    "update:opened": (e) => !0,
    "update:activated": (e) => !0,
    "update:selected": (e) => !0,
    "update:modelValue": (e) => !0,
    "click:open": (e) => !0,
    "click:select": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n,
      emit: a
    } = t;
    const {
      items: l
    } = My(e), i = R(() => e.activeColor), o = R(() => e.baseColor), r = R(() => e.color), s = Ee(e, "activated"), d = Ee(e, "selected"), u = x({
      get: () => e.modelValue ?? d.value,
      set(_) {
        d.value = _, a("update:modelValue", _);
      }
    }), c = Z(), f = x(() => e.openAll ? y(l.value) : e.opened), v = x(() => Dp(l.value)), m = R(() => e.search), {
      filteredItems: h
    } = wi(e, v, m), g = x(() => {
      var E;
      if (!m.value) return null;
      const _ = (E = c.value) == null ? void 0 : E.getPath;
      return _ ? new Set(h.value.flatMap((k) => {
        const P = e.returnObject ? k.raw : k.props.value;
        return [..._(P), ...p(P)].map(Pe);
      })) : null;
    });
    function p(_) {
      var P, A;
      const E = [], k = (((P = c.value) == null ? void 0 : P.children.get(_)) ?? []).slice();
      for (; k.length; ) {
        const D = k.shift();
        D && (E.push(D), k.push(...(((A = c.value) == null ? void 0 : A.children.get(D)) ?? []).slice()));
      }
      return E;
    }
    function y(_) {
      let E = [];
      for (const k of _)
        k.children && (E.push(e.returnObject ? Pe(k.raw) : k.value), k.children && (E = E.concat(y(k.children))));
      return E;
    }
    return at(Pp, {
      visibleIds: g
    }), gt({
      VTreeviewGroup: {
        activeColor: i,
        baseColor: o,
        color: r,
        collapseIcon: R(() => e.collapseIcon),
        expandIcon: R(() => e.expandIcon)
      },
      VTreeviewItem: {
        activeClass: R(() => e.activeClass),
        activeColor: i,
        baseColor: o,
        color: r,
        density: R(() => e.density),
        disabled: R(() => e.disabled),
        lines: R(() => e.lines),
        variant: R(() => e.variant)
      }
    }), re(() => {
      const _ = ri.filterProps(e), E = Vr.filterProps(e), k = typeof e.indentLines == "boolean" ? "default" : e.indentLines;
      return b(ri, Q({
        ref: c
      }, _, {
        class: ["v-treeview", {
          "v-treeview--fluid": e.fluid
        }, e.class],
        openStrategy: "multiple",
        style: e.style,
        opened: f.value,
        activated: s.value,
        "onUpdate:activated": (P) => s.value = P,
        selected: u.value,
        "onUpdate:selected": (P) => u.value = P
      }), {
        default: () => [b(Vr, Q(E, {
          density: e.density,
          returnObject: e.returnObject,
          items: l.value,
          parentIndentLines: e.indentLines ? [] : void 0,
          indentLinesVariant: k
        }), n)]
      });
    }), {};
  }
}), mD = ne()({
  name: "VValidation",
  props: hy(),
  emits: {
    "update:modelValue": (e) => !0
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const a = gy(e, "validation");
    return () => {
      var l;
      return (l = n.default) == null ? void 0 : l.call(n, a);
    };
  }
}), hD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  VAlert: kV,
  VAlertTitle: sy,
  VApp: PC,
  VAppBar: qC,
  VAppBarNavIcon: bV,
  VAppBarTitle: pV,
  VAutocomplete: W1,
  VAvatar: kn,
  VBadge: G1,
  VBanner: q1,
  VBannerActions: Qy,
  VBannerText: eb,
  VBottomNavigation: J1,
  VBottomSheet: Q1,
  VBreadcrumbs: aE,
  VBreadcrumbsDivider: nb,
  VBreadcrumbsItem: ab,
  VBtn: Le,
  VBtnGroup: Vu,
  VBtnToggle: tV,
  VCard: uE,
  VCardActions: lb,
  VCardItem: rb,
  VCardSubtitle: ib,
  VCardText: sb,
  VCardTitle: ob,
  VCarousel: bE,
  VCarouselItem: SE,
  VCheckbox: $V,
  VCheckboxBtn: ia,
  VChip: bi,
  VChipGroup: FV,
  VClassIcon: Fc,
  VCode: wE,
  VCol: KP,
  VColorPicker: uP,
  VCombobox: dP,
  VComponentIcon: xu,
  VConfirmEdit: vP,
  VContainer: jP,
  VCounter: qr,
  VDataIterator: xP,
  VDataTable: MP,
  VDataTableFooter: so,
  VDataTableHeaders: Sl,
  VDataTableRow: Sd,
  VDataTableRows: wl,
  VDataTableServer: HP,
  VDataTableVirtual: LP,
  VDatePicker: iI,
  VDatePickerControls: zu,
  VDatePickerHeader: ju,
  VDatePickerMonth: Wu,
  VDatePickerMonths: Uu,
  VDatePickerYears: Gu,
  VDefaultsProvider: Be,
  VDialog: Ou,
  VDialogBottomTransition: AC,
  VDialogTopTransition: TC,
  VDialogTransition: jr,
  VDivider: Sn,
  VEmptyState: rI,
  VExpandTransition: Wr,
  VExpandXTransition: Uc,
  VExpansionPanel: sI,
  VExpansionPanelText: Ku,
  VExpansionPanelTitle: Yu,
  VExpansionPanels: dI,
  VFab: vI,
  VFabTransition: DC,
  VFadeTransition: eo,
  VField: Fa,
  VFieldLabel: Ai,
  VFileInput: pI,
  VFooter: wI,
  VForm: xI,
  VHover: CI,
  VIcon: Ue,
  VImg: Sa,
  VInfiniteScroll: EI,
  VInput: Kt,
  VItem: NI,
  VItemGroup: II,
  VKbd: AI,
  VLabel: gi,
  VLayout: OI,
  VLayoutItem: BI,
  VLazy: RI,
  VLigatureIcon: vC,
  VList: ri,
  VListGroup: oo,
  VListImg: o1,
  VListItem: zn,
  VListItemAction: Qc,
  VListItemMedia: u1,
  VListItemSubtitle: Ny,
  VListItemTitle: Dy,
  VListSubheader: pi,
  VLocaleProvider: FI,
  VMain: zI,
  VMenu: si,
  VMessages: vy,
  VNavigationDrawer: JI,
  VNoSsr: ZI,
  VNumberInput: aN,
  VOtpInput: iN,
  VOverlay: oa,
  VPagination: Fu,
  VParallax: sN,
  VProgressCircular: yl,
  VProgressLinear: Ur,
  VRadio: cN,
  VRadioGroup: fN,
  VRangeSlider: mN,
  VRating: gN,
  VResponsive: ku,
  VRow: eI,
  VScaleTransition: jc,
  VScrollXReverseTransition: $C,
  VScrollXTransition: OC,
  VScrollYReverseTransition: MC,
  VScrollYTransition: BC,
  VSelect: sd,
  VSelectionControl: La,
  VSelectionControlGroup: cy,
  VSheet: ro,
  VSkeletonLoader: SN,
  VSlideGroup: lo,
  VSlideGroupItem: wN,
  VSlideXReverseTransition: LC,
  VSlideXTransition: RC,
  VSlideYReverseTransition: FC,
  VSlideYTransition: Wc,
  VSlider: Lu,
  VSnackbar: qu,
  VSnackbarQueue: kN,
  VSpacer: ep,
  VSparkline: PN,
  VSpeedDial: NN,
  VStepper: MN,
  VStepperActions: gp,
  VStepperHeader: yp,
  VStepperItem: bp,
  VStepperWindow: pp,
  VStepperWindowItem: Sp,
  VSvgIcon: Lc,
  VSwitch: LN,
  VSystemBar: HN,
  VTab: _p,
  VTable: _l,
  VTabs: GN,
  VTabsWindow: xp,
  VTabsWindowItem: kp,
  VTextField: wa,
  VTextarea: YN,
  VThemeProvider: XN,
  VTimePicker: rD,
  VTimePickerClock: Xu,
  VTimePickerControls: Ju,
  VTimeline: tD,
  VTimelineItem: QN,
  VToolbar: Cu,
  VToolbarItems: uD,
  VToolbarTitle: zc,
  VTooltip: Ep,
  VTreeview: vD,
  VTreeviewGroup: Zu,
  VTreeviewItem: Qu,
  VValidation: mD,
  VVirtualScroll: Xr,
  VWindow: bl,
  VWindowItem: pl
}, Symbol.toStringTag, { value: "Module" }));
function gD(e, t) {
  const n = t.modifiers || {}, a = t.value, {
    once: l,
    immediate: i,
    ...o
  } = n, r = !Object.keys(o).length, {
    handler: s,
    options: d
  } = typeof a == "object" ? a : {
    handler: a,
    options: {
      attributes: (o == null ? void 0 : o.attr) ?? r,
      characterData: (o == null ? void 0 : o.char) ?? r,
      childList: (o == null ? void 0 : o.child) ?? r,
      subtree: (o == null ? void 0 : o.sub) ?? r
    }
  }, u = new MutationObserver(function() {
    let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], f = arguments.length > 1 ? arguments[1] : void 0;
    s == null || s(c, f), l && Ap(e, t);
  });
  i && (s == null || s([], u)), e._mutate = Object(e._mutate), e._mutate[t.instance.$.uid] = {
    observer: u
  }, u.observe(e, d);
}
function Ap(e, t) {
  var n;
  (n = e._mutate) != null && n[t.instance.$.uid] && (e._mutate[t.instance.$.uid].observer.disconnect(), delete e._mutate[t.instance.$.uid]);
}
const yD = {
  mounted: gD,
  unmounted: Ap
};
function bD(e, t) {
  var l, i;
  const n = t.value, a = {
    passive: !((l = t.modifiers) != null && l.active)
  };
  window.addEventListener("resize", n, a), e._onResize = Object(e._onResize), e._onResize[t.instance.$.uid] = {
    handler: n,
    options: a
  }, (i = t.modifiers) != null && i.quiet || n();
}
function pD(e, t) {
  var l;
  if (!((l = e._onResize) != null && l[t.instance.$.uid])) return;
  const {
    handler: n,
    options: a
  } = e._onResize[t.instance.$.uid];
  window.removeEventListener("resize", n, a), delete e._onResize[t.instance.$.uid];
}
const SD = {
  mounted: bD,
  unmounted: pD
};
function Tp(e, t) {
  const {
    self: n = !1
  } = t.modifiers ?? {}, a = t.value, l = typeof a == "object" && a.options || {
    passive: !0
  }, i = typeof a == "function" || "handleEvent" in a ? a : a.handler, o = n ? e : t.arg ? document.querySelector(t.arg) : window;
  o && (o.addEventListener("scroll", i, l), e._onScroll = Object(e._onScroll), e._onScroll[t.instance.$.uid] = {
    handler: i,
    options: l,
    // Don't reference self
    target: n ? void 0 : o
  });
}
function Op(e, t) {
  var i;
  if (!((i = e._onScroll) != null && i[t.instance.$.uid])) return;
  const {
    handler: n,
    options: a,
    target: l = e
  } = e._onScroll[t.instance.$.uid];
  l.removeEventListener("scroll", n, a), delete e._onScroll[t.instance.$.uid];
}
function wD(e, t) {
  t.value !== t.oldValue && (Op(e, t), Tp(e, t));
}
const _D = {
  mounted: Tp,
  unmounted: Op,
  updated: wD
};
function xD(e, t) {
  const n = typeof e == "string" ? xe(e) : e, a = kD(n, t);
  return {
    mounted: a,
    updated: a,
    unmounted(l) {
      Fh(null, l);
    }
  };
}
function kD(e, t) {
  return function(n, a, l) {
    var c, f, v;
    const i = typeof t == "function" ? t(a) : t, o = ((c = a.value) == null ? void 0 : c.text) ?? a.value ?? (i == null ? void 0 : i.text), r = Ki(a.value) ? a.value : {}, s = () => o ?? n.textContent, d = (l.ctx === a.instance.$ ? (f = CD(l, a.instance.$)) == null ? void 0 : f.provides : (v = l.ctx) == null ? void 0 : v.provides) ?? a.instance.$.provides, u = jn(e, Q(i, r), s);
    u.appContext = Object.assign(/* @__PURE__ */ Object.create(null), a.instance.$.appContext, {
      provides: d
    }), Fh(u, n);
  };
}
function CD(e, t) {
  const n = /* @__PURE__ */ new Set(), a = (i) => {
    var o, r;
    for (const s of i) {
      if (!s) continue;
      if (s === e || s.el && e.el && s.el === e.el)
        return !0;
      n.add(s);
      let d;
      if (s.suspense ? d = a([s.ssContent]) : Array.isArray(s.children) ? d = a(s.children) : (o = s.component) != null && o.vnode && (d = a([(r = s.component) == null ? void 0 : r.subTree])), d)
        return d;
      n.delete(s);
    }
    return !1;
  };
  if (!a([t.subTree]))
    return li("Could not find original vnode, component will not inherit provides"), t;
  const l = Array.from(n).reverse();
  for (const i of l)
    if (i.component)
      return i.component;
  return t;
}
const VD = xD(Ep, (e) => {
  var t;
  return {
    activator: "parent",
    location: (t = e.arg) == null ? void 0 : t.replace("-", " "),
    text: typeof e.value == "boolean" ? void 0 : e.value
  };
}), ED = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ClickOutside: Tu,
  Intersect: Hn,
  Mutate: yD,
  Resize: SD,
  Ripple: en,
  Scroll: _D,
  Tooltip: VD,
  Touch: Cr
}, Symbol.toStringTag, { value: "Module" })), Ua = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, l] of t)
    n[a] = l;
  return n;
}, PD = { class: "search-bar" }, ID = {
  key: 1,
  class: "filters-section mt-3"
}, ND = {
  __name: "SearchBar",
  props: {
    //   
    modelValue: {
      type: String,
      default: ""
    },
    // 
    placeholder: {
      type: String,
      default: "..."
    },
    //  
    prependIcon: {
      type: String,
      default: "mdi-magnify"
    },
    //  
    appendIcon: {
      type: String,
      default: ""
    },
    //  
    loading: {
      type: Boolean,
      default: !1
    },
    //   
    clearable: {
      type: Boolean,
      default: !0
    },
    //  
    variant: {
      type: String,
      default: "outlined"
    },
    // 
    density: {
      type: String,
      default: "default"
    },
    //   
    hideDetails: {
      type: Boolean,
      default: !0
    },
    // Solo 
    solo: {
      type: Boolean,
      default: !1
    },
    // Filled 
    filled: {
      type: Boolean,
      default: !1
    },
    // Outlined 
    outlined: {
      type: Boolean,
      default: !1
    },
    //   
    showSuggestions: {
      type: Boolean,
      default: !1
    },
    //  
    suggestions: {
      type: Array,
      default: () => []
    },
    //  
    showFilters: {
      type: Boolean,
      default: !1
    },
    //    
    genreFilter: {
      type: Boolean,
      default: !1
    },
    //    
    priceFilter: {
      type: Boolean,
      default: !1
    },
    //  
    sortOptions: {
      type: Array,
      default: () => []
    },
    //    
    searchOnInput: {
      type: Boolean,
      default: !1
    },
    //    ()
    debounceTime: {
      type: Number,
      default: 500
    }
  },
  emits: [
    "update:modelValue",
    "search",
    "clear",
    "input",
    "filter-change",
    "suggestion-select"
  ],
  setup(e, { emit: t }) {
    const n = e, a = t, l = Z(n.modelValue), i = Z(!1), o = Z(null), r = Z(null), s = Z(n.sortOptions.length > 0 ? n.sortOptions[0].value : null), d = Z(null), u = [
      "",
      "",
      "",
      "RPG",
      "",
      "",
      "",
      "",
      "",
      ""
    ], c = [
      { title: "", value: "free" },
      { title: " 500", value: "0-500" },
      { title: "500 - 1000", value: "500-1000" },
      { title: "1000 - 2000", value: "1000-2000" },
      { title: " 2000", value: "2000+" }
    ];
    me(() => n.modelValue, (p) => {
      l.value = p;
    }), me(l, (p) => {
      a("update:modelValue", p), a("input", p), n.searchOnInput && (clearTimeout(d.value), d.value = setTimeout(() => {
        f();
      }, n.debounceTime)), n.showSuggestions && p && n.suggestions.length > 0 ? i.value = !0 : i.value = !1;
    });
    const f = () => {
      const p = {
        genre: o.value,
        priceRange: r.value,
        sort: s.value
      };
      a("search", {
        query: l.value,
        filters: p
      });
    }, v = () => {
      l.value = "", i.value = !1, a("clear");
    }, m = (p) => {
    }, h = (p) => {
      const y = p.title || p;
      l.value = y, i.value = !1, a("suggestion-select", p), f();
    }, g = () => {
      a("filter-change", {
        genre: o.value,
        priceRange: r.value,
        sort: s.value
      }), l.value && f();
    };
    return (p, y) => {
      const _ = xe("v-text-field"), E = xe("v-img"), k = xe("v-avatar"), P = xe("v-list-item"), A = xe("v-list"), D = xe("v-menu"), N = xe("v-select"), V = xe("v-col"), I = xe("v-row");
      return De(), Qe("div", PD, [
        b(_, {
          modelValue: l.value,
          "onUpdate:modelValue": y[0] || (y[0] = (w) => l.value = w),
          placeholder: e.placeholder,
          "prepend-inner-icon": e.prependIcon,
          "append-inner-icon": e.appendIcon,
          loading: e.loading,
          clearable: e.clearable,
          variant: e.variant,
          density: e.density,
          "hide-details": e.hideDetails,
          solo: e.solo,
          filled: e.filled,
          outlined: e.outlined,
          class: "search-input",
          "onClick:appendInner": f,
          "onClick:clear": v,
          onKeyup: Rh(f, ["enter"]),
          onInput: m
        }, Zl({ _: 2 }, [
          p.$slots.prepend ? {
            name: "prepend",
            fn: ge(() => [
              Ys(p.$slots, "prepend", {}, void 0, !0)
            ]),
            key: "0"
          } : void 0,
          p.$slots.append ? {
            name: "append",
            fn: ge(() => [
              Ys(p.$slots, "append", {}, void 0, !0)
            ]),
            key: "1"
          } : void 0
        ]), 1032, ["modelValue", "placeholder", "prepend-inner-icon", "append-inner-icon", "loading", "clearable", "variant", "density", "hide-details", "solo", "filled", "outlined"]),
        e.showSuggestions && e.suggestions.length > 0 ? (De(), vt(D, {
          key: 0,
          modelValue: i.value,
          "onUpdate:modelValue": y[1] || (y[1] = (w) => i.value = w),
          "close-on-content-click": !1,
          location: "bottom",
          offset: "4"
        }, {
          activator: ge(({ props: w }) => [
            S("div", Q(w, { style: { position: "absolute", width: "100%", height: "0" } }), null, 16)
          ]),
          default: ge(() => [
            b(A, {
              density: "compact",
              "max-height": "300",
              class: "suggestions-list"
            }, {
              default: ge(() => [
                (De(!0), Qe(ye, null, ba(e.suggestions, (w, T) => (De(), vt(P, {
                  key: T,
                  title: w.title || w,
                  subtitle: w.subtitle,
                  "prepend-icon": w.icon,
                  onClick: (M) => h(w)
                }, Zl({ _: 2 }, [
                  w.avatar ? {
                    name: "prepend",
                    fn: ge(() => [
                      b(k, { size: "32" }, {
                        default: ge(() => [
                          b(E, {
                            src: w.avatar
                          }, null, 8, ["src"])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    key: "0"
                  } : void 0
                ]), 1032, ["title", "subtitle", "prepend-icon", "onClick"]))), 128))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])) : Vt("", !0),
        e.showFilters ? (De(), Qe("div", ID, [
          b(I, null, {
            default: ge(() => [
              e.genreFilter ? (De(), vt(V, {
                key: 0,
                cols: "12",
                sm: "6",
                md: "4"
              }, {
                default: ge(() => [
                  b(N, {
                    modelValue: o.value,
                    "onUpdate:modelValue": [
                      y[2] || (y[2] = (w) => o.value = w),
                      g
                    ],
                    items: u,
                    label: "",
                    clearable: "",
                    variant: "outlined",
                    density: "compact"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              })) : Vt("", !0),
              e.priceFilter ? (De(), vt(V, {
                key: 1,
                cols: "12",
                sm: "6",
                md: "4"
              }, {
                default: ge(() => [
                  b(N, {
                    modelValue: r.value,
                    "onUpdate:modelValue": [
                      y[3] || (y[3] = (w) => r.value = w),
                      g
                    ],
                    items: c,
                    label: "",
                    clearable: "",
                    variant: "outlined",
                    density: "compact"
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              })) : Vt("", !0),
              e.sortOptions ? (De(), vt(V, {
                key: 2,
                cols: "12",
                sm: "6",
                md: "4"
              }, {
                default: ge(() => [
                  b(N, {
                    modelValue: s.value,
                    "onUpdate:modelValue": [
                      y[4] || (y[4] = (w) => s.value = w),
                      g
                    ],
                    items: e.sortOptions,
                    label: "",
                    variant: "outlined",
                    density: "compact"
                  }, null, 8, ["modelValue", "items"])
                ]),
                _: 1
              })) : Vt("", !0)
            ]),
            _: 1
          })
        ])) : Vt("", !0)
      ]);
    };
  }
}, qv = /* @__PURE__ */ Ua(ND, [["__scopeId", "data-v-163714b2"]]), DD = {
  key: 0,
  class: "mx-4",
  style: { "max-width": "400px", flex: "1" }
}, AD = {
  key: 1,
  class: "d-flex align-center"
}, TD = {
  key: 0,
  class: "d-flex align-center"
}, OD = {
  class: "pa-3",
  style: { width: "100%" }
}, $D = {
  __name: "AppHeader",
  setup(e) {
    const { mobile: t } = Vn(), n = Z(!1), a = Z(!1), l = Z(""), i = Z([]), o = Z({
      name: "",
      email: "user@example.com",
      id: 1
    });
    console.log(" :", o.value);
    const r = [
      {
        title: "",
        href: "/",
        icon: "mdi-home"
      },
      {
        title: " ",
        href: "/games/",
        icon: "mdi-gamepad-variant"
      },
      {
        title: "",
        href: "/upload/",
        icon: "mdi-upload"
      },
      {
        title: " ",
        href: "/games/?sort=popular",
        icon: "mdi-trophy"
      }
    ], s = [
      {
        title: " ",
        href: "/profile/",
        icon: "mdi-account"
      },
      {
        title: " ",
        href: "/profile/games/",
        icon: "mdi-gamepad"
      },
      {
        title: "",
        href: "/profile/favorites/",
        icon: "mdi-heart"
      },
      {
        title: "",
        href: "/profile/settings/",
        icon: "mdi-cog"
      },
      {
        title: "",
        href: "/logout/",
        icon: "mdi-logout"
      }
    ], d = (f) => {
      console.log(":", f), f.query && (window.location.href = `/games/?search=${encodeURIComponent(f.query)}`);
    }, u = (f) => {
      console.log(" :", f);
    }, c = (f) => {
      a.value && !f.target.closest(".header-search") && (a.value = !1);
    };
    return At(() => {
      document.addEventListener("click", c);
    }), Or(() => {
      document.removeEventListener("click", c);
    }), (f, v) => {
      const m = xe("v-icon"), h = xe("v-toolbar-title"), g = xe("v-spacer"), p = xe("v-btn"), y = xe("v-list-item-title"), _ = xe("v-list-item"), E = xe("v-list"), k = xe("v-menu"), P = xe("v-app-bar-nav-icon"), A = xe("v-expand-transition"), D = xe("v-app-bar"), N = xe("v-avatar"), V = xe("v-list-item-subtitle"), I = xe("v-divider"), w = xe("v-navigation-drawer");
      return De(), Qe(ye, null, [
        b(D, {
          color: "primary",
          density: "comfortable",
          elevation: "4"
        }, Zl({
          default: ge(() => [
            b(h, { class: "text-white d-flex align-center" }, {
              default: ge(() => [
                b(m, {
                  icon: "mdi-gamepad-variant",
                  class: "me-2",
                  size: "28"
                }),
                v[8] || (v[8] = S("a", {
                  href: "/",
                  style: { "text-decoration": "none" },
                  class: "text-white font-weight-bold"
                }, " GameSite ", -1))
              ]),
              _: 1
            }),
            bt(t) ? Vt("", !0) : (De(), Qe("div", DD, [
              b(qv, {
                modelValue: l.value,
                "onUpdate:modelValue": v[0] || (v[0] = (T) => l.value = T),
                placeholder: " ...",
                "show-suggestions": !0,
                suggestions: i.value,
                density: "compact",
                variant: "outlined",
                "hide-details": "",
                class: "header-search",
                onSearch: d,
                onSuggestionSelect: u
              }, null, 8, ["modelValue", "suggestions"])
            ])),
            b(g),
            bt(t) ? Vt("", !0) : (De(), Qe("div", AD, [
              (De(), Qe(ye, null, ba(r, (T) => b(p, {
                key: T.title,
                href: T.href,
                to: T.to,
                variant: "text",
                class: "text-white",
                "prepend-icon": T.icon
              }, {
                default: ge(() => [
                  ze(Re(T.title), 1)
                ]),
                _: 2
              }, 1032, ["href", "to", "prepend-icon"])), 64)),
              o.value ? (De(), Qe("div", TD, [
                b(p, {
                  href: "/profile/",
                  variant: "elevated",
                  color: "white",
                  class: "text-primary font-weight-bold me-2",
                  "prepend-icon": "mdi-account-circle",
                  size: "large"
                }, {
                  default: ge(() => [
                    ze(Re(o.value.name), 1)
                  ]),
                  _: 1
                }),
                b(k, { "offset-y": "" }, {
                  activator: ge(({ props: T }) => [
                    b(p, Q(T, {
                      icon: "mdi-dots-vertical",
                      variant: "text",
                      class: "text-white",
                      size: "small"
                    }), null, 16)
                  ]),
                  default: ge(() => [
                    b(E, null, {
                      default: ge(() => [
                        (De(), Qe(ye, null, ba(s, (T) => b(_, {
                          key: T.title,
                          href: T.href,
                          "prepend-icon": T.icon
                        }, {
                          default: ge(() => [
                            b(y, null, {
                              default: ge(() => [
                                ze(Re(T.title), 1)
                              ]),
                              _: 2
                            }, 1024)
                          ]),
                          _: 2
                        }, 1032, ["href", "prepend-icon"])), 64))
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ])) : (De(), vt(p, {
                key: 1,
                href: "/login/",
                variant: "outlined",
                class: "text-white ml-2",
                "prepend-icon": "mdi-login"
              }, {
                default: ge(() => [...v[9] || (v[9] = [
                  ze("  ", -1)
                ])]),
                _: 1
              }))
            ])),
            bt(t) ? (De(), Qe(ye, { key: 2 }, [
              b(p, {
                icon: "mdi-magnify",
                variant: "text",
                class: "text-white",
                onClick: v[1] || (v[1] = (T) => a.value = !a.value)
              }),
              b(P, {
                class: "text-white",
                onClick: v[2] || (v[2] = (T) => n.value = !n.value)
              })
            ], 64)) : Vt("", !0)
          ]),
          _: 2
        }, [
          bt(t) ? {
            name: "extension",
            fn: ge(() => [
              b(A, null, {
                default: ge(() => [
                  dt(S("div", OD, [
                    b(qv, {
                      modelValue: l.value,
                      "onUpdate:modelValue": v[3] || (v[3] = (T) => l.value = T),
                      placeholder: " ...",
                      "show-suggestions": !0,
                      suggestions: i.value,
                      density: "compact",
                      variant: "outlined",
                      "hide-details": "",
                      onSearch: d,
                      onSuggestionSelect: u
                    }, null, 8, ["modelValue", "suggestions"])
                  ], 512), [
                    [Nn, a.value]
                  ])
                ]),
                _: 1
              })
            ]),
            key: "0"
          } : void 0
        ]), 1024),
        b(w, {
          modelValue: n.value,
          "onUpdate:modelValue": v[7] || (v[7] = (T) => n.value = T),
          location: "right",
          temporary: "",
          width: "280"
        }, {
          default: ge(() => [
            b(E, null, {
              default: ge(() => [
                o.value ? (De(), vt(_, {
                  key: 0,
                  class: "pa-4"
                }, {
                  prepend: ge(() => [
                    b(N, { size: "40" }, {
                      default: ge(() => [
                        b(m, {
                          icon: "mdi-account-circle",
                          size: "40"
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  default: ge(() => [
                    b(y, { class: "font-weight-medium" }, {
                      default: ge(() => [
                        ze(Re(o.value.name), 1)
                      ]),
                      _: 1
                    }),
                    b(V, null, {
                      default: ge(() => [
                        ze(Re(o.value.email), 1)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })) : Vt("", !0),
                o.value ? (De(), vt(I, { key: 1 })) : Vt("", !0),
                (De(), Qe(ye, null, ba(r, (T) => b(_, {
                  key: T.title,
                  href: T.href,
                  to: T.to,
                  "prepend-icon": T.icon,
                  onClick: v[4] || (v[4] = (M) => n.value = !1)
                }, {
                  default: ge(() => [
                    b(y, null, {
                      default: ge(() => [
                        ze(Re(T.title), 1)
                      ]),
                      _: 2
                    }, 1024)
                  ]),
                  _: 2
                }, 1032, ["href", "to", "prepend-icon"])), 64)),
                b(I),
                o.value ? (De(), Qe(ye, { key: 2 }, ba(s, (T) => b(_, {
                  key: T.title,
                  href: T.href,
                  "prepend-icon": T.icon,
                  onClick: v[5] || (v[5] = (M) => n.value = !1)
                }, {
                  default: ge(() => [
                    b(y, null, {
                      default: ge(() => [
                        ze(Re(T.title), 1)
                      ]),
                      _: 2
                    }, 1024)
                  ]),
                  _: 2
                }, 1032, ["href", "prepend-icon"])), 64)) : (De(), vt(_, {
                  key: 3,
                  href: "/login/",
                  "prepend-icon": "mdi-login",
                  onClick: v[6] || (v[6] = (T) => n.value = !1)
                }, {
                  default: ge(() => [
                    b(y, null, {
                      default: ge(() => [...v[10] || (v[10] = [
                        ze("", -1)
                      ])]),
                      _: 1
                    })
                  ]),
                  _: 1
                }))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ], 64);
    };
  }
}, $p = /* @__PURE__ */ Ua($D, [["__scopeId", "data-v-508f4a4b"]]), BD = {}, MD = { class: "d-flex align-center mb-3" }, RD = { class: "d-flex flex-column" }, LD = { class: "d-flex align-center mb-2" }, FD = { class: "d-flex gap-2 mt-2" };
function HD(e, t) {
  const n = xe("v-icon"), a = xe("v-col"), l = xe("v-btn"), i = xe("v-row"), o = xe("v-divider"), r = xe("v-container"), s = xe("v-footer");
  return De(), vt(s, {
    color: "primary",
    class: "pa-6 mt-8"
  }, {
    default: ge(() => [
      b(r, null, {
        default: ge(() => [
          b(i, null, {
            default: ge(() => [
              b(a, {
                cols: "12",
                md: "4",
                class: "text-white"
              }, {
                default: ge(() => [
                  S("div", MD, [
                    b(n, {
                      icon: "mdi-gamepad-variant",
                      size: "32",
                      class: "me-2"
                    }),
                    t[0] || (t[0] = S("strong", { class: "text-h6" }, "GameSite", -1))
                  ]),
                  t[1] || (t[1] = S("div", { class: "text-body-2" }, "     ", -1)),
                  t[2] || (t[2] = S("div", { class: "text-caption mt-2" }, "     !", -1))
                ]),
                _: 1
              }),
              b(a, {
                cols: "12",
                md: "3",
                class: "text-white"
              }, {
                default: ge(() => [...t[3] || (t[3] = [
                  S("h4", { class: "text-subtitle-1 mb-3" }, "", -1),
                  S("div", { class: "d-flex flex-column" }, [
                    S("a", {
                      href: "/",
                      class: "text-white text-decoration-none mb-1 text-body-2"
                    }, ""),
                    S("a", {
                      href: "/games/",
                      class: "text-white text-decoration-none mb-1 text-body-2"
                    }, " "),
                    S("a", {
                      href: "/upload/",
                      class: "text-white text-decoration-none mb-1 text-body-2"
                    }, " "),
                    S("a", {
                      href: "/about/",
                      class: "text-white text-decoration-none mb-1 text-body-2"
                    }, " ")
                  ], -1)
                ])]),
                _: 1
              }),
              b(a, {
                cols: "12",
                md: "3",
                class: "text-white"
              }, {
                default: ge(() => [...t[4] || (t[4] = [
                  S("h4", { class: "text-subtitle-1 mb-3" }, "", -1),
                  S("div", { class: "d-flex flex-column" }, [
                    S("a", {
                      href: "/games/?genre=action",
                      class: "text-white text-decoration-none mb-1 text-body-2"
                    }, ""),
                    S("a", {
                      href: "/games/?genre=adventure",
                      class: "text-white text-decoration-none mb-1 text-body-2"
                    }, ""),
                    S("a", {
                      href: "/games/?genre=strategy",
                      class: "text-white text-decoration-none mb-1 text-body-2"
                    }, ""),
                    S("a", {
                      href: "/games/?genre=indie",
                      class: "text-white text-decoration-none mb-1 text-body-2"
                    }, "")
                  ], -1)
                ])]),
                _: 1
              }),
              b(a, {
                cols: "12",
                md: "2",
                class: "text-white"
              }, {
                default: ge(() => [
                  t[6] || (t[6] = S("h4", { class: "text-subtitle-1 mb-3" }, "", -1)),
                  S("div", RD, [
                    S("div", LD, [
                      b(n, {
                        icon: "mdi-email",
                        size: "16",
                        class: "me-2"
                      }),
                      t[5] || (t[5] = S("span", { class: "text-body-2" }, "info@gamesite.com", -1))
                    ]),
                    S("div", FD, [
                      b(l, {
                        icon: "mdi-github",
                        size: "small",
                        variant: "text",
                        href: "#",
                        class: "text-white"
                      }),
                      b(l, {
                        icon: "mdi-twitter",
                        size: "small",
                        variant: "text",
                        href: "#",
                        class: "text-white"
                      }),
                      b(l, {
                        icon: "mdi-discord",
                        size: "small",
                        variant: "text",
                        href: "#",
                        class: "text-white"
                      })
                    ])
                  ])
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          b(o, {
            class: "my-4",
            color: "white",
            opacity: "0.3"
          }),
          b(i, { align: "center" }, {
            default: ge(() => [
              b(a, {
                cols: "12",
                md: "6",
                class: "text-white"
              }, {
                default: ge(() => [...t[7] || (t[7] = [
                  S("div", { class: "text-body-2" }, " 2024 GameSite.   .", -1)
                ])]),
                _: 1
              }),
              b(a, {
                cols: "12",
                md: "6",
                class: "text-white text-md-right"
              }, {
                default: ge(() => [...t[8] || (t[8] = [
                  S("div", { class: "d-flex justify-md-end gap-4" }, [
                    S("a", {
                      href: "/privacy",
                      class: "text-white text-decoration-none text-body-2"
                    }, " "),
                    S("a", {
                      href: "/terms",
                      class: "text-white text-decoration-none text-body-2"
                    }, " ")
                  ], -1)
                ])]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ]),
    _: 1
  });
}
const Bp = /* @__PURE__ */ Ua(BD, [["render", HD]]), zD = {
  __name: "App",
  setup(e) {
    return (t, n) => {
      const a = xe("router-view"), l = xe("v-main"), i = xe("v-app");
      return De(), vt(i, null, {
        default: ge(() => [
          b($p),
          b(l, null, {
            default: ge(() => [
              b(a)
            ]),
            _: 1
          }),
          b(Bp)
        ]),
        _: 1
      });
    };
  }
};
function Mp(e, t = 0.011) {
  const n = typeof e == "string" ? parseFloat(e) : e;
  return !isFinite(n) || Number.isNaN(n) ? "$0.00" : n === 0 ? "" : `$${(n * t).toFixed(2)}`;
}
const jD = { class: "text-body-2 mb-2" }, WD = { class: "d-flex justify-space-between align-center mb-2" }, UD = { class: "text-success text-h6" }, GD = { class: "d-flex justify-space-between text-medium-emphasis text-caption" }, KD = {
  __name: "GameCard",
  props: {
    game: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = x(() => t.game.description ? t.game.description.length > 100 ? t.game.description.substring(0, 100) + "..." : t.game.description : ""), a = x(() => ({
      : "red",
      : "green",
      : "blue",
      RPG: "purple",
      : "orange",
      : "teal",
      : "amber",
      : "pink"
    })[t.game.genre] || "primary"), l = (r) => Mp(r), i = (r) => r ? new Date(r).toLocaleDateString("ru-RU") : "", o = () => {
      t.game.detail_url && (window.location.href = t.game.detail_url);
    };
    return (r, s) => {
      const d = xe("v-progress-circular"), u = xe("v-row"), c = xe("v-chip"), f = xe("v-img"), v = xe("v-card-title"), m = xe("v-icon"), h = xe("v-card-subtitle"), g = xe("v-card-item"), p = xe("v-card-text"), y = xe("v-btn"), _ = xe("v-card-actions"), E = xe("v-card");
      return De(), vt(E, {
        class: "game-card h-100",
        elevation: "3",
        onClick: o
      }, {
        default: ge(() => [
          b(f, {
            src: e.game.image_url,
            height: "220",
            cover: ""
          }, {
            placeholder: ge(() => [
              b(u, {
                class: "fill-height ma-0",
                align: "center",
                justify: "center"
              }, {
                default: ge(() => [
                  b(d, {
                    indeterminate: "",
                    color: "primary"
                  })
                ]),
                _: 1
              })
            ]),
            default: ge(() => [
              e.game.is_featured ? (De(), vt(c, {
                key: 0,
                class: "ma-2",
                color: "orange",
                size: "small",
                variant: "elevated"
              }, {
                default: ge(() => [...s[0] || (s[0] = [
                  ze("  ", -1)
                ])]),
                _: 1
              })) : Vt("", !0)
            ]),
            _: 1
          }, 8, ["src"]),
          b(g, null, {
            default: ge(() => [
              b(v, { class: "text-h6" }, {
                default: ge(() => [
                  ze(Re(e.game.title), 1)
                ]),
                _: 1
              }),
              b(h, { class: "d-flex align-center" }, {
                default: ge(() => [
                  b(m, {
                    icon: "mdi-account",
                    size: "18",
                    class: "me-1"
                  }),
                  ze(" " + Re(e.game.developer), 1)
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          b(p, null, {
            default: ge(() => [
              S("div", jD, Re(n.value), 1),
              S("div", WD, [
                b(c, {
                  color: a.value,
                  size: "small",
                  variant: "elevated"
                }, {
                  default: ge(() => [
                    ze(Re(e.game.genre), 1)
                  ]),
                  _: 1
                }, 8, ["color"]),
                S("div", UD, Re(l(e.game.price)), 1)
              ]),
              S("div", GD, [
                S("span", null, [
                  b(m, {
                    icon: "mdi-calendar",
                    size: "16",
                    class: "me-1"
                  }),
                  ze(" " + Re(i(e.game.release_date)), 1)
                ]),
                S("span", null, [
                  b(m, {
                    icon: "mdi-download",
                    size: "16",
                    class: "me-1"
                  }),
                  ze(" " + Re(e.game.download_count || 0), 1)
                ])
              ])
            ]),
            _: 1
          }),
          b(_, null, {
            default: ge(() => [
              b(y, {
                href: e.game.detail_url,
                color: "primary",
                variant: "elevated",
                block: "",
                "prepend-icon": "mdi-eye"
              }, {
                default: ge(() => [...s[1] || (s[1] = [
                  ze("  ", -1)
                ])]),
                _: 1
              }, 8, ["href"])
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
}, YD = /* @__PURE__ */ Ua(KD, [["__scopeId", "data-v-51066a2c"]]), qD = {
  key: 0,
  class: "pagination-container"
}, XD = {
  key: 0,
  class: "pagination-info mt-3 text-center"
}, JD = { class: "text-body-2 text-medium-emphasis" }, ZD = {
  key: 0,
  class: "d-flex align-center justify-center mt-2 gap-2"
}, QD = {
  key: 1,
  class: "d-flex align-center justify-center mt-2 gap-2"
}, eA = {
  __name: "Pagination",
  props: {
    //  
    modelValue: {
      type: Number,
      default: 1
    },
    //   
    totalItems: {
      type: Number,
      required: !0
    },
    //  
    pageSize: {
      type: Number,
      default: 10
    },
    //    
    totalVisible: {
      type: Number,
      default: 7
    },
    //  
    disabled: {
      type: Boolean,
      default: !1
    },
    //  
    size: {
      type: String,
      default: "default",
      validator: (e) => ["x-small", "small", "default", "large", "x-large"].includes(e)
    },
    //  
    variant: {
      type: String,
      default: "elevated",
      validator: (e) => ["text", "outlined", "plain", "elevated", "flat", "tonal"].includes(e)
    },
    // 
    color: {
      type: String,
      default: "primary"
    },
    // 
    density: {
      type: String,
      default: "default",
      validator: (e) => ["default", "comfortable", "compact"].includes(e)
    },
    //   / 
    showFirstLastPage: {
      type: Boolean,
      default: !0
    },
    //     
    showLabels: {
      type: Boolean,
      default: !1
    },
    //   ""
    prevLabel: {
      type: String,
      default: ""
    },
    //   ""
    nextLabel: {
      type: String,
      default: ""
    },
    //    
    showInfo: {
      type: Boolean,
      default: !0
    },
    //     
    showPageJump: {
      type: Boolean,
      default: !1
    },
    //    
    showPageSize: {
      type: Boolean,
      default: !1
    },
    //   
    pageSizeOptions: {
      type: Array,
      default: () => [10, 20, 50, 100]
    }
  },
  emits: ["update:modelValue", "page-change", "page-size-change"],
  setup(e, { emit: t }) {
    const n = e, a = t, l = Z(n.modelValue), i = Z(""), o = Z(n.pageSize), r = x(() => Math.ceil(n.totalItems / o.value)), s = x(() => (l.value - 1) * o.value + 1), d = x(() => {
      const m = l.value * o.value;
      return Math.min(m, n.totalItems);
    }), u = x(() => {
      const m = Number(i.value);
      return m >= 1 && m <= r.value && !isNaN(m);
    });
    me(() => n.modelValue, (m) => {
      m !== l.value && (l.value = m);
    }), me(() => n.pageSize, (m) => {
      m !== o.value && (o.value = m, l.value > 1 && c(1));
    }), me(r, (m) => {
      l.value > m && m > 0 && c(m);
    });
    const c = (m) => {
      m !== l.value && m >= 1 && m <= r.value && (l.value = m, a("update:modelValue", m), a("page-change", {
        page: m,
        pageSize: o.value,
        startItem: (m - 1) * o.value + 1,
        endItem: Math.min(m * o.value, n.totalItems)
      }));
    }, f = () => {
      u.value && (c(Number(i.value)), i.value = "");
    }, v = (m) => {
      if (m !== o.value) {
        o.value = m, a("page-size-change", m);
        const h = (l.value - 1) * n.pageSize + 1, g = Math.ceil(h / m);
        c(Math.min(g, Math.ceil(n.totalItems / m)));
      }
    };
    return (m, h) => {
      const g = xe("v-icon"), p = xe("v-btn"), y = xe("v-pagination"), _ = xe("v-text-field"), E = xe("v-select");
      return r.value > 1 ? (De(), Qe("div", qD, [
        b(y, {
          modelValue: l.value,
          "onUpdate:modelValue": [
            h[0] || (h[0] = (k) => l.value = k),
            c
          ],
          length: r.value,
          "total-visible": e.totalVisible,
          disabled: e.disabled,
          size: e.size,
          variant: e.variant,
          color: e.color,
          density: e.density,
          "show-first-last-page": e.showFirstLastPage,
          class: "pagination"
        }, Zl({ _: 2 }, [
          e.showLabels ? {
            name: "prev",
            fn: ge(({ props: k }) => [
              b(p, Q(k, {
                variant: e.variant,
                size: e.size,
                disabled: l.value <= 1,
                class: "pagination-btn"
              }), {
                default: ge(() => [
                  b(g, {
                    icon: "mdi-chevron-left",
                    class: "me-1"
                  }),
                  ze(" " + Re(e.prevLabel), 1)
                ]),
                _: 1
              }, 16, ["variant", "size", "disabled"])
            ]),
            key: "0"
          } : void 0,
          e.showLabels ? {
            name: "next",
            fn: ge(({ props: k }) => [
              b(p, Q(k, {
                variant: e.variant,
                size: e.size,
                disabled: l.value >= r.value,
                class: "pagination-btn"
              }), {
                default: ge(() => [
                  ze(Re(e.nextLabel) + " ", 1),
                  b(g, {
                    icon: "mdi-chevron-right",
                    class: "ms-1"
                  })
                ]),
                _: 1
              }, 16, ["variant", "size", "disabled"])
            ]),
            key: "1"
          } : void 0
        ]), 1032, ["modelValue", "length", "total-visible", "disabled", "size", "variant", "color", "density", "show-first-last-page"]),
        e.showInfo ? (De(), Qe("div", XD, [
          S("div", JD, "  " + Re(s.value) + "-" + Re(d.value) + "  " + Re(e.totalItems) + "  ", 1),
          e.showPageJump ? (De(), Qe("div", ZD, [
            h[4] || (h[4] = S("span", { class: "text-body-2" }, "  :", -1)),
            b(_, {
              modelValue: i.value,
              "onUpdate:modelValue": h[1] || (h[1] = (k) => i.value = k),
              modelModifiers: { number: !0 },
              type: "number",
              min: 1,
              max: r.value,
              density: "compact",
              variant: "outlined",
              style: { "max-width": "80px" },
              "hide-details": "",
              onKeyup: Rh(f, ["enter"])
            }, null, 8, ["modelValue", "max"]),
            b(p, {
              size: "small",
              variant: "outlined",
              disabled: !u.value,
              onClick: f
            }, {
              default: ge(() => [...h[3] || (h[3] = [
                ze("  ", -1)
              ])]),
              _: 1
            }, 8, ["disabled"])
          ])) : Vt("", !0),
          e.showPageSize && e.pageSizeOptions.length > 1 ? (De(), Qe("div", QD, [
            h[5] || (h[5] = S("span", { class: "text-body-2" }, " :", -1)),
            b(E, {
              modelValue: o.value,
              "onUpdate:modelValue": [
                h[2] || (h[2] = (k) => o.value = k),
                v
              ],
              items: e.pageSizeOptions,
              density: "compact",
              variant: "outlined",
              style: { "max-width": "100px" },
              "hide-details": ""
            }, null, 8, ["modelValue", "items"]),
            h[6] || (h[6] = S("span", { class: "text-body-2" }, "", -1))
          ])) : Vt("", !0)
        ])) : Vt("", !0)
      ])) : Vt("", !0);
    };
  }
}, tA = /* @__PURE__ */ Ua(eA, [["__scopeId", "data-v-93372103"]]), nA = { class: "text-caption" }, aA = {
  key: 0,
  class: "text-center mt-3"
}, lA = { class: "text-body-2" }, iA = {
  __name: "LoadingSpinner",
  props: {
    //   (0-100),    -   
    progress: {
      type: Number,
      default: null
    },
    //  
    size: {
      type: [Number, String],
      default: 40
    },
    //  
    width: {
      type: [Number, String],
      default: 4
    },
    //  
    color: {
      type: String,
      default: "primary"
    },
    //  
    rotate: {
      type: [Number, String],
      default: 0
    },
    //    
    showText: {
      type: Boolean,
      default: !1
    },
    //  
    text: {
      type: String,
      default: ""
    },
    //   
    message: {
      type: String,
      default: ""
    },
    //     
    centered: {
      type: Boolean,
      default: !1
    },
    //    
    fullHeight: {
      type: Boolean,
      default: !1
    },
    // Overlay  ( )
    overlay: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, n = x(() => {
      const a = [];
      return t.centered ? a.push("d-flex", "align-center", "justify-center", "flex-column") : a.push("text-center"), t.fullHeight && a.push("fill-height"), t.overlay && a.push("loading-overlay"), a;
    });
    return (a, l) => {
      const i = xe("v-progress-circular");
      return De(), Qe("div", {
        class: le(n.value)
      }, [
        b(i, {
          indeterminate: !e.progress,
          "model-value": e.progress,
          size: e.size,
          width: e.width,
          color: e.color,
          rotate: e.rotate
        }, Zl({ _: 2 }, [
          e.showText && (e.text || e.progress) ? {
            name: "default",
            fn: ge(() => [
              S("span", nA, Re(e.text || (e.progress ? `${Math.round(e.progress)}%` : "")), 1)
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["indeterminate", "model-value", "size", "width", "color", "rotate"]),
        e.message ? (De(), Qe("div", aA, [
          S("div", lA, Re(e.message), 1)
        ])) : Vt("", !0)
      ], 2);
    };
  }
}, oA = /* @__PURE__ */ Ua(iA, [["__scopeId", "data-v-ea74e957"]]), rA = { class: "games-header mb-6" }, sA = { class: "d-flex align-center justify-space-between mb-4" }, uA = { class: "d-flex align-center" }, cA = { class: "text-h4 mb-1" }, dA = { class: "text-body-2 text-medium-emphasis" }, fA = { class: "games-toolbar d-flex align-center mb-4" }, vA = {
  key: 0,
  class: "text-center py-8"
}, mA = {
  key: 1,
  class: "games-content"
}, hA = {
  key: 1,
  class: "games-list"
}, gA = { class: "d-flex align-center pa-4" }, yA = { class: "flex-grow-1" }, bA = { class: "d-flex align-center justify-space-between mb-2" }, pA = { class: "text-h6" }, SA = { class: "text-success text-h6" }, wA = { class: "d-flex align-center gap-3 mb-2" }, _A = { class: "text-body-2 text-medium-emphasis" }, xA = { class: "text-body-2 text-medium-emphasis" }, kA = { class: "text-body-2 text-truncate" }, CA = { class: "pagination-container mt-6" }, VA = {
  key: 2,
  class: "empty-state text-center py-12"
}, EA = {
  __name: "GameList",
  props: {
    //   
    games: {
      type: Array,
      default: () => []
    },
    //    ( )
    totalGames: {
      type: Number,
      default: 0
    },
    //  
    pageTitle: {
      type: String,
      default: " "
    },
    //  
    loading: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["page-change"],
  setup(e, { emit: t }) {
    const n = e, a = t, l = Z([]), i = Z(!1), o = x(() => !n.games || n.games.length === 0), r = async () => {
      i.value = !0;
      try {
        const _ = await (await fetch("/api/games/")).json();
        l.value = Array.isArray(_.results) ? _.results : [];
      } catch (y) {
        console.error("    ", y);
      } finally {
        i.value = !1;
      }
    };
    At(() => {
      o.value && r();
    });
    const s = x(() => o.value ? l.value : n.games), d = x(() => o.value ? i.value : n.loading), u = x(() => o.value ? s.value.length : n.totalGames), c = Z(1), f = Z("grid"), v = (y) => {
      c.value = y.page, a("page-change", {
        ...y,
        query: null,
        filters: {},
        sort: null
      });
    }, m = (y) => {
      y.detail_url && (window.location.href = y.detail_url);
    }, h = (y) => Mp(y), g = (y) => ({
      : "red",
      : "green",
      : "blue",
      RPG: "purple",
      : "orange",
      : "teal",
      : "amber",
      : "pink"
    })[y] || "primary", p = (y) => {
      const _ = y % 10, E = y % 100;
      if (E >= 11 && E <= 14)
        return "";
      switch (_) {
        case 1:
          return "";
        case 2:
        case 3:
        case 4:
          return "";
        default:
          return "";
      }
    };
    return (y, _) => {
      const E = xe("v-icon"), k = xe("v-btn"), P = xe("v-btn-toggle"), A = xe("v-col"), D = xe("v-row"), N = xe("v-progress-circular"), V = xe("v-img"), I = xe("v-chip"), w = xe("v-card"), T = xe("v-container");
      return De(), vt(T, { class: "py-8" }, {
        default: ge(() => [
          S("div", rA, [
            S("div", sA, [
              S("div", uA, [
                b(E, {
                  icon: "mdi-gamepad-variant",
                  class: "me-2",
                  size: "32"
                }),
                S("div", null, [
                  S("h1", cA, Re(e.pageTitle), 1),
                  S("div", dA, Re(u.value) + " " + Re(p(u.value)) + "  ", 1)
                ])
              ])
            ])
          ]),
          S("div", fA, [
            b(P, {
              modelValue: f.value,
              "onUpdate:modelValue": _[0] || (_[0] = (M) => f.value = M),
              mandatory: "",
              variant: "outlined",
              density: "compact"
            }, {
              default: ge(() => [
                b(k, {
                  value: "grid",
                  icon: "mdi-view-grid"
                }),
                b(k, {
                  value: "list",
                  icon: "mdi-view-list"
                })
              ]),
              _: 1
            }, 8, ["modelValue"])
          ]),
          d.value ? (De(), Qe("div", vA, [
            b(oA, {
              message: " ...",
              centered: !0
            })
          ])) : s.value.length > 0 ? (De(), Qe("div", mA, [
            f.value === "grid" ? (De(), vt(D, { key: 0 }, {
              default: ge(() => [
                (De(!0), Qe(ye, null, ba(s.value, (M) => (De(), vt(A, {
                  key: M.id,
                  cols: "12",
                  sm: "6",
                  md: "4",
                  lg: "3",
                  class: "mb-4"
                }, {
                  default: ge(() => [
                    b(YD, { game: M }, null, 8, ["game"])
                  ]),
                  _: 2
                }, 1024))), 128))
              ]),
              _: 1
            })) : (De(), Qe("div", hA, [
              (De(!0), Qe(ye, null, ba(s.value, (M) => (De(), vt(w, {
                key: M.id,
                variant: "outlined",
                class: "mb-3 game-list-item",
                onClick: (W) => m(M)
              }, {
                default: ge(() => [
                  S("div", gA, [
                    b(V, {
                      src: M.image_url,
                      width: "80",
                      height: "80",
                      cover: "",
                      class: "rounded me-4"
                    }, {
                      placeholder: ge(() => [
                        b(N, {
                          indeterminate: "",
                          color: "primary",
                          size: "24"
                        })
                      ]),
                      _: 1
                    }, 8, ["src"]),
                    S("div", yA, [
                      S("div", bA, [
                        S("h3", pA, Re(M.title), 1),
                        S("div", SA, Re(h(M.price)), 1)
                      ]),
                      S("div", wA, [
                        b(I, {
                          size: "small",
                          color: g(M.genre),
                          variant: "elevated"
                        }, {
                          default: ge(() => [
                            ze(Re(M.genre), 1)
                          ]),
                          _: 2
                        }, 1032, ["color"]),
                        S("span", _A, [
                          b(E, {
                            icon: "mdi-account",
                            size: "16",
                            class: "me-1"
                          }),
                          ze(" " + Re(M.developer), 1)
                        ]),
                        S("span", xA, [
                          b(E, {
                            icon: "mdi-download",
                            size: "16",
                            class: "me-1"
                          }),
                          ze(" " + Re(M.download_count || 0), 1)
                        ])
                      ]),
                      S("div", kA, Re(M.description), 1)
                    ]),
                    b(k, {
                      color: "primary",
                      variant: "elevated",
                      "prepend-icon": "mdi-eye",
                      class: "ms-4",
                      onClick: ea((W) => m(M), ["stop"])
                    }, {
                      default: ge(() => [..._[2] || (_[2] = [
                        ze("  ", -1)
                      ])]),
                      _: 1
                    }, 8, ["onClick"])
                  ])
                ]),
                _: 2
              }, 1032, ["onClick"]))), 128))
            ])),
            S("div", CA, [
              b(tA, {
                modelValue: c.value,
                "onUpdate:modelValue": _[1] || (_[1] = (M) => c.value = M),
                "total-items": e.totalGames,
                "page-size": y.pageSize,
                "show-info": !0,
                "show-page-jump": !0,
                "show-page-size": !1,
                onPageChange: v
              }, null, 8, ["modelValue", "total-items", "page-size"])
            ])
          ])) : (De(), Qe("div", VA, [
            b(E, {
              icon: "mdi-gamepad-variant-outline",
              size: "64",
              class: "mb-4 text-medium-emphasis"
            }),
            _[4] || (_[4] = S("div", { class: "text-h5 mb-2" }, "     ", -1)),
            _[5] || (_[5] = S("div", { class: "text-body-1 text-medium-emphasis mb-4" }, "  ,   ! ", -1)),
            b(k, {
              color: "primary",
              href: "/upload/",
              "prepend-icon": "mdi-upload"
            }, {
              default: ge(() => [..._[3] || (_[3] = [
                ze("   ", -1)
              ])]),
              _: 1
            })
          ]))
        ]),
        _: 1
      });
    };
  }
}, Rp = /* @__PURE__ */ Ua(EA, [["__scopeId", "data-v-b7b08e00"]]), PA = { class: "file-upload" }, IA = { class: "drop-content" }, NA = { class: "text-h6 mb-2" }, DA = { class: "text-body-2 text-medium-emphasis" }, AA = {
  key: 1,
  class: "preview-section mt-4"
}, TA = {
  key: 0,
  class: "preview-image"
}, OA = {
  key: 1,
  class: "preview-file text-center pa-4"
}, $A = { class: "text-caption text-truncate" }, BA = { class: "d-flex justify-space-between align-center" }, MA = { class: "file-info" }, RA = { class: "text-body-2 font-weight-medium text-truncate" }, LA = { class: "text-caption text-medium-emphasis" }, FA = {
  key: 2,
  class: "errors-section mt-3"
}, HA = {
  __name: "FileUpload",
  props: {
    // v-model
    modelValue: {
      type: [File, Array],
      default: null
    },
    //  
    label: {
      type: String,
      default: " "
    },
    //   
    accept: {
      type: String,
      default: "*"
    },
    //  
    multiple: {
      type: Boolean,
      default: !1
    },
    //  
    rules: {
      type: Array,
      default: () => []
    },
    //     
    maxSize: {
      type: Number,
      default: 10 * 1024 * 1024
      // 10MB
    },
    //   
    maxFiles: {
      type: Number,
      default: 10
    },
    //  
    preview: {
      type: Boolean,
      default: !1
    },
    //  drag & drop
    enableDragDrop: {
      type: Boolean,
      default: !0
    },
    // 
    prependIcon: {
      type: String,
      default: "mdi-paperclip"
    },
    //  
    variant: {
      type: String,
      default: "outlined"
    },
    // 
    density: {
      type: String,
      default: "default"
    },
    //  
    clearable: {
      type: Boolean,
      default: !0
    },
    //  
    showSize: {
      type: Boolean,
      default: !0
    },
    //  
    chips: {
      type: Boolean,
      default: !0
    },
    //  
    counter: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue", "change", "error"],
  setup(e, { emit: t }) {
    const n = e, a = t, l = Z(n.multiple ? [] : null), i = Z([]), o = Z([]), r = Z(!1), s = Z(null), d = x(() => {
      var V;
      return n.multiple ? ((V = l.value) == null ? void 0 : V.length) > 0 : l.value !== null;
    }), u = x(() => r.value ? "mdi-cloud-upload" : d.value ? "mdi-check-circle" : "mdi-cloud-upload-outline"), c = x(() => d.value ? " " : r.value ? "  " : "  "), f = x(() => d.value ? ` : ${n.multiple ? l.value.length : 1}` : `    (. ${D(n.maxSize)})`), v = x(() => {
      const V = [...n.rules];
      return V.push((I) => {
        if (!I) return !0;
        const w = Array.isArray(I) ? I : [I];
        for (const T of w)
          if (T && T.size > n.maxSize)
            return ` "${T.name}"    ${D(n.maxSize)}`;
        return !0;
      }), n.multiple && V.push((I) => !I || !Array.isArray(I) ? !0 : I.length > n.maxFiles ? `  : ${n.maxFiles}` : !0), V;
    });
    me(() => n.modelValue, (V) => {
      l.value = V, E();
    }, { immediate: !0 }), me(l, (V) => {
      a("update:modelValue", V), a("change", V), E();
    });
    const m = (V) => {
      var w;
      o.value = [];
      const I = V.target.files || V;
      if (I)
        if (n.multiple) {
          const T = Array.from(I);
          if (T.length + (((w = l.value) == null ? void 0 : w.length) || 0) > n.maxFiles) {
            P(`  : ${n.maxFiles}`);
            return;
          }
          l.value = [...l.value || [], ...T];
        } else
          l.value = I[0] || null;
    }, h = (V) => {
      V.preventDefault(), r.value = !0;
    }, g = (V) => {
      V.preventDefault(), r.value = !1;
    }, p = (V) => {
      var T;
      V.preventDefault(), r.value = !1;
      const I = Array.from(V.dataTransfer.files);
      if (I.length === 0) return;
      o.value = [];
      const w = I.filter((M) => n.accept === "*" ? !0 : n.accept.split(",").map((J) => J.trim()).some((J) => J.startsWith(".") ? M.name.toLowerCase().endsWith(J.toLowerCase()) : M.type.includes(J.replace("*", ""))));
      if (w.length !== I.length && P("    "), n.multiple) {
        if (w.length + (((T = l.value) == null ? void 0 : T.length) || 0) > n.maxFiles) {
          P(`  : ${n.maxFiles}`);
          return;
        }
        l.value = [...l.value || [], ...w];
      } else
        l.value = w[0] || null;
    }, y = () => {
      l.value = n.multiple ? [] : null, i.value = [], o.value = [];
    }, _ = () => {
      var I, w;
      const V = (w = (I = s.value) == null ? void 0 : I.closest(".file-upload")) == null ? void 0 : w.querySelector('input[type="file"]');
      V && V.click();
    }, E = () => {
      if (!n.preview) return;
      i.value = [], (n.multiple ? l.value || [] : l.value ? [l.value] : []).forEach((I, w) => {
        const T = {
          file: I,
          name: I.name,
          size: I.size,
          type: I.type.startsWith("image/") ? "image" : "file",
          url: "",
          uploading: !1,
          progress: 0
        };
        if (T.type === "image") {
          const M = new FileReader();
          M.onload = (W) => {
            T.url = W.target.result;
          }, M.readAsDataURL(I);
        }
        i.value.push(T);
      });
    }, k = (V) => {
      n.multiple ? (l.value.splice(V, 1), i.value.splice(V, 1)) : (l.value = null, i.value = []);
    }, P = (V) => {
      o.value.includes(V) || (o.value.push(V), a("error", V));
    }, A = (V) => {
      o.value.splice(V, 1);
    }, D = (V) => {
      if (!V) return "0 ";
      const I = ["", "", "", ""];
      if (V === 0) return "0 ";
      const w = Math.floor(Math.log(V) / Math.log(1024));
      return Math.round(V / Math.pow(1024, w) * 100) / 100 + " " + I[w];
    }, N = (V) => {
      const I = V.type.toLowerCase();
      return I.includes("image") ? "mdi-file-image" : I.includes("video") ? "mdi-file-video" : I.includes("audio") ? "mdi-file-music" : I.includes("pdf") ? "mdi-file-pdf-box" : I.includes("zip") || I.includes("rar") || I.includes("7z") ? "mdi-folder-zip" : I.includes("text") ? "mdi-file-document" : V.name.endsWith(".exe") ? "mdi-application" : "mdi-file";
    };
    return (V, I) => {
      const w = xe("v-file-input"), T = xe("v-icon"), M = xe("v-btn"), W = xe("v-progress-circular"), J = xe("v-row"), ee = xe("v-img"), Y = xe("v-progress-linear"), L = xe("v-card-text"), H = xe("v-card"), j = xe("v-col"), U = xe("v-alert");
      return De(), Qe("div", PA, [
        b(w, {
          modelValue: l.value,
          "onUpdate:modelValue": I[0] || (I[0] = (F) => l.value = F),
          label: e.label,
          accept: e.accept,
          multiple: e.multiple,
          rules: v.value,
          "prepend-icon": e.prependIcon,
          variant: e.variant,
          density: e.density,
          clearable: e.clearable,
          "show-size": e.showSize,
          chips: e.chips,
          counter: e.counter,
          class: "file-input",
          onChange: m,
          "onClick:clear": y
        }, Zl({ _: 2 }, [
          V.$slots.prepend ? {
            name: "prepend",
            fn: ge(() => [
              Ys(V.$slots, "prepend", {}, void 0, !0)
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["modelValue", "label", "accept", "multiple", "rules", "prepend-icon", "variant", "density", "clearable", "show-size", "chips", "counter"]),
        e.enableDragDrop ? (De(), Qe("div", {
          key: 0,
          ref_key: "dropZone",
          ref: s,
          class: le(["drag-drop-zone", { "drag-over": r.value, "has-files": d.value }]),
          onDragover: ea(h, ["prevent"]),
          onDragleave: ea(g, ["prevent"]),
          onDrop: ea(p, ["prevent"]),
          onClick: _
        }, [
          S("div", IA, [
            b(T, {
              icon: u.value,
              size: "48",
              class: "mb-3",
              color: r.value ? "primary" : "grey"
            }, null, 8, ["icon", "color"]),
            S("div", NA, Re(c.value), 1),
            S("div", DA, Re(f.value), 1),
            d.value ? Vt("", !0) : (De(), vt(M, {
              key: 0,
              variant: "outlined",
              class: "mt-3",
              onClick: ea(_, ["stop"])
            }, {
              default: ge(() => [...I[1] || (I[1] = [
                ze("   ", -1)
              ])]),
              _: 1
            }))
          ])
        ], 34)) : Vt("", !0),
        e.preview && i.value.length > 0 ? (De(), Qe("div", AA, [
          I[2] || (I[2] = S("h4", { class: "text-subtitle-1 mb-3" }, " :", -1)),
          b(J, null, {
            default: ge(() => [
              (De(!0), Qe(ye, null, ba(i.value, (F, oe) => (De(), vt(j, {
                key: oe,
                cols: e.multiple ? 6 : 12,
                md: e.multiple ? 4 : 6
              }, {
                default: ge(() => [
                  b(H, {
                    elevation: "2",
                    class: "preview-card"
                  }, {
                    default: ge(() => [
                      F.type === "image" ? (De(), Qe("div", TA, [
                        b(ee, {
                          src: F.url,
                          alt: F.name,
                          height: "150",
                          cover: "",
                          class: "rounded-t"
                        }, {
                          placeholder: ge(() => [
                            b(J, {
                              class: "fill-height ma-0",
                              align: "center",
                              justify: "center"
                            }, {
                              default: ge(() => [
                                b(W, {
                                  indeterminate: "",
                                  color: "primary"
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["src", "alt"])
                      ])) : (De(), Qe("div", OA, [
                        b(T, {
                          icon: N(F.file),
                          size: "64",
                          class: "mb-2"
                        }, null, 8, ["icon"]),
                        S("div", $A, Re(F.name), 1)
                      ])),
                      b(L, { class: "pa-3" }, {
                        default: ge(() => [
                          S("div", BA, [
                            S("div", MA, [
                              S("div", RA, Re(F.name), 1),
                              S("div", LA, Re(D(F.size)), 1)
                            ]),
                            b(M, {
                              icon: "mdi-close",
                              size: "small",
                              variant: "text",
                              onClick: (ve) => k(oe)
                            }, null, 8, ["onClick"])
                          ]),
                          F.uploading ? (De(), vt(Y, {
                            key: 0,
                            "model-value": F.progress,
                            color: "primary",
                            height: "4",
                            class: "mt-2"
                          }, null, 8, ["model-value"])) : Vt("", !0)
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1032, ["cols", "md"]))), 128))
            ]),
            _: 1
          })
        ])) : Vt("", !0),
        o.value.length > 0 ? (De(), Qe("div", FA, [
          (De(!0), Qe(ye, null, ba(o.value, (F, oe) => (De(), vt(U, {
            key: oe,
            type: "error",
            variant: "tonal",
            density: "compact",
            closable: "",
            class: "mb-2",
            "onClick:close": (ve) => A(oe)
          }, {
            default: ge(() => [
              ze(Re(F), 1)
            ]),
            _: 2
          }, 1032, ["onClick:close"]))), 128))
        ])) : Vt("", !0)
      ]);
    };
  }
}, Fs = /* @__PURE__ */ Ua(HA, [["__scopeId", "data-v-ca3f449d"]]), zA = { class: "mb-6" }, jA = { class: "mb-6" }, WA = { class: "mb-6" }, UA = { class: "d-flex gap-3" }, GA = {
  __name: "GameUpload",
  setup(e) {
    const t = Z(null), n = Z(!1), a = Z(!1), l = Z(!1), i = Z(0), o = [
      "",
      "",
      "",
      "RPG",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ], r = It({
      title: "",
      description: "",
      developer: "",
      genre: "",
      price: 0,
      release_date: "",
      game_file: null,
      cover_image: null,
      screenshots: [],
      system_requirements: {
        os: "",
        processor: "",
        memory: "",
        graphics: "",
        storage: ""
      }
    }), s = {
      required: (c) => !!c || "    ",
      positiveNumber: (c) => c >= 0 || "    "
    }, d = async () => {
      if (n.value) {
        a.value = !0, l.value = !0, i.value = 0;
        try {
          const c = new FormData();
          Object.keys(r).forEach((v) => {
            v === "system_requirements" ? c.append(v, JSON.stringify(r[v])) : v === "screenshots" ? r[v].forEach((m, h) => {
              c.append(`screenshot_${h}`, m);
            }) : r[v] !== null && r[v] !== "" && c.append(v, r[v]);
          });
          const f = setInterval(() => {
            i.value += Math.random() * 10, i.value >= 100 && (i.value = 100, clearInterval(f), setTimeout(() => {
              l.value = !1, a.value = !1, u();
            }, 1e3));
          }, 200);
        } catch (c) {
          console.error("   :", c), l.value = !1, a.value = !1;
        }
      }
    }, u = () => {
      t.value && t.value.reset(), Object.assign(r, {
        title: "",
        description: "",
        developer: "",
        genre: "",
        price: 0,
        release_date: "",
        game_file: null,
        cover_image: null,
        screenshots: [],
        system_requirements: {
          os: "",
          processor: "",
          memory: "",
          graphics: "",
          storage: ""
        }
      });
    };
    return (c, f) => {
      const v = xe("v-icon"), m = xe("v-card-title"), h = xe("v-text-field"), g = xe("v-textarea"), p = xe("v-select"), y = xe("v-divider"), _ = xe("v-btn"), E = xe("v-form"), k = xe("v-card-text"), P = xe("v-card"), A = xe("v-col"), D = xe("v-row"), N = xe("v-progress-linear"), V = xe("v-dialog"), I = xe("v-container");
      return De(), vt(I, { class: "py-8" }, {
        default: ge(() => [
          b(D, { justify: "center" }, {
            default: ge(() => [
              b(A, {
                cols: "12",
                md: "8",
                lg: "6"
              }, {
                default: ge(() => [
                  b(P, { elevation: "3" }, {
                    default: ge(() => [
                      b(m, { class: "text-h5 pa-6" }, {
                        default: ge(() => [
                          b(v, {
                            icon: "mdi-upload",
                            class: "me-2"
                          }),
                          f[16] || (f[16] = ze("    ", -1))
                        ]),
                        _: 1
                      }),
                      b(k, { class: "pa-6" }, {
                        default: ge(() => [
                          b(E, {
                            ref_key: "gameForm",
                            ref: t,
                            modelValue: n.value,
                            "onUpdate:modelValue": f[14] || (f[14] = (w) => n.value = w),
                            onSubmit: ea(d, ["prevent"])
                          }, {
                            default: ge(() => [
                              S("div", zA, [
                                f[17] || (f[17] = S("h3", { class: "text-h6 mb-4" }, " ", -1)),
                                b(h, {
                                  modelValue: r.title,
                                  "onUpdate:modelValue": f[0] || (f[0] = (w) => r.title = w),
                                  label: " ",
                                  rules: [s.required],
                                  "prepend-inner-icon": "mdi-gamepad-variant",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue", "rules"]),
                                b(g, {
                                  modelValue: r.description,
                                  "onUpdate:modelValue": f[1] || (f[1] = (w) => r.description = w),
                                  label: " ",
                                  rules: [s.required],
                                  "prepend-inner-icon": "mdi-text",
                                  variant: "outlined",
                                  rows: "4",
                                  class: "mb-4"
                                }, null, 8, ["modelValue", "rules"]),
                                b(h, {
                                  modelValue: r.developer,
                                  "onUpdate:modelValue": f[2] || (f[2] = (w) => r.developer = w),
                                  label: "",
                                  rules: [s.required],
                                  "prepend-inner-icon": "mdi-account",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue", "rules"]),
                                b(p, {
                                  modelValue: r.genre,
                                  "onUpdate:modelValue": f[3] || (f[3] = (w) => r.genre = w),
                                  items: o,
                                  label: "",
                                  rules: [s.required],
                                  "prepend-inner-icon": "mdi-tag",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue", "rules"]),
                                b(h, {
                                  modelValue: r.price,
                                  "onUpdate:modelValue": f[4] || (f[4] = (w) => r.price = w),
                                  label: " ()",
                                  type: "number",
                                  min: "0",
                                  step: "0.01",
                                  rules: [s.required, s.positiveNumber],
                                  "prepend-inner-icon": "mdi-currency-rub",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue", "rules"]),
                                b(h, {
                                  modelValue: r.release_date,
                                  "onUpdate:modelValue": f[5] || (f[5] = (w) => r.release_date = w),
                                  label: " ",
                                  type: "date",
                                  rules: [s.required],
                                  "prepend-inner-icon": "mdi-calendar",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue", "rules"])
                              ]),
                              b(y, { class: "my-6" }),
                              S("div", jA, [
                                f[18] || (f[18] = S("h3", { class: "text-h6 mb-4" }, "", -1)),
                                b(Fs, {
                                  modelValue: r.game_file,
                                  "onUpdate:modelValue": f[6] || (f[6] = (w) => r.game_file = w),
                                  label: " ",
                                  accept: ".zip,.rar,.7z,.exe",
                                  rules: [s.required],
                                  "max-size": 500 * 1024 * 1024,
                                  class: "mb-4"
                                }, null, 8, ["modelValue", "rules"]),
                                b(Fs, {
                                  modelValue: r.cover_image,
                                  "onUpdate:modelValue": f[7] || (f[7] = (w) => r.cover_image = w),
                                  label: " ",
                                  accept: "image/*",
                                  rules: [s.required],
                                  "max-size": 5 * 1024 * 1024,
                                  preview: !0,
                                  class: "mb-4"
                                }, null, 8, ["modelValue", "rules"]),
                                b(Fs, {
                                  modelValue: r.screenshots,
                                  "onUpdate:modelValue": f[8] || (f[8] = (w) => r.screenshots = w),
                                  label: " ()",
                                  accept: "image/*",
                                  multiple: !0,
                                  "max-size": 5 * 1024 * 1024,
                                  preview: !0,
                                  class: "mb-4"
                                }, null, 8, ["modelValue"])
                              ]),
                              b(y, { class: "my-6" }),
                              S("div", WA, [
                                f[19] || (f[19] = S("h3", { class: "text-h6 mb-4" }, " ", -1)),
                                b(h, {
                                  modelValue: r.system_requirements.os,
                                  "onUpdate:modelValue": f[9] || (f[9] = (w) => r.system_requirements.os = w),
                                  label: " ",
                                  "prepend-inner-icon": "mdi-desktop-classic",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue"]),
                                b(h, {
                                  modelValue: r.system_requirements.processor,
                                  "onUpdate:modelValue": f[10] || (f[10] = (w) => r.system_requirements.processor = w),
                                  label: "",
                                  "prepend-inner-icon": "mdi-chip",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue"]),
                                b(h, {
                                  modelValue: r.system_requirements.memory,
                                  "onUpdate:modelValue": f[11] || (f[11] = (w) => r.system_requirements.memory = w),
                                  label: " ",
                                  "prepend-inner-icon": "mdi-memory",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue"]),
                                b(h, {
                                  modelValue: r.system_requirements.graphics,
                                  "onUpdate:modelValue": f[12] || (f[12] = (w) => r.system_requirements.graphics = w),
                                  label: "",
                                  "prepend-inner-icon": "mdi-expansion-card",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue"]),
                                b(h, {
                                  modelValue: r.system_requirements.storage,
                                  "onUpdate:modelValue": f[13] || (f[13] = (w) => r.system_requirements.storage = w),
                                  label: "  ",
                                  "prepend-inner-icon": "mdi-harddisk",
                                  variant: "outlined",
                                  class: "mb-4"
                                }, null, 8, ["modelValue"])
                              ]),
                              S("div", UA, [
                                b(_, {
                                  type: "submit",
                                  color: "primary",
                                  size: "large",
                                  loading: a.value,
                                  disabled: !n.value,
                                  "prepend-icon": "mdi-upload"
                                }, {
                                  default: ge(() => [...f[20] || (f[20] = [
                                    ze("   ", -1)
                                  ])]),
                                  _: 1
                                }, 8, ["loading", "disabled"]),
                                b(_, {
                                  variant: "outlined",
                                  size: "large",
                                  onClick: u
                                }, {
                                  default: ge(() => [...f[21] || (f[21] = [
                                    ze("  ", -1)
                                  ])]),
                                  _: 1
                                })
                              ])
                            ]),
                            _: 1
                          }, 8, ["modelValue"])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          b(V, {
            modelValue: l.value,
            "onUpdate:modelValue": f[15] || (f[15] = (w) => l.value = w),
            persistent: "",
            "max-width": "400"
          }, {
            default: ge(() => [
              b(P, null, {
                default: ge(() => [
                  b(m, null, {
                    default: ge(() => [...f[22] || (f[22] = [
                      ze(" ", -1)
                    ])]),
                    _: 1
                  }),
                  b(k, null, {
                    default: ge(() => [
                      b(N, {
                        "model-value": i.value,
                        height: "25",
                        striped: "",
                        color: "primary"
                      }, {
                        default: ge(({ value: w }) => [
                          S("strong", null, Re(Math.ceil(w)) + "%", 1)
                        ]),
                        _: 1
                      }, 8, ["model-value"]),
                      f[23] || (f[23] = S("div", { class: "text-center mt-3" }, " , ... ", -1))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue"])
        ]),
        _: 1
      });
    };
  }
}, cs = Wg({
  components: hD,
  directives: ED
}), Xv = document.getElementById("app");
if (Xv) {
  const e = [
    { path: "/", component: Rp },
    { path: "/upload", component: GA },
    { path: "/upload/", redirect: "/upload" }
  ], t = wx({
    history: Y_(),
    routes: e
  });
  Rr(zD).use(cs).use(t).mount(Xv);
}
const Jv = document.getElementById("app-header");
Jv && Rr($p).use(cs).mount(Jv);
const Zv = document.getElementById("app-footer");
Zv && Rr(Bp).use(cs).mount(Zv);
const Hs = document.getElementById("game-list-root");
if (Hs) {
  let e = [];
  try {
    const n = Hs.getAttribute("data-games") || "[]";
    e = JSON.parse(n);
  } catch (n) {
    console.error("Failed to parse games JSON from data attribute", n);
  }
  const t = Rr(Rp, { games: e });
  t.use(cs), t.mount(Hs);
}
